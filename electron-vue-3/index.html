<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Electron-vue开发实战2——引入基于Lodash的JSON数据库lowdb"><meta name="keywords" content="前端,Vue,Electron,Electron-vue"><meta name="author" content="Molunerfinn"><meta name="copyright" content="Molunerfinn"><title>Electron-vue开发实战2——引入基于Lodash的JSON数据库lowdb | MARKSZのBlog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2358465699478507",enable_page_level_ads:"true"})</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?19a7ebdbb87f2403773c7ab0cae16d21";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-105869658-1","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"BGLU1ICJFH",apiKey:"85948beeaf121424b806828adc21c8b5",indexName:"mofinn",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#说明"><span class="toc-number">2.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据持久化存储的必要性"><span class="toc-number">3.</span> <span class="toc-text">数据持久化存储的必要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#纯JavaScript数据库的选择"><span class="toc-number">4.</span> <span class="toc-text">纯JavaScript数据库的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#比较"><span class="toc-number">4.1.</span> <span class="toc-text">比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lowdb的初始化"><span class="toc-number">5.</span> <span class="toc-text">lowdb的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#踩坑"><span class="toc-number">5.1.</span> <span class="toc-text">踩坑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-renderer进程要使用remote模块"><span class="toc-number">5.1.1.</span> <span class="toc-text">1. renderer进程要使用remote模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-开发模式和生产模式初始化路径问题"><span class="toc-number">5.1.2.</span> <span class="toc-text">2. 开发模式和生产模式初始化路径问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-初始化数据"><span class="toc-number">5.1.3.</span> <span class="toc-text">3. 初始化数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-唯一标识的id字段"><span class="toc-number">5.1.4.</span> <span class="toc-text">4. 唯一标识的id字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化完整代码"><span class="toc-number">5.2.</span> <span class="toc-text">初始化完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lowdb的基本操作"><span class="toc-number">6.</span> <span class="toc-text">lowdb的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建"><span class="toc-number">6.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取"><span class="toc-number">6.2.</span> <span class="toc-text">读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新"><span class="toc-number">6.3.</span> <span class="toc-text">更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除"><span class="toc-number">6.4.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lowdb实际使用的坑"><span class="toc-number">7.</span> <span class="toc-text">lowdb实际使用的坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue里使用lowdb的便捷方法"><span class="toc-number">8.</span> <span class="toc-text">Vue里使用lowdb的便捷方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ws1.sinaimg.cn/large/8700af19ly1fm4iuz15lsj20ix0iw0u8"></div><div class="author-info__name text-center">Molunerfinn</div><div class="author-info__description text-center">For MElody</div><div class="follow-button"><a href="https://github.com/Molunerfinn">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">23</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com">Molunerfinn</a><a class="author-info-links__name text-center" href="https://elody-07.github.io">Elody</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">MARKSZのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Electron-vue开发实战2——引入基于Lodash的JSON数据库lowdb</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/">Web</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/开发/">开发</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.2k</span><span class="post-meta__separator">|</span><span>Reading time: 10 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="数据持久化存储的必要性"><a href="#数据持久化存储的必要性" class="headerlink" title="数据持久化存储的必要性"></a>数据持久化存储的必要性</h2><p>不像平时很多人写的一些demo，就是请求一下api然后把web页面展示出来就了事了。electron应用毕竟是个桌面级应用，如果思维还留在纯web开发的思路上，那么也就失去了用electron的意义了吧。</p><p>数据持久化存储实际上对于后端很熟悉。通常是指的是把内存里的数据以不同的存储模型存储到磁盘上，在需要的时候再从存储模型里读取读入内存中的整个流程。这里面的存储模型通常就是我们熟悉的数据库。说到数据库，很多人会想到MySQL，Mongodb，SQLite等等。常见的这些数据库都是Server-Client模式的，需要启动服务端——通常我们装的就是这个。但是你一般很少见到叫别人装个桌面软件的同时，叫别人配数据库的吧。</p><p>因为有些数据我们必须在本地存下来，方便下次使用的时候读取。而对于electron来说，既然让用户装MySQL、Mongodb是不太优雅的解决办法的话，那么如果能用其他方式，将数据存到本地而不用用户操心如何存储的，对我们和用户来说都是一件好事。</p><h2 id="纯JavaScript数据库的选择"><a href="#纯JavaScript数据库的选择" class="headerlink" title="纯JavaScript数据库的选择"></a>纯JavaScript数据库的选择</h2><p>既然是JS技术栈的，于是我就找了一些纯JavaScript实现的数据库。经过初步筛选，我找到如下两个：</p><ol><li><a href="https://github.com/louischatriot/nedb" target="_blank" rel="noopener">nedb</a> 7800star（2018-02-12）</li><li><a href="https://github.com/typicode/lowdb" target="_blank" rel="noopener">lowdb</a> 7269star（2018-02-12）</li></ol><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>其中就目前来看，nedb用的更为广泛，star数更多（截止2018-02-12），而且有很多讲到nedb和electron配合使用的文章。不过，nedb已经有快两年没有维护了，而且原生不支持Promise，采用的是异步回调（虽然可以通过第三方插件实现Promise）。</p><p>lowdb是用JSON为基本存储结构基于lodash开发的，有lodash的加持，用起来很顺手。优势在于它在持续的维护，有不少好用的插件。并且很关键的是同步操作，采用链式调用的写法，写起来有种jQuery的感觉。再者，用JSON存储的数据，不管是调用还是备份都很方便，这也是让我很喜欢的一点。</p><p>综上，PicGo采用的是lowdb。</p><h2 id="lowdb的初始化"><a href="#lowdb的初始化" class="headerlink" title="lowdb的初始化"></a>lowdb的初始化</h2><p>由于electron给main进程和renderer进程都置入了Node的<code>fs</code>模块，所以我们可以很方便的在两端都使用跟<code>fs</code>相关的操作。而lowdb本质上就是通过<code>fs</code>来读写JSON文件实现的，正好符合我们的要求。所以根据官方给出的文档，我们首先先初始化一下。</p><p><strong>为了操作<code>fs</code>更方便，不妨安装一个<a href="https://github.com/jprichardson/node-fs-extra" target="_blank" rel="noopener">fs-extra</a>。</strong></p><p>创建一个<code>datastore.js</code>文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; app &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STORE_PATH = app.getPath(<span class="string">'userData'</span>) <span class="comment">// 获取electron应用的用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>)) <span class="comment">// 初始化lowdb读写的json文件名以及存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter) <span class="comment">// lowdb接管该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db <span class="comment">// 暴露出去</span></span><br></pre></td></tr></table></figure><p>接着我们在main进程和renderer进程里就可以这样引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../datastore'</span> <span class="comment">// 取决于你的datastore.js的位置</span></span><br></pre></td></tr></table></figure><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>如果仅仅是上面的基本操作，那么这篇文章未免也太简单了。关于electron引入lowdb的踩坑之路现在才开始。</p><h4 id="1-renderer进程要使用remote模块"><a href="#1-renderer进程要使用remote模块" class="headerlink" title="1. renderer进程要使用remote模块"></a>1. renderer进程要使用remote模块</h4><p>首先由上面的初始化能明显看到一个问题。<code>app</code>模块是main进程里特有的，renderer进程应该使用<code>remote.app</code>模块。所以上面的代码在<code>renderer</code>进程里会报错。</p><p>因此第一次修改，使其既能跑在main进程也能跑在renderer进程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; app, remote &#125; <span class="keyword">from</span> <span class="string">'electron'</span> <span class="comment">// 引入remote模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP = process.type === <span class="string">'renderer'</span> ? remote.app : app <span class="comment">// 根据process.type来分辨在哪种模式使用哪种模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STORE_PATH = APP.getPath(<span class="string">'userData'</span>) <span class="comment">// 获取electron应用的用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>)) <span class="comment">// 初始化lowdb读写的json文件名以及存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter) <span class="comment">// lowdb接管该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db <span class="comment">// 暴露出去</span></span><br></pre></td></tr></table></figure><h4 id="2-开发模式和生产模式初始化路径问题"><a href="#2-开发模式和生产模式初始化路径问题" class="headerlink" title="2. 开发模式和生产模式初始化路径问题"></a>2. 开发模式和生产模式初始化路径问题</h4><p>在开发模式的时候，通过<code>APP.getPath(&#39;userData&#39;)</code>获取到的路径形如：<code>/Users/molunerfinn/Library/Application Support/Electron</code>（macOS下）。这个是一个已经自动创建好的路径。所以在开发模式的时候，初始化路径是已经存在的。</p><p>然而在生产模式下不是这样。生产模式下，第一次打开应用的过程中，<code>APP.getPath(&#39;userData&#39;)</code>获取的路径并未创建，而<code>datastore.js</code>却已经被加载。所以这个时候初始化路径并不存在。用户在第一次打开应用的时候就会遇到如下报错：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fodwgwq9k6j20nc176dov" alt></p><p>所以我们必须在<code>datastore.js</code>里做一次路径是否存在的判断：</p><blockquote><p>此处的fs是来自fs-extra模块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.type !== <span class="string">'renderer'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fs.pathExistsSync(STORE_PATH)) &#123; <span class="comment">// 如果不存在路径</span></span><br><span class="line">    fs.mkdirpSync(STORE_PATH) <span class="comment">// 就创建</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-初始化数据"><a href="#3-初始化数据" class="headerlink" title="3. 初始化数据"></a>3. 初始化数据</h4><p>因为有的时候我们需要预先指定数据库的基本结构，比如是个数组，这样我们就初始化为<code>[]</code>。如果是个Object，有具体值，就指定为具体值。而初始化数据结构不应该在每次对数据读写的时候来判断，应该在数据库一开始创建的时候就初始化，所以写在<code>datastore.js</code>里是合适的。</p><p>比如我要初始化上传列表应该是一个数组，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'uploaded'</span>).value()) &#123; <span class="comment">// 先判断该值存不存在</span></span><br><span class="line">  db.set(<span class="string">'uploaded'</span>, []).write() <span class="comment">// 不存在就创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-唯一标识的id字段"><a href="#4-唯一标识的id字段" class="headerlink" title="4. 唯一标识的id字段"></a>4. 唯一标识的id字段</h4><p>用过MySQL的人大多都会在表里初始化一个自增的id字段作为数据的唯一标识。而lowdb虽然无法很方便地创建一个自增的id字段，但是通过<a href="https://github.com/typicode/lodash-id" target="_blank" rel="noopener">lodash-id</a>这个插件可以很方便地为每个新增的数据自动加上一个唯一标识的id字段。</p><p>形如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"height"</span>: <span class="number">514</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"weibo"</span>,</span><br><span class="line">  <span class="attr">"width"</span>: <span class="number">514</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"7f247aa7-ffeb-4bb1-87f1-a0d69824ec78"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化也很方便：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> LodashId <span class="keyword">from</span> <span class="string">'lodash-id'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter)</span><br><span class="line">db._.mixin(LodashId) <span class="comment">// 通过._mixin()引入</span></span><br></pre></td></tr></table></figure><h3 id="初始化完整代码"><a href="#初始化完整代码" class="headerlink" title="初始化完整代码"></a>初始化完整代码</h3><p>通过上述的踩坑，PicGo的初始化代码如下，仅供参考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> LodashId <span class="keyword">from</span> <span class="string">'lodash-id'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; remote, app &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP = process.type === <span class="string">'renderer'</span> ? remote.app : app</span><br><span class="line"><span class="keyword">const</span> STORE_PATH = APP.getPath(<span class="string">'userData'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.type !== <span class="string">'renderer'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fs.pathExistsSync(STORE_PATH)) &#123;</span><br><span class="line">    fs.mkdirpSync(STORE_PATH)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter)</span><br><span class="line">db._.mixin(LodashId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'uploaded'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'uploaded'</span>, []).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'picBed'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'picBed'</span>, &#123;</span><br><span class="line">    current: <span class="string">'weibo'</span></span><br><span class="line">  &#125;).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'shortKey'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'shortKey'</span>, &#123;</span><br><span class="line">    upload: <span class="string">'CommandOrControl+Shift+P'</span></span><br><span class="line">  &#125;).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db</span><br></pre></td></tr></table></figure><h2 id="lowdb的基本操作"><a href="#lowdb的基本操作" class="headerlink" title="lowdb的基本操作"></a>lowdb的基本操作</h2><p>数据库的基本操作无非就是CURD。</p><blockquote><p>它代表创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete）操作。</p></blockquote><p>下面介绍lowdb的基本使用方法。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>主要通过<code>set()</code>或者<code>defaults()</code>方法。其中<code>defaults()</code>专门针对空JSON文件进行初始化。（不过用set也是可以实现类似的，如上一小节说到的初始化）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.defaults(&#123; <span class="attr">posts</span>: [], <span class="attr">user</span>: &#123;&#125;, <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  .write() <span class="comment">// 一定要显式调用write方法将数据存入JSON</span></span><br></pre></td></tr></table></figure><p><strong>注意任何写的操作，都必须显式的使用<code>write()</code>方法来保存。</strong></p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>).value() <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>当然还可以用lodash的一些方法来查询你的JSON。</p><p>比如<code>find()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .find(&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  .value()</span><br></pre></td></tr></table></figure><p><strong>注意任何读的操作，都必须显式使用<code>value()</code>方法来获取值。</strong></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>通过不同的方法对不同的结构来更新。</p><p>比如针对对象就用赋值，针对数组就用<code>push()</code>或者<code>insert()</code>（lowdb-id提供的方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>).insert(&#123; <span class="comment">// 对数组进行insert操作</span></span><br><span class="line">  title: <span class="string">'xxx'</span>,</span><br><span class="line">  content: <span class="string">'xxxx'</span></span><br><span class="line">&#125;).write()</span><br></pre></td></tr></table></figure><p>针对对象可以直接用<code>set()</code>来更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.set(<span class="string">'user.name'</span>, <span class="string">'typicode'</span>) <span class="comment">// 通过set方法来对对象操作</span></span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>还可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.set(<span class="string">'user'</span>, &#123;</span><br><span class="line">  name: <span class="string">'typicode'</span></span><br><span class="line">&#125;).write()</span><br></pre></td></tr></table></figure><p>很灵活对吧。</p><p>针对原有的数据进行更新的可以用update。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.update(<span class="string">'count'</span>, n =&gt; n + <span class="number">1</span>) <span class="comment">// update方法使用已存在的值来操作</span></span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>可以通过<code>remove()</code>方法删除一个符合条件的项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .remove(&#123; <span class="attr">title</span>: <span class="string">'low!'</span> &#125;)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>可以通过<code>unset</code>来删除一个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.unset(<span class="string">'user.name'</span>)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>还可以通过<code>lodash-id</code>提供的<code>removeById()</code>来删除指定id的项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .removeById(id)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><h2 id="lowdb实际使用的坑"><a href="#lowdb实际使用的坑" class="headerlink" title="lowdb实际使用的坑"></a>lowdb实际使用的坑</h2><p>lowdb在使用的过程中会遇到一个大坑在于，如果就按照基本操作，那么有可能出现我在<code>main</code>进程里存入的值，在<code>renderer</code>进程里读不到。</p><p>为啥？因为直接引用的<code>db</code>实际上只是那个时刻在内存里的数据。lowdb在使用过程中会把JSON数据读入内存中。只有在需要写操作的时候才会将新的数据写入磁盘。</p><p>main进程和renderer进程拿到的db都是应用打开时所读取的。在没有额外处理的情况下，在main进程拿到的内存里的db，和renderer拿到的内存里的db不是同一个db，也就是所谓的不是一个db的两份引用，而是一个db的两份拷贝。main进程对其进行的操作，renderer进程是不知道的。换句话说，main进程对db进行了任何读写操作，renderer拿到的db依然是当初应用打开时所读取的db。所以就会遇到main进程更新了数据，而renderer进程依然无法拿到新的数据。</p><p>那有没有办法解决呢？有的。就是有点麻烦。那就是在所有的db操作的最开始，都重新读取一遍db的最新状态：</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.read().get(<span class="string">'xxx'</span>).value()</span><br><span class="line"></span><br><span class="line">db.read().set(<span class="string">'xxx'</span>, <span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure><p>强制在每个db操作前，都通过read()刷新一遍内存区，这样就能保证拿到的数据都是最新的啦。</p><h2 id="Vue里使用lowdb的便捷方法"><a href="#Vue里使用lowdb的便捷方法" class="headerlink" title="Vue里使用lowdb的便捷方法"></a>Vue里使用lowdb的便捷方法</h2><p>类似于很多人会在Vue里把axios挂在vue的原型链上一样，我们也可以用类似的方法来方便我们在Vue里使用lowdb。</p><p>打开Vue项目的入口文件，通常是<code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../datastore'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$db = db</span><br></pre></td></tr></table></figure><p>这样我们就可以在项目里，用<code>this.$db</code>的方法来使用lowdb啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细地介绍了lowdb以及lowdb在electron里的使用。很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到。如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Molunerfinn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://molunerfinn.com/electron-vue-3/">https://molunerfinn.com/electron-vue-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/前端/">前端</a><a class="post-meta__tags" href="/tags/Vue/">Vue</a><a class="post-meta__tags" href="/tags/Electron/">Electron</a><a class="post-meta__tags" href="/tags/Electron-vue/">Electron-vue</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ws1.sinaimg.cn/large/8700af19ly1fjmba1eumhj20jz0jzq4b.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ws1.sinaimg.cn/large/8700af19ly1fjmbbmp7uwj20jm0jmt9a.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5994f8f0fea9a5f4" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/PC-Chrome-PWA/"><i class="fa fa-chevron-left"></i><span>用新版的Chrome把PWA网站添加到桌面，获得媲美原生应用的体验</span></a></div><div class="next-post pull-right"><a href="/electron-vue-2/"><span>Electron-vue开发实战1——Main进程和Renderer进程的简单开发</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="100%" height="90"></a></div><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"f7b6cca0b0a65f07a027",clientSecret:"84b5ccac558161d1bdaa50fc498619fca9d4c640",repo:"Molunerfinn.github.io",owner:"Molunerfinn",admin:"Molunerfinn",id:md5(decodeURI(location.pathname)),language:"en"});gitalk.render("gitalk-container")</script></div></div><footer class="footer-bg" style="background-image:url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Molunerfinn</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>