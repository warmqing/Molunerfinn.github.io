<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MARKSZのBlog</title>
  
  <subtitle>Do what you love,Love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://molunerfinn.com/"/>
  <updated>2019-03-17T14:42:12.474Z</updated>
  <id>https://molunerfinn.com/</id>
  
  <author>
    <name>Molunerfinn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Electron-vue开发实战6——开发插件系统之GUI部分</title>
    <link href="https://molunerfinn.com/electron-vue-7/"/>
    <id>https://molunerfinn.com/electron-vue-7/</id>
    <published>2019-03-17T11:30:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇<a href="https://molunerfinn.com/tags/Electron-vue/">系列文章</a>或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端(<code>Electron</code>的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从<a href="https://molunerfinn.com/tags/Electron-vue/">之前的文章</a>跟着看。并且如果没有看过前一篇CLI插件系统构建的朋友，需要先行阅读，本文涉及到的部分内容来自上一篇文章。</p><a id="more"></a><h2 id="运行时的require"><a href="#运行时的require" class="headerlink" title="运行时的require"></a>运行时的require</h2><p>我们之前构建的插件系统是基于<code>Node.js</code>端的。对于<code>Electron</code>而言，main进程可以认为拥有<code>Node.js</code>环境，所以我们首先要在main进程里将其引入。而对于PicGo而言，由于上传流程已经完全抽离到<code>PicGo-Core</code>这个库里了，所以原本存在于Electron端的上传部分就可以精简整合成调用<code>PicGo-Core</code>的api来实现上传部分的逻辑了。</p><p>而在引入<code>PicGo-Core</code>的时候会遇到一个问题。在<code>Electron</code>端，由于我使用的脚手架是<code>Electron-vue</code>，它会将<code>main</code>进程和<code>renderer</code>进程都通过<code>Webapck</code>进行打包。由于<code>PicGo-Core</code>用于加载插件的部分使用的是<code>require</code>，在Node.js端很正常没问题。但是Webpack并不知道这些<code>require</code>是在运行时才需要调用的，它会认为这是构建时的「常规」<code>require</code>，也就会在打包的时候把你<code>require</code>的插件也打包进来。这样明显是不合理的，我们是运行时才<code>require</code>插件的，所以需要做一些手段来「绕开」<code>Webpack</code>的打包机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eslint-disable-next-line</span></span><br><span class="line"><span class="keyword">const</span> requireFunc = <span class="keyword">typeof</span> __webpack_require__ === <span class="string">'function'</span> ? __non_webpack_require__ : <span class="built_in">require</span></span><br><span class="line"><span class="keyword">const</span> PicGo = requireFunc(<span class="string">'picgo'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>关于<code>__non_webpack_require__</code>的说明，可以查看<a href="https://webpack.docschina.org/api/module-variables/#__non_webpack_require__-webpack-特有变量-" target="_blank" rel="noopener">文档</a>。</p></blockquote><p>打包之后会变成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requireFunc = <span class="literal">true</span> ? <span class="built_in">require</span> : <span class="built_in">require</span></span><br><span class="line"><span class="keyword">const</span> PicGo = requireFunc(<span class="string">'picgo'</span>)</span><br></pre></td></tr></table></figure><p>这样就可以避免PicGo-Core内部的<code>require</code>被<code>Webpack</code>也打包进去了。</p><h2 id="「前后端」分离"><a href="#「前后端」分离" class="headerlink" title="「前后端」分离"></a>「前后端」分离</h2><p><code>Electron</code>的<code>main</code>进程和<code>renderer</code>进程实际上你可以把它们看成我们平时Web开发的后端和前端。二者交流的工具也不再是<code>Ajax</code>，而是<code>ipcMain</code>和<code>ipcRenderer</code>。当然<code>renderer</code>本身能做的事情也不少，只不过这样说一下可能会好理解一点。相应的，我们的插件系统原本实现在<code>Node.js</code>端，是一个没有界面的工具，想要让它拥有「脸面」，其实也不过是在<code>renderer</code>进程里调用来自<code>main</code>进程里的插件系统暴露出来的api而已。这里我们举几个例子来说明。</p><h3 id="简化原有流程"><a href="#简化原有流程" class="headerlink" title="简化原有流程"></a>简化原有流程</h3><p>在以前PicGo上传图片需要经过很多步骤：</p><ol><li>通过<a href="https://github.com/Molunerfinn/PicGo/blob/v1.6.2/src/main/utils/uploader.js" target="_blank" rel="noopener">uploader</a>来接收图片，并通过<a href="https://github.com/Molunerfinn/PicGo/blob/v1.6.2/src/datastore/pic-bed-handler.js" target="_blank" rel="noopener">pic-bed-handler</a>来指定上传的图床。</li><li>通过<a href="https://github.com/Molunerfinn/PicGo/blob/v1.6.2/src/main/utils/img2base64.js" target="_blank" rel="noopener">img2base64</a>来把图片统一转成<code>Base64</code>编码。</li><li>通过指定的<code>imgUploader</code>（比如<code>qiniu</code>比如<code>weibo</code>等）来上传到指定的图床。</li></ol><p>而如今整个底层上传流程系统已经被抽离出来，因此我们可以直接使用PicGo-Core实现的api来上传图片，只需定义一个<a href="https://github.com/Molunerfinn/PicGo/blob/dev/src/main/utils/uploader.js" target="_blank" rel="noopener">Uploader</a>类即可（下面的代码是简化版本）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  app,</span><br><span class="line">  Notification,</span><br><span class="line">  BrowserWindow,</span><br><span class="line">  ipcMain</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eslint-disable-next-line</span></span><br><span class="line"><span class="keyword">const</span> requireFunc = <span class="keyword">typeof</span> __webpack_require__ === <span class="string">'function'</span> ? __non_webpack_require__ : <span class="built_in">require</span></span><br><span class="line"><span class="keyword">const</span> PicGo = requireFunc(<span class="string">'picgo'</span>)</span><br><span class="line"><span class="keyword">const</span> STORE_PATH = app.getPath(<span class="string">'userData'</span>)</span><br><span class="line"><span class="keyword">const</span> CONFIG_PATH = path.join(STORE_PATH, <span class="string">'/data.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uploader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (img, webContents, picgo = undefined) &#123;</span><br><span class="line">    <span class="keyword">this</span>.img = img</span><br><span class="line">    <span class="keyword">this</span>.webContents = webContents</span><br><span class="line">    <span class="keyword">this</span>.picgo = picgo</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  upload () &#123;</span><br><span class="line">    <span class="keyword">const</span> win = BrowserWindow.fromWebContents(<span class="keyword">this</span>.webContents) <span class="comment">// 获取上传的窗口</span></span><br><span class="line">    <span class="keyword">const</span> picgo = <span class="keyword">this</span>.picgo || <span class="keyword">new</span> PicGo(CONFIG_PATH) <span class="comment">// 获取上传的picgo实例</span></span><br><span class="line">    picgo.config.debug = <span class="literal">true</span> <span class="comment">// 方便调试</span></span><br><span class="line">    <span class="comment">// for picgo-core</span></span><br><span class="line">    picgo.config.PICGO_ENV = <span class="string">'GUI'</span></span><br><span class="line">    <span class="keyword">let</span> input = <span class="keyword">this</span>.img <span class="comment">// 传入的this.img是一个数组</span></span><br><span class="line"></span><br><span class="line">    picgo.upload(input) <span class="comment">// 上传图片，只用了一句话</span></span><br><span class="line"></span><br><span class="line">    picgo.on(<span class="string">'notification'</span>, message =&gt; &#123; <span class="comment">// 上传成功或者失败提示信息</span></span><br><span class="line">      <span class="keyword">const</span> notification = <span class="keyword">new</span> Notification(message)</span><br><span class="line">      notification.show()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    picgo.on(<span class="string">'uploadProgress'</span>, progress =&gt; &#123; <span class="comment">// 上传进度</span></span><br><span class="line">      <span class="keyword">this</span>.webContents.send(<span class="string">'uploadProgress'</span>, progress)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; <span class="comment">// 返回一个Promise方便调用</span></span><br><span class="line">      picgo.on(<span class="string">'finished'</span>, ctx =&gt; &#123; <span class="comment">// 上传完成的事件</span></span><br><span class="line">        <span class="keyword">if</span> (ctx.output.every(<span class="function"><span class="params">item</span> =&gt;</span> item.imgUrl)) &#123;</span><br><span class="line">          resolve(ctx.output)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      picgo.on(<span class="string">'failed'</span>, ctx =&gt; &#123; <span class="comment">// 上传失败的事件</span></span><br><span class="line">        <span class="keyword">const</span> notification = <span class="keyword">new</span> Notification(&#123;</span><br><span class="line">          title: <span class="string">'上传失败'</span>,</span><br><span class="line">          body: <span class="string">'请检查配置和上传的文件是否符合要求'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        notification.show()</span><br><span class="line">        resolve(<span class="literal">false</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Uploader</span><br></pre></td></tr></table></figure><p>可以看出，由于在设计CLI插件系统的时候我们有考虑到设计好插件的生命周期，所以很多功能都可以通过生命周期的钩子、以及相应的一些事件来实现。比如图片上传完成就是通过<code>picgo.on(&#39;finished&#39;， callback)</code>监听<code>finished</code>事件来实现的，而上传的进度与进度条显示就是通过<code>picgo.on(&#39;progress&#39;)</code>来实现的。它们的效果如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-2.0.gif" alt="upload-process"></p><p>而且我们还可以通过接入<code>picgo</code>的生命周期，实现一些以前实现起来比较麻烦的功能，比如上传前重命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">picgo.helper.beforeUploadPlugins.register(<span class="string">'renameFn'</span>, &#123;</span><br><span class="line">  handle: <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> rename = picgo.getConfig(<span class="string">'settings.rename'</span>)</span><br><span class="line">    <span class="keyword">const</span> autoRename = picgo.getConfig(<span class="string">'settings.autoRename'</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(ctx.output.map(<span class="keyword">async</span> (item, index) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> name</span><br><span class="line">      <span class="keyword">let</span> fileName</span><br><span class="line">      <span class="keyword">if</span> (autoRename) &#123;</span><br><span class="line">        fileName = dayjs().add(index, <span class="string">'second'</span>).format(<span class="string">'YYYYMMDDHHmmss'</span>) + item.extname</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fileName = item.fileName</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (rename) &#123; <span class="comment">// 如果要重命名</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">window</span> = createRenameWindow(win) <span class="comment">// 创建重命名窗口</span></span><br><span class="line">        <span class="keyword">await</span> waitForShow(<span class="built_in">window</span>.webContents) <span class="comment">// 等待窗口打开</span></span><br><span class="line">        <span class="built_in">window</span>.webContents.send(<span class="string">'rename'</span>, fileName, <span class="built_in">window</span>.webContents.id) <span class="comment">// 给窗口发送相应信息</span></span><br><span class="line">        name = <span class="keyword">await</span> waitForRename(<span class="built_in">window</span>, <span class="built_in">window</span>.webContents.id) <span class="comment">// 获取重新命名后的文件名</span></span><br><span class="line">      &#125;</span><br><span class="line">      item.fileName = name || fileName</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过注册一个<code>beforeUploadPlugin</code>，在上传前判断是否需要「上传前重命名」，如果是，就创建窗口并等待用户输入重命名的结果，然后将重命名的<code>name</code>赋值给<code>item.fileName</code>供后续的流程使用。</p><p>我们还可以在<code>beforeTransform</code>阶段通知用户当前正在准备上传了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">picgo.on(<span class="string">'beforeTransform'</span>, ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.getConfig(<span class="string">'settings.uploadNotification'</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> notification = <span class="keyword">new</span> Notification(&#123;</span><br><span class="line">      title: <span class="string">'上传进度'</span>,</span><br><span class="line">      body: <span class="string">'正在上传'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    notification.show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>等等。所以实际上我们只需要在<code>main</code>进程完成相应的api，那么<code>renderer</code>进程做的事只不过是通过<code>ipcRenderer</code>来通过<code>main</code>进程调用这些api而已了。比如：</p><ul><li>当用户拖动图片到上传区域，通过<code>ipcRenderer</code>通知<code>main</code>进程：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$electron.ipcRenderer.send(<span class="string">'uploadChoosedFiles'</span>, sendFiles)</span><br></pre></td></tr></table></figure><ul><li><code>main</code>进程监听事件并调用<code>Uploader</code>的<code>upload</code>方法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.on(<span class="string">'uploadChoosedFiles'</span>, <span class="keyword">async</span> (evt, files) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> input = files.map(<span class="function"><span class="params">item</span> =&gt;</span> item.path)</span><br><span class="line">  <span class="keyword">const</span> imgs = <span class="keyword">await</span> <span class="keyword">new</span> Uploader(input, evt.sender).upload() <span class="comment">// 由于upload返回的是Promise</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就完成了一次「前后端」交互。其他方式上传（比如剪贴板上传）也同理，就不再赘述。</p><h2 id="实现插件管理界面"><a href="#实现插件管理界面" class="headerlink" title="实现插件管理界面"></a>实现插件管理界面</h2><p>光有插件系统没有插件也不行，所以我们需要实现一个插件管理的界面。而插件管理的功能（比如安装、卸载、更新）已经在CLI版本里实现了，所以这些功能我们只需要通过向上一节里说的调用<code>ipcRenderer</code>和<code>ipcMain</code>来调用相应api即可。</p><h3 id="第三方插件搜索"><a href="#第三方插件搜索" class="headerlink" title="第三方插件搜索"></a>第三方插件搜索</h3><p>在GUI界面我们需要一个很重要的功能就是「插件搜索」的功能。由于PicGo的插件统一是发布到<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>的，所以其实我们可以通过npm的api来打到搜索插件的目的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">getSearchResult (val) &#123;</span><br><span class="line">  <span class="comment">// this.$http.get(`https://api.npms.io/v2/search?q=$&#123;val&#125;`)</span></span><br><span class="line">  <span class="keyword">this</span>.$http.get(<span class="string">`https://registry.npmjs.com/-/v1/search?text=<span class="subst">$&#123;val&#125;</span>`</span>) <span class="comment">// 调用npm的搜索api</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.pluginList = res.data.objects.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handleSearchResult(item) <span class="comment">// 返回格式化的结果</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">handleSearchResult (item) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = item.package.name.replace(<span class="regexp">/picgo-plugin-/</span>, <span class="string">''</span>)</span><br><span class="line">  <span class="keyword">let</span> gui = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (item.package.keywords &amp;&amp; item.package.keywords.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.package.keywords.includes(<span class="string">'picgo-gui-plugin'</span>)) &#123;</span><br><span class="line">      gui = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    author: item.package.author.name,</span><br><span class="line">    description: item.package.description,</span><br><span class="line">    logo: <span class="string">`https://cdn.jsdelivr.net/npm/<span class="subst">$&#123;item.package.name&#125;</span>/logo.png`</span>,</span><br><span class="line">    config: &#123;&#125;,</span><br><span class="line">    homepage: item.package.links ? item.package.links.homepage : <span class="string">''</span>,</span><br><span class="line">    hasInstall: <span class="keyword">this</span>.pluginNameList.some(<span class="function"><span class="params">plugin</span> =&gt;</span> plugin === item.package.name.replace(<span class="regexp">/picgo-plugin-/</span>, <span class="string">''</span>)),</span><br><span class="line">    version: item.package.version,</span><br><span class="line">    gui,</span><br><span class="line">    ing: <span class="literal">false</span> <span class="comment">// installing or uninstalling</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过搜索然后把结果显示到界面上就是如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/test/search-plugin.gif" alt></p><p>没有安装的插件就会在右下角显示「安装」两个字样。</p><h3 id="本地插件列表"><a href="#本地插件列表" class="headerlink" title="本地插件列表"></a>本地插件列表</h3><p>当我们安装好插件之后，需要从本地获取插件列表。这个部分需要做一些处理。由于插件是安装在Node.js端的，所以我们需要通过<code>ipcRenderer</code>去向<code>main</code>进程发起获取插件列表的「请求」：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$electron.ipcRenderer.send(<span class="string">'getPluginList'</span>) <span class="comment">// 发起获取插件的「请求」</span></span><br><span class="line"><span class="keyword">this</span>.$electron.ipcRenderer.on(<span class="string">'pluginList'</span>, (evt, list) =&gt; &#123; <span class="comment">// 获取插件列表</span></span><br><span class="line">  <span class="keyword">this</span>.pluginList = list</span><br><span class="line">  <span class="keyword">this</span>.pluginNameList = list.map(<span class="function"><span class="params">item</span> =&gt;</span> item.name)</span><br><span class="line">  <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而获取插件列表以及相应信息我们需要在<code>main</code>端进行，并发送回去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.on(<span class="string">'getPluginList'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> picgo = <span class="keyword">new</span> PicGo(CONFIG_PATH)</span><br><span class="line">  <span class="keyword">const</span> pluginList = picgo.pluginLoader.getList()</span><br><span class="line">  <span class="keyword">const</span> list = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> pluginList) &#123;</span><br><span class="line">   <span class="comment">// 处理插件相关的信息</span></span><br><span class="line">  &#125;</span><br><span class="line">  event.sender.send(<span class="string">'pluginList'</span>, list) <span class="comment">// 将插件信息列表发送回去</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意到由于<code>ipcMain</code>和<code>ipcRenderer</code>里收发数据的时候会自动经过<code>JSON.stringify</code>和<code>JSON.parse</code>，所以对于原来的一些属性是<code>function</code>之类无法被序列化的属性，我们要做一些处理，比如先执行它们得到结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleConfigWithFunction = <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> config[i].default === <span class="string">'function'</span>) &#123;</span><br><span class="line">      config[i].default = config[i].default()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> config[i].choices === <span class="string">'function'</span>) &#123;</span><br><span class="line">      config[i].choices = config[i].choices()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在<code>renderer</code>进程里才能拿到完整的数据。</p><h3 id="插件配置相关"><a href="#插件配置相关" class="headerlink" title="插件配置相关"></a>插件配置相关</h3><p>当然光有安装、查看还不够，还需要让插件管理界面拥有其他功能，比如「卸载」、「更新」或者是配置功能，所以在每个安装成功后的插件卡片的右下角有个配置按钮可以弹出相应的菜单：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/20190113160001.png" alt></p><p>菜单这个部分就是用<code>Electron</code>的<code>Menu</code>模块去实现了（我在之前的文章里已经有涉及，不再赘述），并没有特别复杂的地方。而这里比较关键的地方，就是当我点击<code>配置plugin-xxx</code>的时候，会弹出一个配置的对话框：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/test/20190317161148.png" alt></p><p>这个配置对话框内的配置内容来自前文《开发CLI插件系统》里我们要求开发者定义好的<code>config</code>方法返回的配置项。由于插件开发者定义的<code>config</code>内容是<a href="https://github.com/SBoudrias/Inquirer.js/" target="_blank" rel="noopener">Inquirer.js</a>所要求的格式，便于在CLI环境下使用。但是它和我们平时使用的<code>form</code>表单的一些格式可能有些出入，所以需要「转义」一下，通过原始的<code>config</code>动态生成表单项：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"config-form"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-form</span></span></span><br><span class="line"><span class="tag">    <span class="attr">label-position</span>=<span class="string">"right"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">label-width</span>=<span class="string">"120px"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:model</span>=<span class="string">"ruleForm"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"form"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">size</span>=<span class="string">"mini"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(item, index) in configList"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:label</span>=<span class="string">"item.name"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:required</span>=<span class="string">"item.required"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:prop</span>=<span class="string">"item.name"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:key</span>=<span class="string">"item.name + index"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-if</span>=<span class="string">"item.type === 'input' || item.type === 'password'"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:type</span>=<span class="string">"item.type === 'password' ? 'password' : 'input'"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-model</span>=<span class="string">"ruleForm[item.name]"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:placeholder</span>=<span class="string">"item.message || item.name"</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-select</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-else-if</span>=<span class="string">"item.type === 'list'"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-model</span>=<span class="string">"ruleForm[item.name]"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:placeholder</span>=<span class="string">"item.message || item.name"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-option</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-for</span>=<span class="string">"(choice, idx) in item.choices"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:label</span>=<span class="string">"choice.name || choice.value || choice"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:key</span>=<span class="string">"choice.name || choice.value || choice"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:value</span>=<span class="string">"choice.value || choice"</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">el-option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-select</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-else-if</span>=<span class="string">"item.type === 'checkbox'"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-model</span>=<span class="string">"ruleForm[item.name]"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:placeholder</span>=<span class="string">"item.message || item.name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">multiple</span></span></span><br><span class="line"><span class="tag">        <span class="attr">collapse-tags</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-option</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-for</span>=<span class="string">"(choice, idx) in item.choices"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:label</span>=<span class="string">"choice.name || choice.value || choice"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:key</span>=<span class="string">"choice.value || choice"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:value</span>=<span class="string">"choice.value || choice"</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">el-option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-switch</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-else-if</span>=<span class="string">"item.type === 'confirm'"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-model</span>=<span class="string">"ruleForm[item.name]"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">active-text</span>=<span class="string">"yes"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">inactive-text</span>=<span class="string">"no"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-switch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面是针对<code>config</code>里不同的<code>type</code>转换成不同的Web表单控件的代码。下面是初始化的时候处理<code>config</code>的一些工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  config: &#123;</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    handler (val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.ruleForm = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;&#125;)</span><br><span class="line">      <span class="keyword">const</span> config = <span class="keyword">this</span>.$db.read().get(<span class="string">`picBed.<span class="subst">$&#123;<span class="keyword">this</span>.id&#125;</span>`</span>).value()</span><br><span class="line">      <span class="keyword">if</span> (val.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.configList = cloneDeep(val).map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> defaultValue = item.default !== <span class="literal">undefined</span></span><br><span class="line">            ? item.default : item.type === <span class="string">'checkbox'</span></span><br><span class="line">              ? [] : <span class="literal">null</span> <span class="comment">// 处理默认值</span></span><br><span class="line">          <span class="keyword">if</span> (item.type === <span class="string">'checkbox'</span>) &#123; <span class="comment">// 处理checkbox选中值</span></span><br><span class="line">            <span class="keyword">const</span> defaults = item.choices.filter(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> i.checked</span><br><span class="line">            &#125;).map(<span class="function"><span class="params">i</span> =&gt;</span> i.value)</span><br><span class="line">            defaultValue = union(defaultValue, defaults)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (config &amp;&amp; config[item.name] !== <span class="literal">undefined</span>) &#123; <span class="comment">// 处理默认值</span></span><br><span class="line">            defaultValue = config[item.name]</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.$<span class="keyword">set</span>(this.ruleForm, item.name, defaultValue)</span><br><span class="line">          return item</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true // 立即执行</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述处理，就可以将原本用于CLI的配置项，近乎「无缝」地迁移到Web（GUI）端了。其实这也是vue-cli3的ui版本实现的思路，大同小异。</p><h2 id="实现特有的guiApi"><a href="#实现特有的guiApi" class="headerlink" title="实现特有的guiApi"></a>实现特有的guiApi</h2><p>不过既然是GUI软件了，只通过调用CLI实现的功能明显是不够丰富的。因此我也为<code>PicGo</code>实现了一些特有的<code>guiApi</code>提供给插件的开发者，让插件的可玩性更强。当然不同的软件给予插件的GUI能力是不一样的，因此不能一概而论。我仅以<code>PicGo</code>为例，讲述我对于<code>PicGo</code>所提供的<code>guiApi</code>的理解和看法。下面我就来说说这部分是如何实现的。</p><p>由于PicGo本质是一个上传系统，所以用户在上传图片的时候，很多插件底层的东西和功能实际上是看不到的。如果要让插件的功能更加丰富，就需要让插件有自己的「可视化」入口让用户去使用。因此对于PicGo而言，我给予插件的「可视化」入口就放在插件配置的界面里——除了给插件默认的配置菜单之外，还给予插件自己的菜单项供用户使用：</p><p><img src="https://i.loli.net/2019/01/12/5c39a2f60a32a.png" alt></p><p>这个实现也很容易，只要插件在自己的<code>index.js</code>文件里暴露一个<code>guiMenu</code>的选项，就可以生成自己的菜单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> guiMenu = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      label: <span class="string">'打开InputBox'</span>,</span><br><span class="line">      <span class="keyword">async</span> handle (ctx, guiApi) &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      label: <span class="string">'打开FileExplorer'</span>,</span><br><span class="line">      <span class="keyword">async</span> handle (ctx, guiApi) &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到菜单项可以自定义，点击之后的操作也可以自定义，因此给予了插件很大的自由度。可以注意到，在点击菜单的时候会触发<code>handle</code>函数，这个函数里会传入一个<code>guiApi</code>，这个就是本节的重点了。就目前而言，<code>guiApi</code>实现了如下功能：</p><ol><li><code>showInputBox([option])</code> 调用之后打开一个输入弹窗，可以用于接受用户输入。</li><li><code>showFileExplorer([option])</code> 调用之后打开一个文件浏览器，可以得到用户选择的文件（夹）路径。</li><li><code>upload([file])</code> 调用之后使用PicGo底层来上传，可以实现自动更新相册图片、上传成功后自动将URL写入剪贴板。</li><li><code>showNotificaiton(option)</code> 调用之后弹出系统通知窗口。</li></ol><p>上面api我们可以通过诸如<code>guiApi.showInputBox()</code>、<code>guiApi.showFileExplorer()</code>等来实现调用。这里面的例子实现思路都差不多，我简单以<code>guiApi.showFileExplorer()</code>来做讲解。</p><p>当我们在<code>renderer</code>界面点击插件实现的某个菜单之后，实际上是通过调用<code>ipcRenderer</code>向<code>main</code>进程传播了一次事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (plugin.guiMenu) &#123;</span><br><span class="line">  menu.push(&#123;</span><br><span class="line">    type: <span class="string">'separator'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> plugin.guiMenu) &#123;</span><br><span class="line">    menu.push(&#123;</span><br><span class="line">      label: i.label,</span><br><span class="line">      click () &#123; <span class="comment">// 当点击的时候，发送当前的插件名和当前菜单项的名字</span></span><br><span class="line">        _this.$electron.ipcRenderer.send(<span class="string">'pluginActions'</span>, plugin.name, i.label)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是在<code>main</code>进程，我们通过监听这个事件，来调用相应的<code>guiApi</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handlePluginActions = <span class="function">(<span class="params">ipcMain, CONFIG_PATH</span>) =&gt;</span> &#123;</span><br><span class="line">  ipcMain.on(<span class="string">'pluginActions'</span>, (event, name, label) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> picgo = <span class="keyword">new</span> PicGo(CONFIG_PATH)</span><br><span class="line">    <span class="keyword">const</span> plugin = picgo.pluginLoader.getPlugin(<span class="string">`picgo-plugin-<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">const</span> guiApi = <span class="keyword">new</span> GuiApi(ipcMain, event.sender, picgo) <span class="comment">// 实例化guiApi</span></span><br><span class="line">    <span class="keyword">if</span> (plugin.guiMenu &amp;&amp; plugin.guiMenu(picgo).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> menu = plugin.guiMenu(picgo)</span><br><span class="line">      menu.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.label === label) &#123; <span class="comment">// 找到相应的label，执行插件的`handle`</span></span><br><span class="line">          item.handle(picgo, guiApi)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>guiApi</code>的实现类<a href="https://github.com/Molunerfinn/PicGo/blob/dev/src/main/utils/guiApi.js" target="_blank" rel="noopener">GuiApi</a>其实特别简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  dialog,</span><br><span class="line">  BrowserWindow,</span><br><span class="line">  clipboard,</span><br><span class="line">  Notification</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../../datastore'</span></span><br><span class="line"><span class="keyword">import</span> Uploader <span class="keyword">from</span> <span class="string">'./uploader'</span></span><br><span class="line"><span class="keyword">import</span> pasteTemplate <span class="keyword">from</span> <span class="string">'./pasteTemplate'</span></span><br><span class="line"><span class="keyword">const</span> WEBCONTENTS = <span class="built_in">Symbol</span>(<span class="string">'WEBCONTENTS'</span>)</span><br><span class="line"><span class="keyword">const</span> IPCMAIN = <span class="built_in">Symbol</span>(<span class="string">'IPCMAIN'</span>)</span><br><span class="line"><span class="keyword">const</span> PICGO = <span class="built_in">Symbol</span>(<span class="string">'PICGO'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuiApi</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (ipcMain, webcontents, picgo) &#123;</span><br><span class="line">    <span class="keyword">this</span>[WEBCONTENTS] = webcontents</span><br><span class="line">    <span class="keyword">this</span>[IPCMAIN] = ipcMain</span><br><span class="line">    <span class="keyword">this</span>[PICGO] = picgo</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * for plugin show file explorer</span></span><br><span class="line"><span class="comment">   * @param &#123;object&#125; options</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  showFileExplorer (options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      options = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      dialog.showOpenDialog(BrowserWindow.fromWebContents(<span class="keyword">this</span>[WEBCONTENTS]), options, filename =&gt; &#123;</span><br><span class="line">        resolve(filename)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是去调用一些<code>Electron</code>的方法，甚至是你自己封装的一些方法，返回值是一个新的<code>Promise</code>对象。这样插件开发者就可以通过<code>async</code>和<code>await</code>来方便获取这些方法的返回值了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> guiMenu = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123;</span><br><span class="line">      label: <span class="string">'打开文件浏览器'</span>,</span><br><span class="line">      <span class="keyword">async</span> handle (ctx, guiApi) &#123;</span><br><span class="line">        <span class="comment">// 通过await获取用户所选的文件路径</span></span><br><span class="line">        <span class="keyword">const</span> files = <span class="keyword">await</span> guiApi.showFileExplorer(&#123;</span><br><span class="line">          properties: [<span class="string">'openFile'</span>, <span class="string">'multiSelections'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(files)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，一个GUI插件系统的关键部分我们就基本实现了。除了整合了CLI插件系统的几乎所有功能之外，我们还提供了独特的<code>guiApi</code>给插件开发者无限的想象空间，也给用户带来更好的插件体验。可以说插件系统的实现，让<code>PicGo</code>有了更多的可玩性。关于<code>PicGo</code>目前的插件，欢迎查看<a href="https://github.com/PicGo/Awesome-PicGo" target="_blank" rel="noopener">Awesome-PicGo</a>的列表。以下罗列一些我觉得比较有用或者有意思的插件：</p><ol><li><a href="https://github.com/Spades-S/vs-picgo" target="_blank" rel="noopener">vs-picgo</a> 在VSCode里使用PicGo（无需安装GUI！）</li><li><a href="https://github.com/PicGo/picgo-plugin-pic-migrater" target="_blank" rel="noopener">picgo-plugin-pic-migrater</a> 可以迁移你的Markdown里的图片地址到你默认指定的图床，哪怕是本地图片也可以迁移到云端！</li><li><a href="https://github.com/zWingz/picgo-plugin-github-plus" target="_blank" rel="noopener">picgo-plugin-github-plus</a> 增强版GitHub图床，支持了同步图床以及同步删除操作（删除本地图片也会把GitHub上的图片删除）</li><li><a href="https://github.com/yuki-xin/picgo-plugin-web-uploader" target="_blank" rel="noopener">picgo-plugin-web-uploader</a> 支持<a href="https://github.com/xiebruce/PicUploader" target="_blank" rel="noopener">PicUploader</a>配置的图床插件</li><li><a href="https://github.com/chengww5217/picgo-plugin-qingstor-uploader" target="_blank" rel="noopener">picgo-plugin-qingstor-uploader</a> 支持青云云存储的图床插件</li><li><a href="https://github.com/chengww5217/picgo-plugin-blog-uploader" target="_blank" rel="noopener">picgo-plugin-blog-uploader</a> 支持掘金、简书和CSDN来做图床的图床插件</li></ol><p>如果你也想为PicGo开发插件，欢迎阅读<a href="https://picgo.github.io/PicGo-Core-Doc/zh/" target="_blank" rel="noopener">开发文档</a>，PicGo有你更精彩哈哈！</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>和<a href="https://github.com/PicGo/PicGo-Core" target="_blank" rel="noopener">PicGo-Core</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及<a href="https://molunerfinn.com/tags/Electron-vue/">本系列文章</a>的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>感谢这些高质量的文章：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/38730825" target="_blank" rel="noopener">用Node.js开发一个Command Line Interface (CLI)</a></li><li><a href="https://zhuanlan.zhihu.com/p/26895282" target="_blank" rel="noopener">Node.js编写CLI的实践</a></li><li><a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism" target="_blank" rel="noopener">Node.js模块机制</a></li><li><a href="https://onetwo.ren/%E5%89%8D%E7%AB%AF%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">前端插件系统设计与实现</a></li><li><a href="https://blog.csdn.net/kyfxbl/article/details/47787827" target="_blank" rel="noopener">Hexo插件机制分析</a></li><li><a href="http://blog.yunplus.io/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/" target="_blank" rel="noopener">如何实现一个简单的插件扩展</a></li><li><a href="https://fenying.net/2017/12/02/publish-to-npm/" target="_blank" rel="noopener">使用NPM发布与维护TypeScript模块</a></li><li><a href="https://github.com/basarat/ts-npm-module" target="_blank" rel="noopener">typescript npm 包例子</a></li><li><a href="https://docs.travis-ci.com/user/deployment/npm/" target="_blank" rel="noopener">通过travis-ci发布npm包</a></li><li><a href="https://discuss.atom.io/t/dynamically-load-module-in-plugin-from-local-project-node-modules-folder/42930/2" target="_blank" rel="noopener">Dynamic load module in plugin from local project node_modules folder</a></li><li><a href="https://aotu.io/notes/2016/08/09/command-line-development/index.html" target="_blank" rel="noopener">跟着老司机玩转Node命令行</a></li><li>以及没来得及记录的那些好文章，感谢你们！</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;系列文章&lt;/a&gt;或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-5/&quot;&gt;通过CI发布以及更新的方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-6/&quot;&gt;开发插件系统——CLI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-7/&quot;&gt;开发插件系统——GUI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;想到再写…&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端(&lt;code&gt;Electron&lt;/code&gt;的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;之前的文章&lt;/a&gt;跟着看。并且如果没有看过前一篇CLI插件系统构建的朋友，需要先行阅读，本文涉及到的部分内容来自上一篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战5——开发插件系统之CLI部分</title>
    <link href="https://molunerfinn.com/electron-vue-6/"/>
    <id>https://molunerfinn.com/electron-vue-6/</id>
    <published>2019-02-04T11:30:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>祝大家2019年猪年新年快乐！本文较长，需要一定耐心看完哦~</strong></p><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇<a href="https://molunerfinn.com/tags/Electron-vue/">系列文章</a>或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从<a href="https://molunerfinn.com/tags/Electron-vue/">之前的文章</a>跟着看。</p><a id="more"></a><p><strong>说在前面，其实这篇文章写起来真的很难。如何构建一个插件系统，我花了半年的时间。要在一篇或者两篇文章里把这个东西说好是真的不容易。所以可能行文上会有一些瑕疵，后续会不断打磨。</strong></p><h2 id="插件系统——容器"><a href="#插件系统——容器" class="headerlink" title="插件系统——容器"></a>插件系统——容器</h2><p>相信很多人平时更多的是给其他框架诸如<code>Vue</code>、<code>React</code>或者<code>Webpack</code>等写插件。我们可以把提供插件系统的框架称为「容器」，通过容器暴露出来的API，插件可以挂载到容器上，或者接入容器的生命周期来实现一些更定制化的功能。</p><p>比如<code>Webpack</code>本质上是一个流程系统，它通过<a href="https://github.com/webpack/tapable" target="_blank" rel="noopener">Tapable</a>暴露了很多生命周期的钩子，插件可以通过接入这些生命周期钩子实现流水线作业——比如<code>babel</code>系列的插件把<code>ES6</code>代码转义成<code>ES5</code>；<code>SASS</code>、<code>LESS</code>、<code>Stylus</code>系列的插件把预处理的<code>CSS</code>代码编译成浏览器可识别的正常<code>CSS</code>代码等等。</p><p>我们要实现一个插件系统，本质上也是实现这么一个容器。这个容器以及对应的插件需要具备如下基本特征：</p><ul><li>容器在没有 <strong>第三方插件</strong> 接入的情况下也能 <strong>实现基本功能</strong></li><li>插件具有独立性</li><li>插件可配置可管理</li></ul><p>第一点应该很容易理解。如果一个插件系统因为没有第三方插件的存在就无法运行，那么这个插件系统有什么用呢？不过有别于第三方插件，很多插件系统有自己内置的插件，比如<code>vue-cli</code>、<code>Webpack</code>的一系列内置插件。这个时候插件系统本身的一些功能就会由内置的插件去实现。</p><p>第二点，插件的独立性是指插件本身运行时不会 <strong>主动</strong> 影响其他插件的运作。当然某个插件可以依赖于其他插件的运行结果。</p><p>第三点，插件如果不能配置不能管理，那么从安装插件阶段就会遇到问题。所以容器需要有设计良好的入口给予插件注册。</p><p>接下来的部分，我将结合<a href="https://github.com/PicGo/PicGo-Core" target="_blank" rel="noopener">PicGo-Core</a>与<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>来详细说明CLI插件系统与GUI插件系统如何构建与实现。</p><h2 id="CLI插件系统"><a href="#CLI插件系统" class="headerlink" title="CLI插件系统"></a>CLI插件系统</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>其实CLI插件系统可以认为是无GUI的插件系统，也就是运行在命令行或者不带有可视化界面的插件系统。为什么我们开发Electron的插件系统，需要扯到CLI插件系统呢？这里需要简单回顾一下Electron的结构：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncq342rk8j20cs0d63zd" alt="Electron结构"></p><p>可以看到除了<code>Renderer</code>的界面渲染，大部分的功能是由<code>Main</code>进程提供的。对于PicGo而言，它的底层应该是一个上传流程系统，如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-core-fix.jpg" alt="PicGo-Core"></p><ol><li>Input（输入）：接受来自外部的输入，默认是通过路径或者完整的图片base64信息</li><li>Transformer（转换器）：把输入转换成可以被上传器上传的对象（包含图片尺寸、base64、图片名等信息）</li><li>Uploader（上传器）：将来自转换器的输出上传到指定的地方，默认的上传器将会是SM.MS</li><li>Output（输出）：输出上传的结果，通常可以在输出的imgUrl里拿到结果</li></ol><p>所以理论上它的底层应该在Node.js端就能实现。而Electron的<code>Renderer</code>进程只是实现了GUI界面，去调用底层Node.js端实现的流程系统提供的API而已。类似于我们平时在开发网页时候的前后端分离，只不过现在这个后端是基于Node.js实现的插件系统。基于这个思路，我开始着手<a href="https://github.com/PicGo/PicGo-Core" target="_blank" rel="noopener">PicGo-Core</a>的实现。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>通常来说一个插件系统都有自己的一个生命周期，比如<code>Vue</code>有<code>beforeCreate</code>、<code>created</code>、<code>mounted</code>等等，<code>Webpack</code>有<code>beforeRun</code>、<code>run</code>、<code>afterCompile</code>等等。这个也是一个插件系统的灵魂所在，通过接入系统的生命周期，赋予了插件更多的自由度。</p><p>因此我们可以先来实现一个生命周期类。代码可以参考<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/core/Lifecycle.ts" target="_blank" rel="noopener">Lifecycle.ts</a>。</p><p>生命周期流程可以参考上面的流程图。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Lifecycle &#123;</span><br><span class="line">  <span class="comment">// 整个生命周期的入口</span></span><br><span class="line">  <span class="keyword">async</span> start (input: <span class="built_in">any</span>[]): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.beforeTransform(input)</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.doTransform(input)</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.beforeUpload(input)</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.doUpload(input)</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.afterUpload(input)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取原始输入，转换前</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> beforeTransform (input) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将输入转换成Uploader可上传的格式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> doTransform (input) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Uploader上传前</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> beforeUpload (input) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Uploader上传</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> doUpload (input) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Uploader上传完成后</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">async</span> afterUpload (input) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际使用中，我们可以通过：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lifeCycle = <span class="keyword">new</span> LifeCycle()</span><br><span class="line">lifeCycle.start([...])</span><br></pre></td></tr></table></figure><p>来运行整个上传流程的生命周期。不过到这里我们还没有看到任何跟插件相关的东西。这是为了实现我们说的第一个条件： 容器在没有 <strong>第三方插件</strong> 接入的情况下也能 <strong>实现基本功能</strong>。</p><h3 id="广播事件"><a href="#广播事件" class="headerlink" title="广播事件"></a>广播事件</h3><p>很多时候我们需要将一些事件以某种方式传递出去。就像发布订阅模型一样，由容器发布，由插件订阅。这个时候我们可以直接让<code>Lifecycle</code>这个类继承Node.js自带的<code>EventEmmit</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Lifecycle <span class="keyword">extends</span> EventEmitter &#123;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么<code>Lifecycle</code>也就拥有了<code>EventEmitter</code>的<code>emit</code>和<code>on</code>方法了。对于容器来说，我们只需要<code>emit</code>事件出去即可。</p><p>比如在<code>PicGo-Core</code>里，上传的整个流程都会往外广播事件，通知插件当前进行到什么阶段，并且将当前的输入或者输出在广播的时候发送出去。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> beforeTransform (input) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">this</span>.emit(<span class="string">'beforeTransform'</span>, input) <span class="comment">// 广播事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件可以自由选择监听想要监听的事件。比如插件想要知道上传结束后的结果（伪代码）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugin.on(<span class="string">'finished'</span>, <span class="function">(<span class="params">output</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(output) <span class="comment">// 获取output</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在开发PicGo-Core的时候，有一些很有用的事件。在这里我也想分享出来，虽然不是所有插件系统都会有这样的事件，但是结合自己和项目的实际需要，他们有的时候很有用。</p><h4 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h4><p>平时我们上传或者下载文件的时候，都会注意一个东西：进度条。同样，在PicGo-Core里也暴露了一个事件，叫做<code>uploadProgress</code>，用于告诉用户当前的上传进度。不过在PicGo-Core，上传进度是从<code>beforeTransform</code>就开始算了，为了方便计算，划分了5个固定的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> beforeTransform (input) &#123;</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'uploadProgress'</span>, <span class="number">0</span>) <span class="comment">// 转换前，进度0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> doTransform (input) &#123;</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'uploadProgress'</span>, <span class="number">30</span>) <span class="comment">// 开始转换，进度30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> beforeUpload (input) &#123;</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'uploadProgress'</span>, <span class="number">60</span>) <span class="comment">// 开始上传，进度60</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> afterUpload (input) &#123;</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'uploadProgress'</span>, <span class="number">100</span>) <span class="comment">// 上传完毕，进度100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上传失败的话就返回<code>-1</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> start (input: <span class="built_in">any</span>[]): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">await</span> <span class="keyword">this</span>.beforeTransform(input)</span><br><span class="line">   <span class="keyword">await</span> <span class="keyword">this</span>.doTransform(input)</span><br><span class="line">   <span class="keyword">await</span> <span class="keyword">this</span>.beforeUpload(input)</span><br><span class="line">   <span class="keyword">await</span> <span class="keyword">this</span>.doUpload(input)</span><br><span class="line">   <span class="keyword">await</span> <span class="keyword">this</span>.afterUpload(input)</span><br><span class="line"> &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(e)</span><br><span class="line">   <span class="keyword">this</span>.emit(<span class="string">'uploadProgress'</span>, <span class="number">-1</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过监听这个事件，PicGo就能做出如下的上传进度条：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-2.0.gif" alt="progress-bar"></p><h4 id="系统通知"><a href="#系统通知" class="headerlink" title="系统通知"></a>系统通知</h4><p>如果上传出了问题，或者有些信息需要通过系统级别的通知告诉用户的话，可以发布<code>notification</code>事件。通过监听这个事件可以调用系统通知来发布。插件也可以发布这个事件，让PicGo监听。如上图上传成功后右上角的通知。</p><h3 id="接入生命周期"><a href="#接入生命周期" class="headerlink" title="接入生命周期"></a>接入生命周期</h3><p>上部分讲到了生命周期中的事件广播，可以发现事件广播是只管发不管结果的。也就是PicGo-Core只管发布这个事件，至于有没有插件监听，监听后做了什么都不用关心。（怎么有点像UDP一样）。但是实际上很多时候我们需要接入生命周期做一些事情的。</p><p>就拿上传流程来说，我要是想要上传前压缩图片，那么监听<code>beforeUpload</code>事件是做不到的。因为在<code>beforeUpload</code>事件里就算你把图片已经压缩了，恐怕上传的流程早就走完了，<code>emit</code>事件出去后生命周期照旧运行。</p><p>因此我们需要在容器的生命周期里实现一个功能，能够让插件接入它的生命周期，在执行完当前生命周期的插件的动作后，才把结果送往下一个生命周期。可以发现，这里有一个「等待」插件执行的动作。因此PicGo-Core使用最简易而直观的<code>async</code>函数配合<code>await</code>来实现「等待」。</p><p>我们先不用考虑插件是如何注册的，后文会说到。我们先来实现怎么让插件接入生命周期。</p><p>下面以生命周期<code>beforeUpload</code>为例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> beforeUpload (input) &#123;</span><br><span class="line">  <span class="keyword">this</span>.ctx.emit(<span class="string">'uploadProgress'</span>, <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">this</span>.ctx.emit(<span class="string">'beforeUpload'</span>, input)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">this</span>.handlePlugins(beforeUploadPlugins.getList(), input) <span class="comment">// 执行并「等待」插件执行结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们通过<code>await</code>等待生命周期方法<code>handlePlugins</code>（下文会说明如何实现）的执行结束。而我们运行的插件列表是通过<code>beforeUploadPlugins.getList()</code>（下文会说明如何实现）获取的，说明这些是只针对<code>beforeUpload</code>这个生命周期的插件。然后将输入<code>input</code>传入<code>handlePlugins</code>让插件们调用即可。</p><p>现在我们实现一下<code>handlePlugins</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> handlePlugins (plugins: Plugin[], input: <span class="built_in">any</span>[]) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(plugins.map(<span class="keyword">async</span> (plugin: Plugin) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> plugin.handle(input)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>Promise.all</code>以及<code>await</code>来「等待」所有插件执行。这里需要注意的是，每个PicGo插件需要实现一个<code>handle</code>方法来供<code>PicGo-Core</code>调用。可以看到，这里实现我们说的第二个特征： <strong>插件具有独立性</strong>。</p><p>从这里也能看到我们通过<code>async</code>和<code>await</code>构建了一个能够「等待」插件执行结束的环境。这样就解决了光是通过广播事件无法接入插件系统的生命周期的问题。</p><p>不，等等，这里还有一个问题。<code>beforeUploadPlugins.getList()</code>是哪来的？上面只是一个示例代码。实际上PicGo-Core根据上传流程里的不同生命周期预留了五种不同的插件：</p><ul><li>beforeTransformPlugins</li><li>transformer</li><li>beforeUploadPlugins</li><li>uploader</li><li>afterUploadPlugins</li></ul><p>分别在上传的5个周期里调用。虽然这5种插件调用的时机不一样，但是它们的实现是同样的：有同样的注册机制、同样的方法用于获取插件列表、获取插件信息等等。所以我们接下去来实现一个生命周期的插件类。</p><h3 id="生命周期插件类"><a href="#生命周期插件类" class="headerlink" title="生命周期插件类"></a>生命周期插件类</h3><p>这个是插件系统里很关键的一环，这个类的实现了插件应该以什么方式注册到我们的插件系统里，以及插件系统如何获取他们。这块的代码可以参考 <a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/lib/LifecyclePlugins.ts" target="_blank" rel="noopener">LifecyclePlugins.ts</a>。</p><p>以下是实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LifecyclePlugins &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// list就是插件列表。以对象形式呈现。</span></span><br><span class="line">  list: &#123;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: Plugin</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list = &#123;&#125; <span class="comment">// 初始化插件列表为&#123;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插件注册的入口</span></span><br><span class="line">  register (id: <span class="built_in">string</span>, plugin: Plugin): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">// 如果插件没有提供id，则不予注册</span></span><br><span class="line">    <span class="keyword">if</span> (!id) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'id is required!'</span>)</span><br><span class="line">    <span class="comment">// 如果插件没有handle的方法，则不予注册</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.handle !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'plugin.handle must be a function!'</span>)</span><br><span class="line">    <span class="comment">// 如果插件的id重复了，则不予注册</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.list[id]) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> duplicate id: <span class="subst">$&#123;id&#125;</span>!`</span>)</span><br><span class="line">    <span class="keyword">this</span>.list[id] = plugin</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过插件ID获取插件</span></span><br><span class="line">  <span class="keyword">get</span> (id: <span class="built_in">string</span>): Plugin &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list[id]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取插件列表</span></span><br><span class="line">  getList (): Plugin[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.list).map(<span class="function">(<span class="params">item: <span class="built_in">string</span></span>) =&gt;</span> <span class="keyword">this</span>.list[item])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取插件ID列表</span></span><br><span class="line">  getIdList (): <span class="built_in">string</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> LifecyclePlugins</span><br></pre></td></tr></table></figure><p>对于插件而言最重要的是<code>register</code>方法，它是插件注册的入口。通过<code>register</code>注册后，会在<code>Lifecycle</code>内部的<code>list</code>以<code>id:plugin</code>形式里写入这个插件。注意到，PicGo-Core要求每个插件需要实现一个<code>handle</code>的方法，用于之后在生命周期里调用。</p><p>这里用伪代码说明一下插件要如何注册：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeTransformPlugins.register(<span class="string">'test'</span>, &#123;</span><br><span class="line">  handle (ctx) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们就注册了一个<code>id</code>叫做<code>test</code>的插件，它是一个<code>beforeTransform</code>阶段的插件，它的作用就是打印传入的信息。</p><p>然后在不同的生命周期里，调用<code>LifeCyclePlugins.getList()</code>的方法就能获取这个生命周期对应的插件的列表了。</p><h3 id="抽离出核心类"><a href="#抽离出核心类" class="headerlink" title="抽离出核心类"></a>抽离出核心类</h3><p>如果仅仅是实现一个能够在Node.js项目里运行的插件系统，上面两个部分基本就够了：</p><ol><li>Lifecyle类负责整个生命周期</li><li>LifecylePlugins类负责插件的注册与调用</li></ol><p>不过一个良好的CLI插件系统还需要至少如下的部分（至少我觉得）：</p><ol><li>可以通过命令行调用</li><li>能够读取配置文件进行额外配置</li><li>命令行一键安装插件</li><li>命令行完成插件配置</li><li>友好的log信息提示</li></ol><blockquote><p>此处可以参考vue-cli3这个工具。</p></blockquote><p>因此我们至少还需要如下的部分：</p><ol><li>命令行操作相关的类</li><li>配置文件操作相关</li><li>插件安装、卸载、更新等相关操作的类</li><li>插件加载相关的类</li><li>日志信息输出相关的类</li></ol><p>这上面的几个部分都跟生命周期类本身没有特别强的耦合关系，所以可以不必将它们都放到生命周期类里实现。</p><p>相对的，我们抽离出一个<code>Core</code>作为核心，将上述这些类包含到这个核心类中，核心类负责命令行命令的注册、插件的加载、优化日志信息以及调用生命周期等等。</p><p>最后再将这个核心类暴露出去，供使用者或者开发者使用。这个就是PicGo-Core的核心 <a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/core/PicGo.ts" target="_blank" rel="noopener">PicGo.ts</a> 的实现。</p><p>PicGo本身的实现并不复杂，基本上只是调用上述几个类实例的方法。</p><p>不过注意到这里有一个之前一直没有提到的东西。PicGo-Core除了核心PicGo之外的几个子类里，基本上在<code>constructor</code>构建函数阶段都会传入一个叫做<code>ctx</code>的参数。这个参数是什么？这个参数是PicGo这个类自身的<code>this</code>。通过传入<code>this</code>，PicGo-Core的子类也能使用PicGo核心类暴露出来的方法了。</p><p>比如<code>Logger</code>类实现了美观的命令行日志输出：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/20180912153940.png" alt="logger"></p><p>那么在其他子类里想要调用<code>Logger</code>的方法也很容易：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.log.success(<span class="string">'Hello world!'</span>)</span><br></pre></td></tr></table></figure><p>其中<code>ctx</code>就是我们上面说的，PicGo自身的<code>this</code>指针。</p><p>我们接下去介绍的每个类具体的实现。</p><h3 id="日志输出相关类"><a href="#日志输出相关类" class="headerlink" title="日志输出相关类"></a>日志输出相关类</h3><p>先从这个类开始说起是因为这个类是最简单而且侵入性最小的一个类。有它没它都行，但是有它自然是锦上添花。</p><p>PicGo实现美化日志输出的库是<a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a>，它的作用就是用来输出花花绿绿的命令行文字：</p><p><img src="https://camo.githubusercontent.com/036b5e5ae84937a17ce0a1a424aeb6f7eb23863f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6368616c6b2f616e73692d7374796c657340383236313639376339356266333462366337373637653263626539393431613835316435393338352f73637265656e73686f742e737667" alt></p><p>用起来也很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = chalk.green(<span class="string">'Success'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(log) <span class="comment">// 绿色字体的Success</span></span><br></pre></td></tr></table></figure><p>我们打算实现4种输出类型，success、warn、info和error：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/20180912153940.png" alt="logger"></p><p>于是创建如下的类：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chalk <span class="keyword">from</span> <span class="string">'chalk'</span></span><br><span class="line"><span class="keyword">import</span> PicGo <span class="keyword">from</span> <span class="string">'../core/PicGo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Logger &#123;</span><br><span class="line">  level: &#123;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">  &#125;</span><br><span class="line">  ctx: PicGo</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">ctx: PicGo</span>) &#123; <span class="comment">// 将PicGo的this传入构造函数，使得Logger也能使用PicGo核心类暴露的方法</span></span><br><span class="line">    <span class="keyword">this</span>.level = &#123;</span><br><span class="line">      success: <span class="string">'green'</span>,</span><br><span class="line">      info: <span class="string">'blue'</span>,</span><br><span class="line">      warn: <span class="string">'yellow'</span>,</span><br><span class="line">      error: <span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际输出函数</span></span><br><span class="line">  <span class="keyword">protected</span> handleLog (<span class="keyword">type</span>: <span class="built_in">string</span>, msg: <span class="built_in">string</span> | <span class="built_in">Error</span>): <span class="built_in">string</span> | <span class="built_in">Error</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.ctx.config.silent) &#123; <span class="comment">// 如果不是静默模式，静默模式不输出log</span></span><br><span class="line">      <span class="keyword">let</span> log = chalk[<span class="keyword">this</span>.level[<span class="keyword">type</span>]](<span class="string">`[PicGo <span class="subst">$&#123;type.toUpperCase()&#125;</span>]: `</span>)</span><br><span class="line">      log += msg</span><br><span class="line">      <span class="built_in">console</span>.log(log)</span><br><span class="line">      <span class="keyword">return</span> msg</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应四种不同类型</span></span><br><span class="line">  success (msg: <span class="built_in">string</span> | <span class="built_in">Error</span>): <span class="built_in">string</span> | <span class="built_in">Error</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleLog(<span class="string">'success'</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  info (msg: <span class="built_in">string</span> | <span class="built_in">Error</span>): <span class="built_in">string</span> | <span class="built_in">Error</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleLog(<span class="string">'info'</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error (msg: <span class="built_in">string</span> | <span class="built_in">Error</span>): <span class="built_in">string</span> | <span class="built_in">Error</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleLog(<span class="string">'error'</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  warn (msg: <span class="built_in">string</span> | <span class="built_in">Error</span>): <span class="built_in">string</span> | <span class="built_in">Error</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleLog(<span class="string">'warn'</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Logger</span><br></pre></td></tr></table></figure><p>之后再将<code>Logger</code>这个类挂载到PicGo核心类上：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Logger <span class="keyword">from</span> <span class="string">'../lib/Logger'</span></span><br><span class="line"><span class="keyword">class</span> PicGo &#123;</span><br><span class="line">  log: Logger</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.log = <span class="keyword">new</span> Logger(<span class="keyword">this</span>) <span class="comment">// 把this传入Logger，也就是Logger里的ctx</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样其他挂载到PicGo核心类上的类就能使用<code>ctx.log</code>来调用log里的方法了。</p><h3 id="配置文件相关"><a href="#配置文件相关" class="headerlink" title="配置文件相关"></a>配置文件相关</h3><p>很多时候我们的所写的系统也好、插件也好，或多或少需要一些配置之后才能更好地使用。比如<code>vue-cli3</code>的<code>vue.config.js</code>，比如<code>hexo</code>的<code>_config.yml</code>等等。而PicGo也不例外。默认情况下它可以直接使用，但是如果想要做些其他操作，自然就需要配置了。所以配置文件是插件系统很重要的一个组成部分。</p><p>之前我在Electron版的PicGo上使用了<a href="https://github.com/typicode/lowdb" target="_blank" rel="noopener">lowdb</a>作为JSON配置文件的读写库，体验不错。为了向前兼容PicGo的配置，写PicGo-Core的时候我依然采用了这个库。关于lowdb的一些具体用法，我在之前的一篇文章里有提及，有兴趣的可以看看——<a href="https://molunerfinn.com/electron-vue-3/">传送门</a>。</p><p>由于lowdb做的是类似MySQL一样的持久化配置，它需要磁盘上一个具体的JSON文件作为载体，所以无法通过创建一个配置对象去初始化配置。因此一切都从这个配置文件展开：</p><p>PicGo-Core采用一个默认的配置文件：<code>homedir()/.picgo/config.json</code>，如果在实例化PicGo没提供配置文件路径那么就会使用这个文件。如果使用者提供了具体的配置文件，那么就会使用所提供的配置文件。</p><p>下面来实现一下PicGo初始化的过程：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">class</span> PicGo <span class="keyword">extends</span> EventEmitter &#123;</span><br><span class="line">  configPath: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">private</span> lifecycle: Lifecycle</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">configPath: <span class="built_in">string</span> = ''</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.configPath = configPath <span class="comment">// 传入configPath</span></span><br><span class="line">    <span class="keyword">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.configPath === <span class="string">''</span>) &#123; <span class="comment">// 如果不提供配置文件路径，就使用默认配置</span></span><br><span class="line">      <span class="keyword">this</span>.configPath = homedir() + <span class="string">'/.picgo/config.json'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path.extname(<span class="keyword">this</span>.configPath).toUpperCase() !== <span class="string">'.JSON'</span>) &#123; <span class="comment">// 如果配置文件的格式不是JSON就返回错误日志</span></span><br><span class="line">      <span class="keyword">this</span>.configPath = <span class="string">''</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.log.error(<span class="string">'The configuration file only supports JSON format.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> exist = fs.pathExistsSync(<span class="keyword">this</span>.configPath)</span><br><span class="line">    <span class="keyword">if</span> (!exist) &#123; <span class="comment">// 如果不存在就创建</span></span><br><span class="line">      fs.ensureFileSync(<span class="string">`<span class="subst">$&#123;this.configPath&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在实例化PicGo的时候就是如下这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PicGo = <span class="built_in">require</span>(<span class="string">'picgo'</span>)</span><br><span class="line"><span class="keyword">const</span> picgo = <span class="keyword">new</span> PicGo() <span class="comment">// 不提供配置文件就用默认配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> picgo = <span class="keyword">new</span> PicGo(<span class="string">'./xxx.json'</span>) <span class="comment">// 提供配置文件就用所提供的配置文件</span></span><br></pre></td></tr></table></figure><p>有了配置文件之后，我们只需要实现三个基本操作：</p><ol><li>初始化配置</li><li>读取配置</li><li>写入配置（写入配置包括创建、更新、删除等）</li></ol><h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><p>一般来说我们的系统都会有一些默认的配置，PicGo也不例外。我们可以选择把默认配置写到代码里，也可以选择把默认配置写到代码里。因为PicGo的配置文件有持久化的需求，所以把一些关键的默认配置写入配置文件是合理的。</p><p>初始化配置的时候会用到<a href="https://github.com/typicode/lowdb" target="_blank" rel="noopener">lowdb</a>的一些知识，这里就不展开了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lowdb <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initConfig = (configPath: <span class="built_in">string</span>): lowdb.LowdbSync&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(configPath, &#123; <span class="comment">// lowdb的adapter，用于读取配置文件</span></span><br><span class="line">    deserialize: (data: <span class="built_in">string</span>): <span class="function"><span class="params">Function</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">`return <span class="subst">$&#123;data&#125;</span>`</span>))()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> db = lowdb(adapter) <span class="comment">// 暴露出来的db对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!db.has(<span class="string">'picBed'</span>).value()) &#123; <span class="comment">// 如果没有picBed配置</span></span><br><span class="line">    db.set(<span class="string">'picBed'</span>, &#123; <span class="comment">// 就生成一个默认图床为SM.MS的配置</span></span><br><span class="line">      current: <span class="string">'smms'</span></span><br><span class="line">    &#125;).write()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!db.has(<span class="string">'picgoPlugins'</span>).value()) &#123; <span class="comment">// 同理</span></span><br><span class="line">    db.set(<span class="string">'picgoPlugins'</span>, &#123;&#125;).write()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> db <span class="comment">// 将db暴露出去让外部使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在PicGo初始化阶段就可以将<code>configPath</code>传入，来实现配置的初始化，以及获取配置。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> db = initConfig(<span class="keyword">this</span>.configPath)</span><br><span class="line">  <span class="keyword">this</span>.config = db.read().value() <span class="comment">// 将配置文件内容存入this.config</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h4><p>一旦初始化配置之后，要获取配置就很容易了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">get</span> &#125; <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line">getConfig (name: <span class="built_in">string</span> = <span class="string">''</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (name) &#123; <span class="comment">// 如果提供了配置项的名字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>(<span class="keyword">this</span>.config, name) <span class="comment">// 返回具体配置项结果</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.config <span class="comment">// 否则就返回完整配置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了<code>lodash</code>的<code>get</code>方法，主要是为了方便获取如下情况：</p><p>比如配置内容长这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"a"</span>: &#123;</span><br><span class="line">    <span class="attr">"b"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往常我们要获取<code>a.b</code>需要：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="keyword">this</span>.config.a.b</span><br></pre></td></tr></table></figure><p>万一遇到<code>a</code>不存在的时候，那么上面那句话就会报错了。因为<code>a</code>不存在，那么<code>a.b</code>就是<code>undefined.b</code>自然会报错了。而用<code>lodash</code>的<code>get</code>方法则可以避免这个问题，并且可以很方便的获取：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="keyword">get</span>(<span class="keyword">this</span>.config, <span class="string">'a.b'</span>)</span><br></pre></td></tr></table></figure><p>如果<code>a</code>不存在，那么获取到的结果<code>b</code>也不会报错，而是<code>undefined</code>。</p><h4 id="写入配置"><a href="#写入配置" class="headerlink" title="写入配置"></a>写入配置</h4><p>有了上面的铺垫，写入内容也很简单。通过<code>lowdb</code>提供的接口，写入配置如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> saveConfig = (configPath: <span class="built_in">string</span>, config: <span class="built_in">any</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> db = initConfig(configPath)</span><br><span class="line">  <span class="built_in">Object</span>.keys(config).forEach(<span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    db.read().set(name, config[name]).write()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saveConfig(<span class="keyword">this</span>.configPath, &#123; a: &#123; b: <span class="literal">true</span> &#125; &#125;)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saveConfig(<span class="keyword">this</span>.configPath, &#123; <span class="string">'a.b'</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><p>上面两种写法都会生成如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"a"</span>: &#123;</span><br><span class="line">    <span class="attr">"b"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到明显后者更简洁点。这多亏了lowdb里由lodash提供的<code>set</code>方法。</p><p>至此我们已经将配置文件相关的操作实现完了。其实可以把这堆操作封装成一个类的，PicGo-Core在一开始实现的时候觉得东西不多不复杂，所以只是抽成了一个小工具来调用的。当然这个不是关键，关键在于实现了配置文件的相关操作后，你的系统和这个系统的插件都能因此受益。系统可以把跟配置文件相关的操作的API暴露给插件使用。接下去我们一步步来完善这个插件系统。</p><h3 id="插件操作类"><a href="#插件操作类" class="headerlink" title="插件操作类"></a>插件操作类</h3><p>暂时没想好这个类要取的名字是啥，代码里我写的是<code>pluginHandler</code>，那么就叫它插件操作类吧。这个类主要目的就三个：</p><ol><li>通过<code>npm</code>安装插件 —— install</li><li>通过<code>npm</code>卸载插件 —— uninstall</li><li>通过<code>npm</code>更新插件 —— update</li></ol><p>用<code>npm</code>来分发插件，这是大多数Node.js插件系统会选择的解决方案。毕竟在没有自己的插件商店（比如VSCode）的基础上，<code>npm</code>就是一个天然的「插件商店」。当然发布到<code>npm</code>之上好处还有很多，比如可以十分方便地来对插件进行安装、更新和卸载，比如对Node.js用户来说是0成本的上手。这也是<code>pluginHandler</code>这个类要做的事。</p><blockquote><p><code>pluginHandler</code>相关的实现思路来自<a href="https://github.com/feflow/feflow" target="_blank" rel="noopener">feflow</a>，特此感谢。</p></blockquote><p>平时我们安装一个npm模块的时候，很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxxx --save</span><br></pre></td></tr></table></figure><p>不过我们是在当前项目目录的上来安装的。PicGo由于引入了配置文件，所以我们可以直接在配置文件所在的目录里进行插件的安装，这样如果你要卸载PicGo，只要把。但是每次都让用户打开PicGo的配置文件所在的路径去安装插件未免太累了。这样也不优雅。</p><p>相对的，如果我们全局安装了<code>picgo</code>之后，在文件系统任何一个角落里只需要通过<code>picgo install xxx</code>就能安装一个<code>picgo</code>的插件，而不需要定位到PicGo的配置文件所在的文件夹，这样用户体验会好不少。这里大家可以类比<code>vue-cli3</code>安装插件的步骤。</p><p>为了实现这个效果，我们需要通过代码的方式去调用<code>npm</code>这个命令。那么Node.js要如何通过代码去实现命令行调用呢？</p><p>这里我们可以使用<a href="https://github.com/moxystudio/node-cross-spawn" target="_blank" rel="noopener">cross-spawn</a>来实现跨平台的、通过代码来调用命令行的目的。</p><p><code>spawn</code>这个方法Node.js原生也有（在child_process里），不过<code>cross-spawn</code>解决了一些跨平台的问题。使用上是一样的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'cross-spawn'</span>)</span><br><span class="line">spawn(<span class="string">'npm'</span>, [<span class="string">'install'</span>, <span class="string">'@vue/cli'</span>, <span class="string">'-g'</span>])</span><br></pre></td></tr></table></figure><p>可以看到，它的参数是以数组的形式传入的。</p><p>而我们要实现的插件操作，除了主要命令<code>install</code>、<code>update</code>、<code>uninstall</code>不一样之外，其他的参数都是一样的。所以我们抽离出一个<code>execCommand</code>的方法来实现它们背后的公共逻辑：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">execCommand (cmd: <span class="built_in">string</span>, modules: <span class="built_in">string</span>[], where: <span class="built_in">string</span>, proxy: <span class="built_in">string</span> = <span class="string">''</span>): <span class="built_in">Promise</span>&lt;Result&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve: <span class="built_in">any</span>, reject: <span class="built_in">any</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// spawn的命令行参数是以数组形式传入</span></span><br><span class="line">    <span class="comment">// 此处将命令和要安装的插件以数组的形式拼接起来</span></span><br><span class="line">    <span class="comment">// 此处的cmd指的是执行的命令，比如install\uninstall\update</span></span><br><span class="line">    <span class="keyword">let</span> args = [cmd].concat(modules).concat(<span class="string">'--color=always'</span>).concat(<span class="string">'--save'</span>)</span><br><span class="line">    <span class="keyword">const</span> npm = spawn(<span class="string">'npm'</span>, args, &#123; cwd: where &#125;) <span class="comment">// 执行npm，并通过 cwd指定执行的路径——配置文件所在文件夹</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">''</span></span><br><span class="line">    npm.stdout.on(<span class="string">'data'</span>, <span class="function">(<span class="params">data: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">      output += data <span class="comment">// 获取输出日志</span></span><br><span class="line">    &#125;).pipe(process.stdout)</span><br><span class="line"></span><br><span class="line">    npm.stderr.on(<span class="string">'data'</span>, <span class="function">(<span class="params">data: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">      output += data <span class="comment">// 获取报错日志</span></span><br><span class="line">    &#125;).pipe(process.stderr)</span><br><span class="line"></span><br><span class="line">    npm.on(<span class="string">'close'</span>, <span class="function">(<span class="params">code: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!code) &#123;</span><br><span class="line">        resolve(&#123; code: <span class="number">0</span>, data: output &#125;) <span class="comment">// 如果没有报错就输出正常日志</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(&#123; code: code, data: output &#125;) <span class="comment">// 如果报错就输出报错日志</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键的部分基本都已经在代码里给出了注释。当然这里还是有一些需要注意的地方。注意这句话：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> npm = spawn(<span class="string">'npm'</span>, args, &#123; cwd: where &#125;) <span class="comment">// 执行npm，并通过 cwd指定执行的路径——配置文件所在文件夹</span></span><br></pre></td></tr></table></figure><p>里面的<code>{cwd: where}</code>，这个<code>where</code>是会从外部传进来的值，表示这个<code>npm</code>命令会在哪个目录下执行。这个也是我们要做这个插件操作类最关键的地方——不用让用户主动打开配置文件所在目录去安装插件，在系统任何地方都可以轻松安装PicGo的插件。</p><p>接下去我们实现一下<code>install</code>方法，这样另外两个就可以类推了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> install (plugins: <span class="built_in">string</span>[], proxy: <span class="built_in">string</span>): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  plugins = plugins.map(<span class="function">(<span class="params">item: <span class="built_in">string</span></span>) =&gt;</span> <span class="string">'picgo-plugin-'</span> + item)</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.execCommand(<span class="string">'install'</span>, plugins, <span class="keyword">this</span>.ctx.baseDir, proxy)</span><br><span class="line">   <span class="keyword">if</span> (!result.code) &#123;</span><br><span class="line">     <span class="keyword">this</span>.ctx.log.success(<span class="string">'插件安装成功'</span>)</span><br><span class="line">     <span class="keyword">this</span>.ctx.emit(<span class="string">'installSuccess'</span>, &#123;</span><br><span class="line">       title: <span class="string">'插件安装成功'</span>,</span><br><span class="line">       body: plugins</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> err = <span class="string">`插件安装失败，失败码为<span class="subst">$&#123;result.code&#125;</span>，错误日志为<span class="subst">$&#123;result.data&#125;</span>`</span></span><br><span class="line">     <span class="keyword">this</span>.ctx.log.error(err)</span><br><span class="line">     <span class="keyword">this</span>.ctx.emit(<span class="string">'failed'</span>, &#123;</span><br><span class="line">       title: <span class="string">'插件安装失败'</span>,</span><br><span class="line">       body: err</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看代码很多，关键就一句<code>const result = await this.execCommand(&#39;install&#39;, plugins, this.ctx.baseDir, proxy)</code>，剩下的都是日志输出而已。好了，插件也安装完了，如何加载呢？</p><h3 id="插件加载类"><a href="#插件加载类" class="headerlink" title="插件加载类"></a>插件加载类</h3><p>上面说了，我们会将插件安装在配置文件所在目录里。值得注意的是，由于<code>npm</code>的特点，如果目录里有个叫做<code>package.json</code>的文件，那么安装插件、更新插件等操作会同时修改<code>package.json</code>文件。因此我们可以通过读取<code>package.json</code>文件来得知当前目录下有什么PicGo的插件。这也是Hexo的插件加载机制里的很重要的一环。</p><blockquote><p><code>pluginLoader</code>相关的实现思路来自<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">hexo</a>，特此感谢。</p></blockquote><p>关于插件的命名，PicGo这里有个约束（这也是很多插件系统选择的方式），必须以<code>picgo-plugin-</code>开头。这样才能方便插件加载类识别它们。</p><p>这里有一个小坑。如果我们配置文件所在的目录里没有<code>package.json</code>的话，那么执行安装插件的命令会有报错信息。但是我们不想让用户看到这个报错，于是在初始化<code>插件加载类</code>的时候，需要判断一下这个文件存不存在，如果不存在那么我们就要创建一个：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> PluginLoader &#123;</span><br><span class="line">  ctx: PicGo</span><br><span class="line">  list: <span class="built_in">string</span>[]</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">ctx: PicGo</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx</span><br><span class="line">    <span class="keyword">this</span>.list = [] <span class="comment">// 插件列表</span></span><br><span class="line">    <span class="keyword">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init (): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> packagePath = path.join(<span class="keyword">this</span>.ctx.baseDir, <span class="string">'package.json'</span>)</span><br><span class="line">    <span class="keyword">if</span> (!fs.existsSync(packagePath)) &#123; <span class="comment">// 如果不存在</span></span><br><span class="line">      <span class="keyword">const</span> pkg = &#123;</span><br><span class="line">        name: <span class="string">'picgo-plugins'</span>,</span><br><span class="line">        description: <span class="string">'picgo-plugins'</span>,</span><br><span class="line">        repository: <span class="string">'https://github.com/Molunerfinn/PicGo-Core'</span>,</span><br><span class="line">        license: <span class="string">'MIT'</span></span><br><span class="line">      &#125;</span><br><span class="line">      fs.writeFileSync(packagePath, <span class="built_in">JSON</span>.stringify(pkg), <span class="string">'utf8'</span>) <span class="comment">// 创建这个文件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们要实现最关键的<code>load</code>方法了。我们需要如下步骤：</p><ol><li>先通过<code>package.json</code>来找到所有合法的插件</li><li>通过<code>require</code>来加载插件</li><li>通过维护<code>picgoPlugins</code>配置来判断插件是否被禁用</li><li>通过执行未被禁用的插件暴露的<code>register</code>方法来实现插件注册</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PicGo <span class="keyword">from</span> <span class="string">'../core/PicGo'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">'resolve'</span></span><br><span class="line"></span><br><span class="line">load (): <span class="built_in">void</span> | <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> packagePath = path.join(<span class="keyword">this</span>.ctx.baseDir, <span class="string">'package.json'</span>)</span><br><span class="line">  <span class="keyword">const</span> pluginDir = path.join(<span class="keyword">this</span>.ctx.baseDir, <span class="string">'node_modules/'</span>)</span><br><span class="line">    <span class="comment">// Thanks to hexo -&gt; https://github.com/hexojs/hexo/blob/master/lib/hexo/load_plugins.js</span></span><br><span class="line">  <span class="keyword">if</span> (!fs.existsSync(pluginDir)) &#123; <span class="comment">// 如果插件文件夹不存在，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> json = fs.readJSONSync(packagePath) <span class="comment">// 读取package.json</span></span><br><span class="line">  <span class="keyword">const</span> deps = <span class="built_in">Object</span>.keys(json.dependencies || &#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> devDeps = <span class="built_in">Object</span>.keys(json.devDependencies || &#123;&#125;)</span><br><span class="line">  <span class="comment">// 1.获取插件列表</span></span><br><span class="line">  <span class="keyword">const</span> modules = deps.concat(devDeps).filter(<span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/^picgo-plugin-|^@[^/]+\/picgo-plugin-/</span>.test(name)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> path = <span class="keyword">this</span>.resolvePlugin(<span class="keyword">this</span>.ctx, name) <span class="comment">// 获取插件路径</span></span><br><span class="line">    <span class="keyword">return</span> fs.existsSync(path)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> modules) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(modules[i]) <span class="comment">// 把插件push进插件列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.ctx.config.picgoPlugins[modules[i]] || <span class="keyword">this</span>.ctx.config.picgoPlugins[modules[i]] === <span class="literal">undefined</span>) &#123; <span class="comment">// 3.判断插件是否被禁用，如果是undefined则为新安装的插件，默认不禁用</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.getPlugin(modules[i]).register() <span class="comment">// 4.调用插件的`register`方法进行注册</span></span><br><span class="line">        <span class="keyword">const</span> plugin = <span class="string">`picgoPlugins[<span class="subst">$&#123;modules[i]&#125;</span>]`</span></span><br><span class="line">        <span class="keyword">this</span>.ctx.saveConfig( <span class="comment">// 将插件设为启用--&gt;让新安装的插件的值从undefined变成true</span></span><br><span class="line">          &#123;</span><br><span class="line">            [plugin]: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx.log.error(e)</span><br><span class="line">        <span class="keyword">this</span>.ctx.emit(<span class="string">'notification'</span>, &#123;</span><br><span class="line">          title: <span class="string">`Plugin <span class="subst">$&#123;modules[i]&#125;</span> Load Error`</span>,</span><br><span class="line">          body: e</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">resolvePlugin (ctx: PicGo, name: <span class="built_in">string</span>): <span class="built_in">string</span> &#123; <span class="comment">// 获取插件路径</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve.sync(name, &#123; basedir: ctx.baseDir &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> path.join(ctx.baseDir, <span class="string">'node_modules'</span>, name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">getPlugin (name: <span class="built_in">string</span>): <span class="built_in">any</span> &#123; <span class="comment">// 通过插件名获取插件</span></span><br><span class="line">  <span class="keyword">const</span> pluginDir = path.join(<span class="keyword">this</span>.ctx.baseDir, <span class="string">'node_modules/'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(pluginDir + name)(<span class="keyword">this</span>.ctx) <span class="comment">// 2.通过require获取插件并传入ctx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>load</code>这个方法是整个插件系统加载的最关键的部分。光看上面的步骤和代码可能没办法很好理解。我们下面用一个具体的插件例子来说明。</p><p>假设我写了一个<code>picgo-plugin-xxx</code>的插件。我的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件系统会传入picgo的ctx，方便插件调用picgo暴露出来的api</span></span><br><span class="line"><span class="comment">// 所以我们需要有一个ctx的参数用于接收来自picgo的api</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插件系统会调用这个方法来进行插件的注册</span></span><br><span class="line">  <span class="keyword">const</span> register = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ctx.helper.beforeTransformPlugins.register(<span class="string">'xxx'</span>, &#123;</span><br><span class="line">      handle (ctx) &#123; <span class="comment">// 调用插件的 handle 方法时也会传入 ctx 方便调用api</span></span><br><span class="line">        <span class="built_in">console</span>.log(ctx.output)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    register</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从前文已经大概知道插件运行流程：</p><ol><li>首先运行生命周期</li><li>当运行到某个生命周期，比如这里的<code>beforeTransform</code>，那么这个阶段就去获取<code>beforeTransformPlugins</code>这些插件</li><li><code>beforeTransformPlugins</code>这些插件由<code>ctx.helper.beforeTransformPlugins.register</code>方法注册，并可以通过<code>ctx.helper.beforeTransformPlugins.getList()</code>获取</li><li>拿到插件之后将调用每个<code>beforeTransformPlugins</code>的<code>handle</code>方法，并传入<code>ctx</code>供插件使用</li></ol><p>注意上面的第三步，<code>ctx.helper.beforeTransformPlugins.register</code>这个方法是在什么时候被调用的？答案就是在本小节介绍的插件的加载阶段，<code>pluginLoader</code>调用了每个插件的<code>register</code>方法，那么在插件的<code>register</code>方法里，我们写了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.helper.beforeTransformPlugins.register(<span class="string">'xxx'</span>, &#123;</span><br><span class="line">  handle (ctx) &#123; <span class="comment">// 调用插件的 handle 方法时也会传入 ctx 方便调用api</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.output)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也就是在这个时候，<code>ctx.helper.beforeTransformPlugins.register</code>这个方法被调用。</p><p>于是乎，在生命周期开始之前，整个插件以及每个生命周期的插件已经预先被注册了。所以在生命周期开始运作的时候，只需要通过<code>getList()</code>就可以获取注册过的插件，从而执行整个流程了。</p><p>也因此，我以前在跑<code>Hexo</code>生成博客的时候曾经遇到的问题就得到解释了。我以前安装过一些<code>Hexo</code>的插件，但是不知道为什么总是无法生效。后来发现是安装的时候没有使用<code>--save</code>，导致它们没被写入<code>package.json</code>的依赖字段。而<code>Hexo</code>加载插件的第一步就是从<code>package.json</code>里获取合法的插件列表，如果插件不在<code>package.json</code>里，哪怕在<code>node_modules</code>里有，也不会生效了。</p><p>有了插件，接下去我们讲讲如何在命令行调用和配置了。</p><h3 id="命令行操作类"><a href="#命令行操作类" class="headerlink" title="命令行操作类"></a>命令行操作类</h3><p>PicGo的命令行操作类主要依赖于两个库：<a href="https://github.com/tj/commander.js/" target="_blank" rel="noopener">commander.js</a>和<a href="https://github.com/SBoudrias/Inquirer.js/" target="_blank" rel="noopener">Inquirer.js</a>。这两个也是做Node.js命令行应用很常用的库了。前者负责命令行解析、执行相关命令。后者负责提供与用户交互的命令行界面。</p><p>比如你可以输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picgo use uploader</span><br></pre></td></tr></table></figure><p>这个时候由<code>commander.js</code>去解析这句命令，告诉我们这个时候调用的是<code>use</code>这个命令，参数是<code>uploader</code>，那么就进入<code>Inquirer.js</code>提供的交互式界面了：</p><p><img src="https://i.loli.net/2019/01/31/5c529491e27e4.png" alt="Inquirer.js"></p><p>如果你用过诸如<code>vue-cli3</code>或者<code>create-react-app</code>等类似的命令行工具一定类似的情况很熟悉。</p><p>首先我们写一个命令行操作类，用于暴露api给其他部分注册命令，此处源码可以参考<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/lib/Commander.ts" target="_blank" rel="noopener">Commander.ts</a>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PicGo <span class="keyword">from</span> <span class="string">'../core/PicGo'</span></span><br><span class="line"><span class="keyword">import</span> program <span class="keyword">from</span> <span class="string">'commander'</span></span><br><span class="line"><span class="keyword">import</span> inquirer <span class="keyword">from</span> <span class="string">'inquirer'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Plugin &#125; <span class="keyword">from</span> <span class="string">'../utils/interfaces'</span></span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'../../package.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Commander &#123;</span><br><span class="line">  list: &#123;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: Plugin</span><br><span class="line">  &#125;</span><br><span class="line">  program: <span class="keyword">typeof</span> program</span><br><span class="line">  inquirer: <span class="keyword">typeof</span> inquirer</span><br><span class="line">  <span class="keyword">private</span> ctx: PicGo</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">ctx: PicGo</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.program = program</span><br><span class="line">    <span class="keyword">this</span>.inquirer = inquirer</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Commander</span><br></pre></td></tr></table></figure><p>然后我们在PicGo-Core的核心类里将其实例化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Commander <span class="keyword">from</span> <span class="string">'../lib/Commander'</span></span><br><span class="line"><span class="keyword">class</span> PicGo <span class="keyword">extends</span> EventEmitter &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  cmd: Commander</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">configPath: <span class="built_in">string</span> = ''</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.cmd = <span class="keyword">new</span> Commander(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这样其他部分就可以使用<code>ctx.cmd.program</code>来调用<code>commander.js</code>以及使用<code>ctx.cmd.inquirer</code>来调用<code>Inquirer.js</code>了。</p><p>这两个库的使用，网络上有很多教程了。此处简单举个例子，我们从PicGo最基本的功能——命令行上传图片开始说起。</p><h4 id="命令的注册"><a href="#命令的注册" class="headerlink" title="命令的注册"></a>命令的注册</h4><p>为了与之前的插件结构统一，我们把命令注册也写到<code>handle</code>函数里。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PicGo <span class="keyword">from</span> <span class="string">'../../core/PicGo'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  handle: (ctx: PicGo): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cmd = ctx.cmd</span><br><span class="line">    cmd.program <span class="comment">// 此处是一个commander.js实例</span></span><br><span class="line">      .command(<span class="string">'upload'</span>) <span class="comment">// 注册命令 upload</span></span><br><span class="line">      .description(<span class="string">'upload, go go go'</span>) <span class="comment">// 命令的描述</span></span><br><span class="line">      .arguments(<span class="string">'[input...]'</span>) <span class="comment">// 命令的参数</span></span><br><span class="line">      .alias(<span class="string">'u'</span>) <span class="comment">// 命令的别名 u</span></span><br><span class="line">      .action(<span class="keyword">async</span> (input: <span class="built_in">string</span>[]) =&gt; &#123; <span class="comment">// 命令执行的函数</span></span><br><span class="line">        <span class="keyword">const</span> inputList = input <span class="comment">// 获取输入的input</span></span><br><span class="line">            .map(<span class="function">(<span class="params">item: <span class="built_in">string</span></span>) =&gt;</span> path.resolve(item))</span><br><span class="line">            .filter(<span class="function">(<span class="params">item: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> exist = fs.existsSync(item) <span class="comment">// 判断输入的地址存不存在</span></span><br><span class="line">              <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">                ctx.log.warn(<span class="string">`<span class="subst">$&#123;item&#125;</span> is not existed.`</span>) <span class="comment">// 如果不存在就返回警告信息</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> exist</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">await</span> ctx.upload(inputList) <span class="comment">// 上传图片（调用生命周期的start函数）</span></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们如果通过某种方式把命令注册进去：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PicGo <span class="keyword">from</span> <span class="string">'../../core/PicGo'</span></span><br><span class="line"><span class="keyword">import</span> upload <span class="keyword">from</span> <span class="string">'./upload'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (ctx: PicGo): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.cmd.register(<span class="string">'upload'</span>, upload) <span class="comment">// 此处的注册逻辑跟lifecyclePlugins一致。</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当代码写到这里，可能大家觉得已经大功告成了。实际上还差了最后一步，我们缺少一个入口来接纳我们输入的命令。就比如现在我们写完了命令，也写完了命令的注册，然后我们要怎么在命令行里使用呢？</p><h4 id="命令行的使用"><a href="#命令行的使用" class="headerlink" title="命令行的使用"></a>命令行的使用</h4><p>这个时候要简单说下<code>package.json</code>里的两个字段<code>bin</code>和<code>main</code>。其中<code>main</code>字段指向的文件，是你<code>const xxx = require(&#39;xxx&#39;)</code>的时候拿到的东西。而<code>bin</code>字段指向的文件，就是你在全局安装了之后，可以在命令行里直接输入的命令。</p><p>举个例子，PicGo-Core的<code>bin</code>字段如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">"bin": &#123;</span><br><span class="line">  "picgo": "./bin/picgo"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>那么用户如果全局安装了picgo，就可以通过<code>picgo</code>这个命令来使用picgo了。类似安装<code>@vue/cli</code>之后，可以使用<code>vue</code>这个命令一样。</p><p>那么我们来看看<code>./bin/picgo</code>做了啥。源码在<a href="https://github.com/PicGo/PicGo-Core/blob/dev/bin/picgo" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> minimist = <span class="built_in">require</span>(<span class="string">'minimist'</span>)</span><br><span class="line"><span class="keyword">let</span> argv = minimist(process.argv.slice(<span class="number">2</span>)) <span class="comment">// 解析命令行</span></span><br><span class="line"><span class="keyword">let</span> configPath = argv.c || argv.config || <span class="string">''</span> <span class="comment">// 查看是否提供了configPath</span></span><br><span class="line"><span class="keyword">if</span> (configPath !== <span class="literal">true</span> &amp;&amp; configPath !== <span class="string">''</span>) &#123;</span><br><span class="line">  configPath = path.resolve(configPath)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  configPath = <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> PicGo = <span class="built_in">require</span>(<span class="string">'../dist/index'</span>)</span><br><span class="line"><span class="keyword">const</span> picgo = <span class="keyword">new</span> PicGo(configPath) <span class="comment">// 实例化picgo</span></span><br><span class="line">picgo.registerCommands() <span class="comment">// 注册命令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  picgo.cmd.program.parse(process.argv) <span class="comment">// 调用commander.js解析命令</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  picgo.log.error(e)</span><br><span class="line">  <span class="keyword">if</span> (process.argv.includes(<span class="string">'--debug'</span>)) &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分就在<code>picgo.cmd.program.parse(process.argv)</code>这句话，这句话调用了<code>commander.js</code>来解析<code>process.argv</code>，也就是命令行里命令以及参数。</p><p>那么我们在开发阶段就可以用<code>./bin/picgo upload</code>这样来调用命令，而在生产环境下，也就是用户全局安装后，就可以通过<code>picgo upload</code>这样来调用命令了。</p><h4 id="配置项的处理"><a href="#配置项的处理" class="headerlink" title="配置项的处理"></a>配置项的处理</h4><p>前文提到了，配置项是插件系统里很重要的一个组成部分。不同插件系统的配置项处理不太一样。比如<code>Hexo</code>提供了<code>_config.yml</code>供用户配置，<code>vue-cli3</code>提供了<code>vue.config.js</code>供用户配置。PicGo也提供了<code>config.json</code>供用户配置，不过在此基础上，我想提供一个更方便的方式来让用户直接在命令行里完成配置，而不需要专门打开这个配置文件。</p><p>比如我们可以通过命令行来选择当前上传的图床是什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ picgo use</span><br><span class="line">? Use an uploader (Use arrow keys)</span><br><span class="line">  smms</span><br><span class="line">❯ tcyun</span><br><span class="line">  weibo</span><br><span class="line">  github</span><br><span class="line">  qiniu</span><br><span class="line">  imgur</span><br><span class="line">  aliyun</span><br><span class="line">(Move up and down to reveal more choices)</span><br></pre></td></tr></table></figure><p>这种在命令行里的交互，需要之前提到的<code>Inquirer.js</code>来辅助我们达到这个效果。</p><p>它的用法也很简单，传入一个<code>prompts</code>（可以理解为一个问题数组），然后它会将问题的结果再以对象的形式返回出来，我们通常将这个结果记为<code>answer</code>。</p><p>而PicGo为了简化这个过程，只需要插件提供一个<code>config</code>方法，这个方法只需返回一个合法的<code>prompts</code>问题数组，然后PicGo会自动调用<code>Inquirer.js</code>去执行它，并自动将结果写入配置文件里。</p><p>举个例子，PicGo内置的<code>Imgur</code>图床的<code>config</code>代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = (ctx: PicGo): PluginConfig[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> userConfig = ctx.getConfig(<span class="string">'picBed.imgur'</span>)</span><br><span class="line">  <span class="keyword">if</span> (!userConfig) &#123;</span><br><span class="line">    userConfig = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> config = [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'clientId'</span>,</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">'input'</span>,</span><br><span class="line">      <span class="keyword">default</span>: userConfig.clientId || <span class="string">''</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'proxy'</span>,</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">'input'</span>,</span><br><span class="line">      <span class="keyword">default</span>: userConfig.proxy || <span class="string">''</span>,</span><br><span class="line">      required: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">return</span> config <span class="comment">// 这个config就是一个合法的prompts数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们用代码实现能够在命令行里调用它，源码<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/plugins/commander/setting.ts" target="_blank" rel="noopener">传送门</a>：</p><blockquote><p>以下代码有所精简</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PicGo <span class="keyword">from</span> <span class="string">'../../core/PicGo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; PluginConfig &#125; <span class="keyword">from</span> <span class="string">'../../utils/interfaces'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理uploader的config数组，然后写入配置文件</span></span><br><span class="line"><span class="keyword">const</span> handleConfig = <span class="keyword">async</span> (ctx: PicGo, prompts: PluginConfig, name: <span class="built_in">string</span>): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="keyword">await</span> ctx.cmd.inquirer.prompt(prompts)</span><br><span class="line">  <span class="keyword">let</span> configName = <span class="string">`picBed.<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  ctx.saveConfig(&#123;</span><br><span class="line">    [configName]: answer</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  handle: (ctx: PicGo): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cmd: <span class="keyword">typeof</span> ctx.cmd = ctx.cmd</span><br><span class="line">    cmd.program</span><br><span class="line">      .command(<span class="string">'set'</span>) <span class="comment">// 注册一个set命令</span></span><br><span class="line">      .alias(<span class="string">'config'</span>) <span class="comment">// 别名 config</span></span><br><span class="line">      .description(<span class="string">'configure config of picgo'</span>)</span><br><span class="line">      .action(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> prompts = [ <span class="comment">// prompts问题数组</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">type</span>: <span class="string">'list'</span>,</span><br><span class="line">              name: <span class="string">'uploader'</span>,</span><br><span class="line">              choices: ctx.helper.uploader.getIdList(), <span class="comment">// 获取Uploader列表</span></span><br><span class="line">              message: <span class="string">`Choose a(n) uploader`</span>,</span><br><span class="line">              <span class="keyword">default</span>: ctx.config.picBed.uploader || ctx.config.picBed.current</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">          <span class="keyword">let</span> answer = <span class="keyword">await</span> ctx.cmd.inquirer.prompt(prompts) <span class="comment">// 等待inquirer处理用户的输入</span></span><br><span class="line">          <span class="keyword">const</span> item = ctx.helper.uploader.get(answer.uploader) <span class="comment">// 获取用户选择的uploader</span></span><br><span class="line">          <span class="keyword">if</span> (item.config) &#123; <span class="comment">// 如果uploader提供了config方法</span></span><br><span class="line">            <span class="keyword">await</span> handleConfig(ctx, item.config(ctx), answer.uploader) <span class="comment">//处理该config方法暴露出的prompts数组</span></span><br><span class="line">          &#125;</span><br><span class="line">          ctx.log.success(<span class="string">'Configure config successfully!'</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          ctx.log.error(e)</span><br><span class="line">          <span class="keyword">if</span> (process.argv.includes(<span class="string">'--debug'</span>)) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是针对Uploader的config方法进行的配置处理，对于其他插件也是同理的，就不再赘述。这样我们就实现了能够通过命令行快速对配置文件进行配置，用户体验又是++。</p><h2 id="插件系统发布"><a href="#插件系统发布" class="headerlink" title="插件系统发布"></a>插件系统发布</h2><p>讲了那么多，我们都是在本地书写的插件系统，如何发布让别人能够安装使用呢？关于往npm发布模块有很多相关文章，比如参考这篇<a href="https://fenying.net/2017/12/02/publish-to-npm/" target="_blank" rel="noopener">文章</a>。我在这里想讲的是如何发布一个既能在命令行使用，又可以通过比如<code>const picgo = require(&#39;picgo&#39;)</code>在Node.js项目里使用API调用的库。</p><h3 id="CLI与API调用并存"><a href="#CLI与API调用并存" class="headerlink" title="CLI与API调用并存"></a>CLI与API调用并存</h3><p>其实这个上面的部分里也提到了。我们在发布一个npm库的时候通常是在<code>package.json</code>里的<code>main</code>字段指定这个库的入口文件。那么这样使用者就可以通过比如<code>const picgo = require(&#39;picgo&#39;)</code>在Node.js项目里使用。</p><p>如果我们想要让这个库安装之后能够注册一个命令，那么我们可以在<code>bin</code>字段里指定这个命令已经对应的入口文件。比如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">"bin": &#123;</span><br><span class="line">  "picgo": "./bin/picgo"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样我们在全局安装之后就会在系统里注册一个叫做<code>picgo</code>的命令了。</p><p>当然这个时候<code>bin</code>和<code>main</code>的入口文件通常是不一样的。<code>bin</code>的入口文件需要做好解析命令行的功能。所以通常我们会使用一些命令行解析的库例如<code>minimist</code>或者<code>commander.js</code>等等来解析命令行里的参数。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，一个CLI插件系统的关键部分我们就基本实现了。那么我们在Electron项目里，可以在<code>main</code>进程里使用我们所写的插件系统，并通过这个插件暴露的API来打造应用的插件系统了。下一篇文章会详细讲述如何把CLI插件系统整合进Electron，实现GUI插件系统，并加入一些额外的机制，使得在GUI上的插件系统更加灵活而强大。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>和<a href="https://github.com/PicGo/PicGo-Core" target="_blank" rel="noopener">PicGo-Core</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及<a href="https://molunerfinn.com/tags/Electron-vue/">本系列文章</a>的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>感谢这些高质量的文章：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/38730825" target="_blank" rel="noopener">用Node.js开发一个Command Line Interface (CLI)</a></li><li><a href="https://zhuanlan.zhihu.com/p/26895282" target="_blank" rel="noopener">Node.js编写CLI的实践</a></li><li><a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism" target="_blank" rel="noopener">Node.js模块机制</a></li><li><a href="https://onetwo.ren/%E5%89%8D%E7%AB%AF%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">前端插件系统设计与实现</a></li><li><a href="https://blog.csdn.net/kyfxbl/article/details/47787827" target="_blank" rel="noopener">Hexo插件机制分析</a></li><li><a href="http://blog.yunplus.io/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95/" target="_blank" rel="noopener">如何实现一个简单的插件扩展</a></li><li><a href="https://fenying.net/2017/12/02/publish-to-npm/" target="_blank" rel="noopener">使用NPM发布与维护TypeScript模块</a></li><li><a href="https://github.com/basarat/ts-npm-module" target="_blank" rel="noopener">typescript npm 包例子</a></li><li><a href="https://docs.travis-ci.com/user/deployment/npm/" target="_blank" rel="noopener">通过travis-ci发布npm包</a></li><li><a href="https://discuss.atom.io/t/dynamically-load-module-in-plugin-from-local-project-node-modules-folder/42930/2" target="_blank" rel="noopener">Dynamic load module in plugin from local project node_modules folder</a></li><li><a href="https://aotu.io/notes/2016/08/09/command-line-development/index.html" target="_blank" rel="noopener">跟着老司机玩转Node命令行</a></li><li>以及没来得及记录的那些好文章，感谢你们！</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;祝大家2019年猪年新年快乐！本文较长，需要一定耐心看完哦~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持主流三大桌面操作系统）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;系列文章&lt;/a&gt;或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-5/&quot;&gt;通过CI发布以及更新的方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-6/&quot;&gt;开发插件系统——CLI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-7/&quot;&gt;开发插件系统——GUI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;想到再写…&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;之前的文章&lt;/a&gt;跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>2018小结</title>
    <link href="https://molunerfinn.com/2018-summary/"/>
    <id>https://molunerfinn.com/2018-summary/</id>
    <published>2019-01-18T09:22:00.000Z</published>
    <updated>2019-03-17T14:42:12.470Z</updated>
    
    <content type="html"><![CDATA[<p>终于把研究生开题的事情弄得差不多了，可以抽空写一下2018年的小结了。</p><a id="more"></a><p>今年和去年一样，也是格外忙。不仅实验室活多，还要兼顾研究生的开题等。跟去年一样，列一个今年学习成果清单：</p><h1 id="过去的一年"><a href="#过去的一年" class="headerlink" title="过去的一年"></a>过去的一年</h1><h2 id="技术成果"><a href="#技术成果" class="headerlink" title="技术成果"></a>技术成果</h2><ul><li><p><strong>2019.01.13</strong>（插播） <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> 发布v2.0版本，正式支持插件系统。star数破3200，下载量破26k。【Electron】</p></li><li><p><strong>2018.08.28</strong> <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> star数破2000，下载量破12k。【Electron】</p></li><li><p><strong>2018.07.19</strong> <a href="https://github.com/Molunerfinn/PicGo-Core" target="_blank" rel="noopener">PicGo-Core</a> 开坑PicGo底层流程系统，将支持插件系统【Node+TypeScript】</p></li><li><p><strong>2018.07.11</strong> <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> 更新v1.6版本，支持阿里云OSS，imgur，mini窗口，批量删除等功能。【Electron】</p></li><li><p><strong>2018.05.23</strong> 为VSCode的<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank" rel="noopener">amVim-for-VSCode</a>插件提交的支持<code>:</code>呼出<code>Command Palette</code>并实现部分Vim命令的<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/199" target="_blank" rel="noopener">PR</a>被合并。【TypeScript】</p></li><li><p><strong>2018.05.17</strong> <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> star数破800，下载数破5k。【Electron】</p></li><li><p><strong>2018.05.15</strong> 开发推来推趣3期后台时遇到微信二维码支付相关功能的开发，总结了一篇<a href="https://molunerfinn.com/koa2-wechatpay/">《基于Koa2开发微信二维码扫码支付相关流程》</a>的经验文。【Koa】</p></li><li><p><strong>2018.05.09</strong> <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> 更新v1.5版本，支持腾讯云COSv5、GitHub图床、重命名等新功能。【Electron】</p></li><li><p><strong>2018.03.28</strong> <a href="https://github.com/Molunerfinn/node-github-profile-summary" target="_blank" rel="noopener">node-github-profile-summary</a>和<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>的Docker话。【Docker】</p></li><li><p><strong>2018.03.10~2018.05.31</strong> 推来推趣3期后台（全栈）迭代。【Vue+Koa+Graphql】</p></li><li><p><strong>2018.03.06</strong> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a> 更新v1.5版本，支持iframe、支持slides等特性。【hexo+hexo-theme】</p></li><li><p><strong>2018.01.17~2018.03.28</strong> 开坑<a href="https://github.com/Molunerfinn/node-github-profile-summary" target="_blank" rel="noopener">node-github-profile-summary</a>，可以生成漂亮的GitHub总结报告。【Vue+Koa+Chart.js+Graphql】</p></li><li><p><strong>2018.01.11~2018.05.08</strong> 写了<a href="https://molunerfinn.com/tags/Electron-vue/">Electron-vue开发实战系列教程</a>，用于记录自己开发PicGo的坑以及帮助新人入门Electron开发。【Electron】</p></li></ul><p>对比去年给自己立的目标：</p><ul><li>算法、数据结构 【一部分】</li><li>Parcel 【没有】</li><li>TypeScript 【用上了】</li><li>Puppeteer自动化测试 【没有】</li><li>PWA 【有新的体验】</li><li>给开源库提PR 【完成】</li><li>github robot 【没有】</li><li>如果可以，学习一下react 【碰了皮毛】</li></ul><p>感觉完成度不够高，不及去年同期对2016年的目标的实现。主要是没有预料到下半年研究生的开题的战线耗时这么久。从2018年8月开始我就没有发过笔记或者技术文章了，真的非常惭愧。</p><h1 id="期望、目标"><a href="#期望、目标" class="headerlink" title="期望、目标"></a>期望、目标</h1><p>依然要写下2019年需要学习的东西：</p><ul><li>算法、数据结构</li><li>Flutter入门</li><li>PWA</li><li>学习react</li><li>Puppeteer使用</li></ul><p>感觉把目标缩小点应该完成度会更高。毕竟19年要开始找实习和正式工作+写研究生毕设了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这一年来的前端的学习之路，收获还是不少的。比起2017年来说，我感觉最大的收获就是阅读源码的能力提高了。虽然不是什么高深的源码，不过相比之前对阅读源码有恐惧心理的自己，还是好了不少。</p><p>5月份的时候，那段时间我的Mac上的VSCode的Vim插件变得异常卡，可以参考这个<a href="https://github.com/VSCodeVim/Vim/issues/2021" target="_blank" rel="noopener">issue</a>。无奈之下只能把官方的Vim插件替换掉，换成了<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank" rel="noopener">amVim-for-VSCode</a>，当初刚换上的时候，操作如丝般顺滑！不过当时发现它不支持<code>:</code>带来的一系列操作，比如<code>:w</code>保存，<code>:q</code>退出等。于是我萌生了一个想法，能不能把VSCodeVim的操作移植到amVim上？在阅读了VSCodeVim的源码之后，我也模仿了它的实现，把一部分常用的命令移植到了amVim上，并最终成功被作者<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/199" target="_blank" rel="noopener">合并</a>。</p><p>这次提交PR的过程，我也发了一篇<a href="https://molunerfinn.com/vscode-extension-develop-1/">文章</a>作为记录。应该说这次经历过后我对阅读源码的恐惧感减轻了不少，这也为之后的<a href="https://github.com/PicGo/PicGo-Core" target="_blank" rel="noopener">PicGo-Core</a>的开发带来很大的帮助。</p><p>8月份之后很长的一段时间里，除了在做研究生开题相关的东西，我基本就是在开发<a href="https://github.com/PicGo/PicGo-Core" target="_blank" rel="noopener">PicGo-Core</a>了。如果你有用过<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，那么你应该知道它的1.x版本是不支持插件系统的。而且内置的只有有限的8个图床。（如果你不知道<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，欢迎使用，对你的文章写作有很大帮助~）。<code>PicGo</code>里我收到最多的issue，应该就是<code>能否支持XXX图床</code>。如果是一开始写PicGo的时候，我一般会在下一个版本里更新新的图床支持。但是支持到第8个的时候我发现这样无限地支持下去不是一个办法。正巧有个用户提出一个<a href="https://github.com/Molunerfinn/PicGo/issues/26#issuecomment-370105520" target="_blank" rel="noopener">想法</a>：能否将对各种图床的支持，做成插件化的管理，类似 Core + Plugins 这样的模式。</p><p>我为此思考了好久，发现这样是可行而且非常合理的。于是我开始找相关的资料——我一开始的想法只是在Electron内部实现一个插件系统。为此我去找了不少例子，比如VSCode、Kap、Atom、Hyper等用Electron写的工具，想看看他们的插件系统是如何实现的。发现他们的实现相对比较复杂。对我来说我是想要实现一个底层的上传流程系统。</p><p>后来我想到了Hexo也是有插件系统的，于是就去阅读了Hexo的插件系统如何实现。在看Hexo插件系统实现的同时，我还发现了另外一个工具<a href="https://segmentfault.com/a/1190000013362598" target="_blank" rel="noopener">feflow的插件系统实现</a>。不过我后来发现，feflow的插件体系其实底层大部分是「抄」的hexo的源码的，尤其一个很经典的例子…</p><p><img src="https://i.loli.net/2019/01/18/5c4135bf942d9.png" alt="20190118101110.png"></p><p>于是我就把feflow的文章当做hexo插件系统实现的解析文章了哈哈。</p><p>在充分理解了hexo插件如何实现了之后，我也开始着手我自己的<a href="https://github.com/PicGo/PicGo-Core" target="_blank" rel="noopener">PicGo-Core</a>了。当然我并没有完全照搬hexo的实现，因为我发现那样的话不利于插件开发者开发插件（主要是语法提示），hexo的插件机制是暴露全局的<code>hexo</code>变量去实现的。</p><p><code>PicGo-Core</code>的流程大概如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-core-fix.jpg" alt="flow"></p><p>输入路径或者变量等-&gt;经过转换器转换-&gt;上传器上传-&gt;输出结果。中间包含着三个生命周期钩子。这样的话用户开发插件可以只实现其中的某个部分，也可以实现其中的某几个部分，来实现<code>PicGo</code>原先不能实现的一些功能：</p><ol><li>比如上传非图片文件</li><li>比如上传图片前压缩、加水印</li><li>比如通过已知URL上传图片</li></ol><p>等等。</p><p>我也正式使用了<code>TypeScript</code>作为<code>PicGo-Core</code>的开发语言，使用起来一开始确实很不习惯，但是后来越用越顺手，学习新东西的过程大概都是这样吧！</p><p>在开发<code>PicGo-Core</code>的过程中，我也做了很多除了上面流程系统之外的工作。比如：</p><ol><li>要让用户在命令行和Node里都能使用，我为此基于<a href="https://github.com/tj/commander.js/" target="_blank" rel="noopener">commander.js</a>和<a href="https://github.com/SBoudrias/Inquirer.js/" target="_blank" rel="noopener">Inquirer.js</a>给<code>PicGo-Core</code>加上了命令行支持，同样插件也能支持注册命令等操作。</li><li>为了方便其他开发者开发插件，首先我得写好一个插件模板<a href="https://github.com/PicGo/picgo-template-plugin" target="_blank" rel="noopener">picgo-template-plugin</a>，并学习了<code>vue-cli2</code>和<code>vue-cli3</code>对于模板生成的实现，写了一个下载模板、生成模板的命令<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/plugins/commander/init.ts" target="_blank" rel="noopener">init</a>，好让插件开发者能够快速创建插件模板进行插件开发。</li><li>为了让使用者方便下载使用插件，我写了一个<a href="https://github.com/PicGo/PicGo-Core/blob/dev/src/lib/PluginHandler.ts" target="_blank" rel="noopener">PluginHandler</a>用于调用<code>npm</code>命令来下载插件。</li><li>除了写代码，还得写文档，没有文档怎么能有其他开发者为你开发插件呢？所以还花了很大的精力写了<code>PicGo-Core</code>的<a href="https://picgo.github.io/PicGo-Core-Doc/zh/" target="_blank" rel="noopener">文档</a>，配图、示例一应俱全。</li></ol><p>开发完Node版本的<code>PicGo-Core</code>之后，我还要将它和Electron版本的<code>PicGo</code>整合起来，使得Electron版本的<code>PicGo</code>也能拥有插件系统。并且还得通过<code>ipcMain</code>等方式，将主进程的信息通知给渲染进程，从而渲染出插件页面里的插件列表：</p><p><img src="https://user-images.githubusercontent.com/12621342/50515434-bc9e8180-0adf-11e9-8c71-0e39973c06b1.png" alt></p><p>为了让插件开发者能够更好地利用GUI版本的优势，我还为GUI版本的PicGo插件加了GUI插件特有的<code>guiApi</code>、<code>guiMenu</code>等功能：</p><p><img src="https://i.loli.net/2019/01/12/5c39a2f60a32a.png" alt></p><p>这样插件拥有自己的菜单，可以执行自己的操作，那么能做的事就更多了，比如：</p><ol><li>结合GitHub刚刚开放的免费私人仓库，可以通过插件实现PicGo的相册以及配置文件同步。</li><li>结合TinyPng等工具实现上传前给图片瘦身。（不过可能挺影响上传速度的。）</li><li>结合一些Canvas工具，可以在上传图片前给图片加水印。</li><li>通过指定文件夹，将文件夹内部的markdown里的图片地址进行图床迁移。</li></ol><p>等等。。</p><p>终于，在2019年1月13号，PicGo迎来了2.0版本的<a href="https://github.com/Molunerfinn/PicGo/releases/" target="_blank" rel="noopener">更新</a>。</p><p>回顾这些工作，都是我一个人在半年的时间里通过课余的时间做出来的，其实还是很自豪的。更关键的是，通过开放了插件系统，可以让更多的人参与到PicGo软件的完善中来，通过插件可以实现很多本体不提供或者不足的功能，也是让PicGo更加强大的一个条件。我也希望它日后也能形成自己的一个小生态。</p><p>实际上，PicGo-Core以及PicGo2.0发布之后，就已经有第三方开发者开发插件了，速度之快让我始料未及。为此我也迅速加上了<a href="https://github.com/PicGo/Awesome-PicGo" target="_blank" rel="noopener">Awesome-PicGo</a>的仓库，这样能让更多的开发者的作品让用户看到：</p><p><img src="https://i.loli.net/2019/01/18/5c413c6300681.png" alt="20190118103930.png"></p><p>你已经可以在VSCode里搜索PicGo，就能发现VSCode版的PicGo扩展了，实现了三种在Markdown里快速上传图片的方式：</p><ul><li>通过截图上传</li></ul><p><img src="https://camo.githubusercontent.com/e7898449cadc72bb7045319e4195a5210fef60cf/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f31362f356333656430333335373761302e676966" alt></p><ul><li>通过文件浏览器上传</li></ul><p><img src="https://camo.githubusercontent.com/955c32665b55b1ac85ec9696cc51fddcb740076d/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f31362f356333656433366430643964332e676966" alt></p><ul><li>通过输入文件路径上传</li></ul><p><img src="https://camo.githubusercontent.com/f2cb528b4fcca4e64f6e6bf80d1e25ea47b85483/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f31362f356333656432333836623761632e676966" alt></p><p>2019年，我会更新几篇文章，主要讲讲如何实现一个插件系统，如何将Node端实现的插件系统整合到Electron端，如何实现一个模板下载、生成功能，如何实现良好的命令行交互等等。</p><p>2019年也是我找实习、找正式工作的一年，希望今年一切都顺利吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于把研究生开题的事情弄得差不多了，可以抽空写一下2018年的小结了。&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="随笔" scheme="https://molunerfinn.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>图床「神器」PicGo v2.0更新，插件系统终于来了</title>
    <link href="https://molunerfinn.com/picgo-v2.0-update/"/>
    <id>https://molunerfinn.com/picgo-v2.0-update/</id>
    <published>2019-01-13T11:30:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离上次更新(v1.6.2)已经过去了5个月，很抱歉2.0版本来得这么晚。本来想着在18年12月（PicGo一周年的时候）发布2.0版本，但是无奈正值研究生开题期间，需要花费不少时间（不然毕不了业了T T），所以这个大版本姗姗来迟。不过从这个版本开始，正式支持插件系统，发挥你们的无限想象，PicGo也能成为一个极致的效率工具。</p><p>除了发布PicGo 2.0<a href="https://github.com/Molunerfinn/PicGo/releases/" target="_blank" rel="noopener">本体</a>，一同发布的还有<a href="https://picgo.github.io/PicGo-Core-Doc/" target="_blank" rel="noopener">PicGo-Core</a>（PicGo 2.0的底层，支持CLI和API调用），以及VSCode的PicGo插件<a href="https://github.com/Spades-S/vs-picgo" target="_blank" rel="noopener">vs-picgo</a>等。</p><a id="more"></a><h3 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h3><p>PicGo的底层核心其实是<code>PicGo-Core</code>。这个核心主要就是一个流程系统。(它支持在Node.js环境下全局安装，可以通过命令行上传图片文件、也可以接入Node.js项目中调用api实现上传。)</p><p><code>PicGo-Core</code>的上传流程如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-core-fix.jpg" alt></p><p><code>Input</code>一般是文件路径，经过<code>Transformer</code>读取信息，传入<code>Uploader</code>进行上传，最后通过 <code>Output</code> 输出结果。而插件可以接入三个生命周期（<code>beforeTransform</code>、<code>beforeUpload</code>、<code>afterUpload</code>）以及两种部件（<code>Transformer</code>和<code>Uploader</code>）。</p><p>换句话说，如果你书写了合适的<code>Uploader</code>，那么可以上传到不同的图床。如果你书写了合适的<code>Transformer</code>，你可以通过URL先行下载文件再通过<code>Uploader</code>上传等等。</p><p>另外，如果你不想下载PicGo的electron版本，也可以通过npm安装picgo来实现命令行一键上传图片的快速体验。</p><p>PicGo除了<code>PicGo-Core</code>提供的核心功能之外，额外给GUI插件给予一些自主控制权。</p><p>比如插件可以拥有自己的菜单项：</p><p><img src="https://i.loli.net/2019/01/12/5c39a2f60a32a.png" alt></p><p>因此GUI插件除了能够接管<code>PicGo-Core</code>给予的上传流程，还可以通过PicGo提供的guiApi等接口，在插件页面实现一些以前单纯通过<code>上传区</code>实现不了的功能：</p><p>比如可以通过打开一个<code>InputBox</code>获取用户的输入：</p><p><img src="https://i.loli.net/2019/01/12/5c39aa4dab0b4.png" alt></p><p>可以通过打开一个路径来执行其他功能（而非只是上传文件）：</p><p><img src="https://i.loli.net/2019/01/12/5c39aea61e80d.gif" alt></p><p>甚至还可以直接在插件面板通过调用api实现上传。</p><p>另外插件可以监听相册里图片删除的事件：</p><p><img src="https://i.loli.net/2019/01/12/5c39b3c8746cf.png" alt></p><p>这个功能就可以写一个插件来实现相册图片和远端存储里的同步删除了。</p><p>通过如上介绍，我现在甚至就已经能想到插件系统能做出哪些有意思的插件了。</p><p>比如：</p><ol><li>结合GitHub刚刚开放的免费私人仓库，可以通过插件实现PicGo的相册以及配置文件同步。</li><li>结合TinyPng等工具实现上传前给图片瘦身。（不过可能挺影响上传速度的。）</li><li>结合一些Canvas工具，可以在上传图片前给图片加水印。</li><li>通过指定文件夹，将文件夹内部的markdown里的图片地址进行图床迁移。</li><li>等等。。</li></ol><p>希望这个插件系统能够给PicGo带来更强大的威力，也希望它能够成为你的极致的效率工具。</p><p><strong>需要注意的是，想要使用PicGo 2.0的插件系统，需要先行安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>环境，因为PicGo的插件安装依赖<code>npm</code>。</strong></p><h2 id="2-0其他更新内容"><a href="#2-0其他更新内容" class="headerlink" title="2.0其他更新内容"></a>2.0其他更新内容</h2><p>除了上面说的插件系统，PicGo 2.0还更新了如下内容：</p><ul><li>底层重构了之后，某些图床上传不通过<code>base64</code>值的将会提升不少速度。比如<code>SM.MS</code>图床等。而原本就通过<code>base64</code>上传的图床速度不变。</li><li>增加一些配置项，比如打开配置文件（包括了上传的图片列表）、mini窗口置顶、代理设置等。<br><img src="https://user-images.githubusercontent.com/12621342/50515474-ea83c600-0adf-11e9-8022-52f4ab9e0ea5.png" alt="image"></li><li>在相册页可以选择复制的链接格式，不用再跑去上传页改了。<br><img src="https://user-images.githubusercontent.com/12621342/50515502-17d07400-0ae0-11e9-80b9-c38f25b64922.png" alt="image"></li><li>增加不同页面切换的淡入淡出动画。</li><li>macOS版本配色小幅更新。（Windows版本配色更新Fluent Design效果预计在2.1版本上线）</li><li>更新electron版本从1.8-&gt;4.0，启动速度更快了，性能也更好了。</li></ul><h2 id="Bug-Fixed"><a href="#Bug-Fixed" class="headerlink" title="Bug Fixed"></a>Bug Fixed</h2><ul><li>修复：macOS多屏下打开详细窗口时位置错误的<a href="https://github.com/Molunerfinn/PicGo/issues/128" target="_blank" rel="noopener">问题</a>。</li><li>修复：多图片上传重命名一致的<a href="https://github.com/Molunerfinn/PicGo/issues/136" target="_blank" rel="noopener">问题</a>。</li><li>修复：拖拽图片到软件会自动在软件内部打开这张图片的<a href="https://github.com/Molunerfinn/PicGo/issues/140" target="_blank" rel="noopener">bug</a>。</li><li>修复：重命名窗口只出现在屏幕中央而不是跟随主窗口的<a href="https://github.com/Molunerfinn/PicGo/issues/145" target="_blank" rel="noopener">bug</a>。</li></ul><h2 id="VSCode的PicGo插件vs-picgo"><a href="#VSCode的PicGo插件vs-picgo" class="headerlink" title="VSCode的PicGo插件vs-picgo"></a>VSCode的PicGo插件vs-picgo</h2><p>在PicGo-Core发布不久，就有人根据PicGo-Core的API编写了VSCode版的PicGo插件。使用起来也非常方便：</p><ul><li>截图上传</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/13/1684764986e5edd7?w=891&amp;h=498&amp;f=gif&amp;s=297594" alt></p><ul><li>文件浏览器选择文件上传</li></ul><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/vs-picgo-explorer.gif" alt></p><ul><li>输入文件路径上传</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/1/13/1684765698ad41fe?w=891&amp;h=498&amp;f=gif&amp;s=155843" alt></p><p>配置项与PicGo的图床的配置项基本保持一致。在VSCode插件栏搜索PicGo即可下载安装与体验！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>PicGo第一个稳定版本是在少数派上发布的，详见<a href="https://sspai.com/post/42310" target="_blank" rel="noopener">PicGo：基于 Electron 的图片上传工具</a>。支持macOS、Windows、Linux三平台，开源免费，界面美观，也得到了很多朋友的认可。如果你对它有什么意见或者建议，也欢迎在<a href="https://github.com/Molunerfinn/PicGo/issues" target="_blank" rel="noopener">issues</a>里指出。如果你喜欢它，不妨给它点个star。如果对你真的很有帮助，不妨请我喝杯咖啡（PicGo的GitHub<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">首页</a>有赞助的二维码）？</p><blockquote><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p></blockquote><blockquote><p>Windows用户请下载<code>.exe</code>文件，macOS用户请下载<code>.dmg</code>文件，Linux用户请下载<code>.AppImage</code>文件。</p></blockquote><p>Happy uploading！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;距离上次更新(v1.6.2)已经过去了5个月，很抱歉2.0版本来得这么晚。本来想着在18年12月（PicGo一周年的时候）发布2.0版本，但是无奈正值研究生开题期间，需要花费不少时间（不然毕不了业了T T），所以这个大版本姗姗来迟。不过从这个版本开始，正式支持插件系统，发挥你们的无限想象，PicGo也能成为一个极致的效率工具。&lt;/p&gt;&lt;p&gt;除了发布PicGo 2.0&lt;a href=&quot;https://github.com/Molunerfinn/PicGo/releases/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本体&lt;/a&gt;，一同发布的还有&lt;a href=&quot;https://picgo.github.io/PicGo-Core-Doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo-Core&lt;/a&gt;（PicGo 2.0的底层，支持CLI和API调用），以及VSCode的PicGo插件&lt;a href=&quot;https://github.com/Spades-S/vs-picgo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vs-picgo&lt;/a&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>一周一部好电影V【WEEK210 网络迷踪】</title>
    <link href="https://molunerfinn.com/PerfectMoviePerWeek5/"/>
    <id>https://molunerfinn.com/PerfectMoviePerWeek5/</id>
    <published>2018-11-19T22:29:00.000Z</published>
    <updated>2019-03-17T14:42:12.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018-11-11-WEEK210-网络迷踪"><a href="#2018-11-11-WEEK210-网络迷踪" class="headerlink" title="2018-11-11 WEEK210 网络迷踪"></a>2018-11-11 WEEK210 网络迷踪</h3><p>网络迷踪——————————————Searching<br><img src="https://img.piegg.cn/week210.jpg?imgslim" alt="网络迷踪"></p><ul><li>导演：阿尼什·查甘蒂</li><li>主演：约翰·赵/米切尔·拉/黛博拉·梅辛/约瑟夫·李/萨拉·米博·孙/亚历克丝·杰恩·高/梅金·刘/刘卡雅/多米尼克·霍夫曼/西尔维亚·米纳西安/梅丽莎·迪斯尼/康纳·麦克雷斯/科林·伍德尔/约瑟夫·约翰·谢尔勒/阿什丽·艾德纳/托马斯·巴布萨卡/朱莉·内桑森/罗伊·阿布拉姆森/盖奇·<br>比尔托福/肖恩·奥布赖恩/瑞克·萨拉比亚/布拉德·阿布瑞尔/加布里埃尔D·安吉尔</li><li>片长：102分钟</li><li>影 片类型：剧情/悬疑/惊悚</li><li>豆 瓣评分：8.7/10(from85,981users)</li><li>IMDB评分：7.8/10(from38,178users)</li></ul><a id="more"></a><p>Hi，各位好久不见！（最近在忙毕设开题的事，所以一直没办法按期完成推送。等忙过这一段就能大致恢复正常。）这部电影可以说是小成本制作的典范之作了。全片很有意思，大部分用的镜头来自手机、电脑的前置摄像头，然后配合电脑、手机屏幕的聊天记录、网页记录等来描述故事、展现角色心理状态。很多时候刚敲完的文字，然后想了想又删掉的光标；在屏幕前停留的视线等等都会让你身临其境——因为这些场景在我们当今的生活中，真的司空见惯。</p><p>可以说手机和电脑加上互联网已经占据了很多人一天的大部分。本片也聚焦在当前的网络环境下的人与人之间，父母和孩子之间的关系。我们经常会对父母隐藏自己的某一面，而在互联网上却又是另一副的面孔。所以很多时候本该最了解我们的人，却成了最熟悉的陌生人。当然，意外的惊喜是本片还加入了很不错的悬疑元素，真相大白的那刻，总算把你觉得不对劲的地方说了出来，但是却让你依然感觉很过瘾。好电影，值得一看！</p><hr><h3 id="2018-10-07-WEEK209-奇迹男孩"><a href="#2018-10-07-WEEK209-奇迹男孩" class="headerlink" title="2018-10-07 WEEK209 奇迹男孩"></a>2018-10-07 WEEK209 奇迹男孩</h3><p>奇迹男孩——————————————Wonder<br><img src="https://img.piegg.cn/week209.jpg?imgslim" alt="奇迹男孩"></p><ul><li>导演：斯蒂芬·卓博斯基</li><li>主演：雅各布·特伦布莱/朱莉娅·罗伯茨/伊扎贝拉·维多维奇/欧文·威尔逊/诺亚·尤佩/丹妮尔·罗丝·拉塞尔/纳吉·杰特/戴维<br>德·迪格斯/曼迪·帕廷金/布莱斯·吉扎尔/艾尔·麦金农/泰·孔西利奥/詹姆斯·休斯/凯尔·布瑞特科夫/米莉·戴维斯/莉娅·朱厄<br>特/凯琳·布瑞特科夫/利亚姆·迪金森/艾玛·特伦布莱/马克·多兹劳/鲁奇娅·伯纳德/J·道格拉斯·斯图瓦特/阿里·利伯特/埃丽卡<br>·麦基特里克/本杰明·拉特纳/杰森·麦金农/索尼娅·布拉加/吉洁特</li><li>片长：113分钟</li><li>影 片类型：剧情/家庭/儿童</li><li>豆 瓣评分：8.6/10(from211,803users)</li><li>IMDB评分：8.0/10(from89,828users)</li></ul><!--more--><p>Hi，各位好久不见！本周给大家推荐的是一部来自美国的《奇迹男孩》。从片名就可以看出是讲述一个小男孩的故事。温馨的故事很多，不过各有各打动人的地方。本片讲述的故事可能并没有什么出奇的地方，甚至你也有可能遇到类似的例子。影片中的的主要角色都有自己的一段独白戏。而从独白戏中，你才可以看到那些角色真实的自己。</p><p>就像行星绕着恒星转一样，我们的生活中也或多或少会围着某个人转。在关心他人的同时不得不遮盖自己的伤疤。但其实很多时候跟对方坦诚相待能获得更好的效果。要成为一个善良的人，要做善良的事。温馨的电影，值得一看~</p><hr><h3 id="2018-09-23-WEEK208-谍影重重"><a href="#2018-09-23-WEEK208-谍影重重" class="headerlink" title="2018-09-23 WEEK208 谍影重重"></a>2018-09-23 WEEK208 谍影重重</h3><p>谍影重重——————————————The Bourne Identity<br><img src="https://img.piegg.cn/week208.jpg?imgslim" alt="谍影重重"></p><ul><li>导演：道格·里曼</li><li>主演：马特·达蒙/弗朗卡·波滕特/克里斯·库珀/克里夫·欧文/朱丽娅·斯蒂尔斯/布莱恩·考克斯/阿德沃尔·阿吉纽依-艾格拜吉/加布里埃尔·曼/沃尔顿·戈金斯/约什·汉密尔顿/Orso Maria Guerrini</li><li>片长：119分钟</li><li>影 片类型：动作/悬疑/惊悚</li><li>豆 瓣评分：8.5/10(from215,888users)</li><li>IMDB评分：7.9/10(from461,682users)</li></ul><!--more--><p>Hi，各位好久不见！继上次看完《碟中谍6》之后，在经过舍友的推荐后我找来了另外一部讲述特工的电影《谍影重重》。跟《碟中谍》系列不同的是，《谍影重重》系列的男主角马特达蒙并没有阿汤哥那样帅到让你印象深刻。相反他一开始并不吸引人。</p><p>如果说《007》的看点是特工+美女，《碟中谍》的看点是阿汤哥的颜和拼命，那么《谍影重重》的看点就真的是一个特工的自我救赎了。我想推荐的并不是这一部电影，而是这整个系列（1、2、3、5部）。并且这里面每一部的水平、评分都很高。可以说是荧幕上「最为真实」的讲述间谍、特工的电影了。在这里面你是能真的学习到一些常人并不会特意关注到的细节。伯恩的招式可能没有那么华丽，但是是招招制敌，干净利落不拖泥带水，剧情的发展也是一波三折，紧凑而牵动人心。作为一部动作、悬疑电影我觉得虽然动作戏不如《碟中谍》那么华丽但是也已经足够帮。</p><p>其实第一部已经做得很出色，没想到第二部、第三部也同样出彩。好电影，值得一看。</p><hr><h3 id="2018-09-16-WEEK207-走到尽头"><a href="#2018-09-16-WEEK207-走到尽头" class="headerlink" title="2018-09-16 WEEK207 走到尽头"></a>2018-09-16 WEEK207 走到尽头</h3><p>走到尽头——————————————끝까지 간다<br><img src="https://img.piegg.cn/week207.jpg?imgslim" alt="走到尽头"></p><ul><li>导演：金成勋</li><li>主演：李善均/赵震雄/郑满植/申东美/申正根/朴宝剑</li><li>片长：111分钟</li><li>影 片类型：动作/惊悚/犯罪</li><li>豆 瓣评分：7.8/10(from41,868users)</li><li>IMDB评分：7.2/10(from7,509users)</li></ul><!--more--><p>Hi，各位好久不见！本周给大家推荐的是一部来自韩国的《走到尽头》。这部电影我在3年前曾看过一次，不过最近重新又看了一遍依然感觉十分不错。</p><p>从影片一开始就开始就把观众带入非常紧张、刺激的情节，让人不由自主地为主角捏一把汗。而后的矛盾冲突又依然保持着高度的紧张和不突兀的幽默镜头。而随着剧情的推进，不断地反转也是让人看得很是过瘾。可以说是不停地用新的错误掩盖旧的错误。我想虽然电影有所夸张，但是现实中的我们却总会有类似的时刻。环环相扣的剧情在影片的最后达到高潮。开放式的结局也能让你思考良多。而比起我们的电影结局大多是阳光美好而言，这部电影的结局可以说带着一些黑色气息了。好电影，值得一看！</p><hr><h3 id="2018-09-09-WEEK206-碟中谍6：全面瓦解"><a href="#2018-09-09-WEEK206-碟中谍6：全面瓦解" class="headerlink" title="2018-09-09 WEEK206 碟中谍6：全面瓦解"></a>2018-09-09 WEEK206 碟中谍6：全面瓦解</h3><p>碟中谍6：全面瓦解——————————————Mission: Impossible - Fallout<br><img src="https://img.piegg.cn/week206.jpg?imgslim" alt="碟中谍6：全面瓦解"></p><ul><li>导演：克里斯托弗·麦奎里</li><li>主演：汤姆·克鲁斯/亨利·卡维尔/文·瑞姆斯/西蒙·佩吉/丽贝卡·弗格森/西恩·哈里斯/安吉拉·贝塞特/凡妮莎·柯比/米歇尔·莫纳汉/韦斯·本特利/费雷德里克·施密特/亚历克·鲍德温/杨亮/克里斯托弗·琼勒/沃尔夫·布利策/拉斐尔·琼勒/安德鲁·卡扎纳夫·平/克里斯多夫·德·舒瓦西/拉裴尔·德普雷/让·巴普蒂斯特·菲永/马克斯·盖勒/奥利维尔·体班德/亚历山大·普尔/阿利克斯·贝纳泽什/乔伊·安沙/维利贝·托皮奇/格雷厄姆·福克斯/卡斯珀·菲利普森/菲恩·乔利/鲁斯·贝恩/奈杰尔·艾伦</li><li>片长：147分钟</li><li>影 片类型：动作/惊悚/冒险</li><li>豆 瓣评分：8.3/10(from164,538users)</li><li>IMDB评分：8.1/10(from118,713users)</li></ul><!--more--><p>Hi，各位好久不见！本周给大家推荐的是一部最近正在热映的电影《碟中谍6：全面瓦解》。动作片系列，我觉得如今只有《速度与激情》系列能与《碟中谍》系列比拼了。</p><p>阿汤哥依然是拼命三郎。本片全程无尿点。虽然剧情依然是跟核弹有关（哈哈）。不过不管是跳伞、飙车、开飞机甚至是「屋顶跑酷」都让人看得热血沸腾。22年了，阿汤哥依然是那个阿汤哥，不过当年看他电影的人已经长大了。熟悉的片头曲，琳琅满目的「黑科技」，剧情也是不停地反转反转。整部电影几乎一直处于神经紧绷的状态，让人看了大呼过瘾！</p><p>不知道还能再看到阿汤哥的碟中谍多少次，这部好电影，我想你一定要去看看。</p><hr><h3 id="2018-08-26-WEEK205-游戏之夜"><a href="#2018-08-26-WEEK205-游戏之夜" class="headerlink" title="2018-08-26 WEEK205 游戏之夜"></a>2018-08-26 WEEK205 游戏之夜</h3><p>游戏之夜——————————————Game Night<br><img src="https://img.piegg.cn/week205.jpg?imgslim" alt="游戏之夜"></p><!--more--><ul><li>导演：约翰·弗朗西斯·戴利/乔纳森·M·戈尔茨坦</li><li>主演：杰森·贝特曼/瑞秋·麦克亚当斯/凯尔·钱德勒/ 莎朗·豪根/比利·马格努森/拉蒙尼·莫里斯/凯莉·班伯里/杰西·普莱蒙/ 迈克尔·C·豪尔/丹尼·赫斯顿/切尔西·帕瑞蒂/卡米利·陈/泽瑞克·威廉姆斯/约书亚·米克尔/R·F·戴利</li><li>片长：100分钟</li><li>影 片类型：喜剧/悬疑/犯罪</li><li>豆 瓣评分：7.1/10(from22,632users)</li><li>IMDB评分：7.0/10(from109,979users)</li></ul><p>Hi，各位好久不见~本周给大家推荐的是来自英国的喜剧电影《游戏之夜》。听名字可能并不知道是什么意思，甚至有点「游戏人生」的感觉。但是看完之后却能把你笑得人仰马翻。这部结合了悬疑、犯罪的喜剧电影从分类上来说就让人忍俊不禁。其实同样类型的国内电影还有比如《唐人街探案》系列。不过我更加推荐这一部电影。</p><p>原因？原因在于这部电影的笑点和反转总是让你措手不及，反转会给你会心一击，笑点会让你笑掉下巴。我觉得一部喜剧电影的成功在于它能不用老梗把观众欢笑地送出电影院。而每部喜剧电影或多或少都会有些荤段子。有些电影处理地不好反而让人反感。而这部电影处理起来就让人看完很舒服。它不是什么很高内涵的电影，但是确是一部老少咸宜，适合一群人一起观看一起欢笑的好电影。值得一看~</p><hr><h3 id="2018-08-05-WEEK204-华盛顿邮报"><a href="#2018-08-05-WEEK204-华盛顿邮报" class="headerlink" title="2018-08-05 WEEK204 华盛顿邮报"></a>2018-08-05 WEEK204 华盛顿邮报</h3><p>华盛顿邮报——————————————The Post<br><img src="https://img.piegg.cn/week204.jpg?imgslim" alt="华盛顿邮报"></p><!--more--><ul><li>导演：史蒂文·斯皮尔伯格</li><li>主演：梅丽尔·斯特里普/汤姆·汉克斯/莎拉·保罗森/鲍勃·奥登科克/崔西·莱茨/布莱德利·惠特福德/布鲁斯·格林伍德/马修·瑞斯/爱丽森·布里/凯莉·库恩/杰西·普莱蒙/大卫·克罗斯/扎克·伍兹/帕特·希利/约翰·鲁/里克·霍姆斯/菲利普·卡斯诺夫/杰茜·缪勒/斯塔克·桑德斯/迈克尔·西里尔·克赖顿/威尔·丹顿/迪尔德丽·罗夫乔/迈克尔·斯图巴</li><li>片长：116分钟</li><li>影 片类型：剧情/惊悚/传记/历史</li><li>豆 瓣评分：8.2/10(from45,185users)</li><li>IMDB评分：7.2/10(from82,885users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的，是来自美国的电影《华盛顿邮报》。我记得此前给大家推荐过《聚焦》，那部电影讲的是波士顿环球报的故事。而本片从片名上你就能看出来，讲述的是华盛顿邮报的故事。同样都是讲报社的电影，两部电影讲出了各自不同的风格，不过同样都很精彩。</p><p>本片基于真实事件改编，剧情总体并不复杂，讲述的是华盛顿邮报揭露美国当时的越战黑幕，与尼克松政府「对着干」的故事。如果说《聚焦》的风格是尽力的克制，那么《华盛顿邮报》的风格就是与之相反的锋芒毕露。美国当时深陷越战泥潭，而政府却把战局的节节败退告知公众于步步胜利。在明知打不赢这场战争的情况下还依然偷偷往越南派兵。如果没有有良知的记着冒死将机密文件从五角大厦里偷出，华盛顿邮报将其公之于众，恐怕越战还将继续持续很久。</p><p>不得不提的是报社与政府之间的较量。他们捍卫着新闻自由，捍卫着美国宪法赋予新闻工作者的权利。「报纸不应为统治者服务，而是应该为被统治者服务」。这部电影虽然讲述的故事发生在40多年前，但是对于当世而言依然有很强烈的警示作用。「如果纽约时报和我们（华盛顿邮报）输了，那么自由新闻才是真的输了。」可以很自然的想到，如果当初华盛顿邮报在于政府的禁令面前败下阵来，那么1年后的水门事件也将同样的被压下来。而曝光水门事件促使尼克松下台的，正是华盛顿邮报。</p><p>看完电影真的非常感动，感动于那些新闻工作者为了国家，为了社会，为了人民在努力追求真相，拼死把真相曝光。可恨在于我们的当下，没有质量、没有深入调查、没有核实来源的假新闻、谣言却铺天盖地。不管是前段时间的「汤兰兰事件」，还是「慈溪被害女生事件」等等新闻，都是为了增加曝光量，却没有考虑到当事人、当事方的感受的新闻。一味追求标题党，撒手把事情甩锅给其他人，让当事人当事方得花十倍百倍的力气去辟谣。这种新闻是可恨的。而那些追求真理，曝光真相的新闻，比如曝光疫苗案、比如毒奶粉案等等的调查记者们，却因为触动了某些人的利益，触动了它们脆弱的神经，遭到掩盖、封杀、甚至人身威胁。演变成现在，我们很多的新闻、很多的细节不得不通过微信公众号、微博截图等等才能看到第一手的材料。因为一旦晚了，就是「该内容已被发布者删除」「该内容因违规无法查看」。这里面也是鱼龙混杂，有的人为了坚持正义，发出的文章无奈被封，而自己的账号也被封禁；有的人为了蹭热点不惜一切代价做出煽情的文章，而变相输出一些谣言。然而人们在这里面获取到信息后通常容易出现广泛传播。当局的做法通常是不论真假一并封杀。</p><p>《中华人民共和国宪法》第二章第三十五条规定：中华人民共和国公民有言论、出版、集会、结社、游行、示威的自由。</p><p>然而今天的真相是我们的「言论自由」是有代价的，通常只要触犯到某些人的利益就会遭到全面的封杀。我不知道它们看过《华盛顿邮报》之后会怎么想，恐怕会很害怕吧。「宜疏不宜堵」「水能载舟亦能覆舟」的道理，小学生都知道。不知道那些口口声声说着「为人民服务」的人，为什么不懂呢。好电影，值得一看。</p><hr><h3 id="2018-07-22-WEEK203-第十二人"><a href="#2018-07-22-WEEK203-第十二人" class="headerlink" title="2018-07-22 WEEK203 第十二人"></a>2018-07-22 WEEK203 第十二人</h3><p>第十二人——————————————Den 12. mann<br><img src="https://img.piegg.cn/week203.jpg?imgslim" alt="第十二人"></p><!--more--><ul><li>导演：哈罗德·兹瓦特</li><li>主演：乔纳森·莱斯·梅耶斯/托马斯·古勒斯塔德/玛丽·布洛克胡斯/维加·霍尔/马丁·基弗</li><li>片长：135分钟</li><li>影 片类型：剧情/历史/战争</li><li>豆 瓣评分：7.8/10(from2,665users)</li><li>IMDB评分：7.5/10(from4,773users)</li></ul><p>Hi，各位好久不见！好久没给大家推荐战争类型的电影了。本次给大家推荐的是一部来自挪威的电影，讲述了一个12人的小队，最终只有第12个人生还的故事。这部电影最震撼的就是片头说的「这个故事里，最令人难以置信的是，确有其事。」。</p><p>跟敦刻尔克一样，这部电影讲述的不是消灭了多少德军，而是讲述了如何生还（或者「逃跑」）的故事。这个故事讲述的虽然是「一个人」，但是实际上讲的是一群人的故事。「我不是英雄，那些帮助了我的人才是英雄」。这部电影伟大之处在于给予一路上帮助主角的人足够多的镜头和描写。为了帮助主角逃生，很多人甚至会为此付出生命的代价。</p><p>这部取景很「冷」的电影，在冲破国境线的那一刻却格外地热血沸腾。好电影，值得一看。</p><hr><h3 id="2018-07-08-WEEK202-我不是药神"><a href="#2018-07-08-WEEK202-我不是药神" class="headerlink" title="2018-07-08 WEEK202 我不是药神"></a>2018-07-08 WEEK202 我不是药神</h3><p>我不是药神——————————————我不是药神<br><img src="https://img.piegg.cn/week202.jpg?imgslim" alt="我不是药神"></p><!--more--><ul><li>导演：文牧野</li><li>主演：徐峥/王传君/周一围/谭卓/章宇/杨新鸣/王佳佳/王砚辉/贾晨飞/龚蓓苾/宁浩/李乃文</li><li>片长：117分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：9.0/10(from350,132users)</li><li>IMDB评分：8.3/10(from372users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是刚上映的大热门《我不是药神》。其实光看名字和海报的时候，我以为只是徐峥的一部常规喜剧电影。然而自从点映以来就有不少朋友给我推荐。于是今天也去电影院看了，发现确实值得上豆瓣9.0的分数。「我们也拍出了韩国那样的电影」。这是我看完感慨最深的一点。</p><p>在审查严苛、国情如此的情况下我们还能拿出一部直击社会问题，反映社会现实和矛盾，并让不少人由衷落泪的电影，真的非常不容易。其实从前年的《湄公河行动》、去年的《战狼2》、今年的《红海行动》之后，我很害怕我们国家以后的「好」电影都只能是这类主旋律的动作片了。我们有《心迷宫》、《暴裂无声》等质量上乘的悬疑电影，也有逗男女老少开心一笑的《泰囧》、《夏洛特烦恼》等优质喜剧片等等。但是我们缺的是直击社会问题，挖掘人性的剧情电影。我们少了多少《辩护人》、少了多少未见的《熔炉》、少了多少难得的《Taxi Driver》。今天一部《我不是药神》让我看到了中国电影的未来还是有希望的。这部基于真实事件改编的电影，从影片一开始就会让你有种深深代入感——因为你也是千千万万中国人之一，这就会是发生在你身边的事。</p><p>不管是配乐、剪辑还是情节的把控，导演和主演们都让我们感到了深深的负责和认真。该给的镜头一个不少，该有的细节一个不缺，该哭的泪点一个不落。你知道这将是中国电影的一个里程碑式的电影么，这么棒的电影真的值得你去一看。</p><hr><h3 id="2018-06-27-WEEK201-寻梦环游记"><a href="#2018-06-27-WEEK201-寻梦环游记" class="headerlink" title="2018-06-27 WEEK201 寻梦环游记"></a>2018-06-27 WEEK201 寻梦环游记</h3><p>寻梦环游记——————————————Coco<br><img src="https://img.piegg.cn/week201.jpg?imgslim" alt="寻梦环游记"></p><!--more--><ul><li>导演：李·昂克里奇/阿德里安·莫利纳</li><li>主演：安东尼·冈萨雷斯/盖尔·加西亚·贝纳尔/本杰明·布拉特/阿兰纳·乌巴奇/芮妮·维克托/杰米·卡米尔/阿方索·阿雷奥/赫 伯特·西古恩萨/加布里埃尔·伊格莱西亚斯/隆巴多·博伊尔/安娜·奥菲丽亚·莫吉亚/娜塔丽·科尔多瓦/赛琳娜·露娜/爱德华·詹姆斯·奥莫斯/索菲亚·伊斯皮诺萨/卡拉·梅迪纳/黛娅娜·欧特里/路易斯·瓦尔德斯/布兰卡·阿拉切利/萨尔瓦多·雷耶斯/切奇·马林/奥克塔维·索利斯/约翰·拉岑贝格</li><li>片长：105分钟</li><li>影 片类型：喜剧/动画/音乐/奇幻</li><li>豆 瓣评分：9.0/10(from509,070users)</li><li>IMDB评分：8.5/10(from188,620users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是来自皮克斯的动画电影《寻梦环游记》。这部电影在当时上映的时候获得了很高的评价。不过我直到最近才看了它。不得不说确实是一部很赞的电影。关于这部电影有个有趣的段子，引进的时候，由于把审片的人都看哭了，所以本来是不能上映的亡灵题材的电影也过审了。暂且不考虑这个说法的真实性，从这个段子里你也能看出这部电影的硬实力确实很强。<br>这部是一部关于音乐，梦想和爱的电影。故事的构思很巧妙，背景设置在墨西哥也是别有一番风味。电影给我们营造了一个及其绚丽的亡灵世界。在这里大部分的生活是快乐的，不过也有令人揪心的问题——如果在人间没有人还记得你的话那么你将会在亡灵世界里消逝。这点真的非常赞，完美诠释了那句话：「人会死三次，第一次是在他停止呼吸的时候 ，从生物学上说他死了，他失去了思考的能力；第二次是在他下葬的时候，人们来参加他的葬礼，怀念他的过往和人生，然后在社会上他死了，活着的世界里不再会有他的位置；第三次是世界上最后一个记得他的人把他忘记的时候，那时候他才能算是真正的死了，永远的死了。」这个设定也带来了剧情的里的矛盾点和发展点。后续的情节铺开张弛有度，有情理之中也有意料之外。感动人心，好电影值得一看~</p><hr><h3 id="2018-06-13-WEEK200-燃烧"><a href="#2018-06-13-WEEK200-燃烧" class="headerlink" title="2018-06-13 WEEK200 燃烧"></a>2018-06-13 WEEK200 燃烧</h3><p>燃烧——————————————버닝<br><img src="https://img.piegg.cn/week200.png?imgslim" alt="燃烧"></p><!--more--><ul><li>导演：李沧东</li><li>主演：刘亚仁/史蒂文·元/全钟瑞/金秀京/崔承浩/玉子妍</li><li>片长：148分钟</li><li>影 片类型：剧情/悬疑</li><li>豆 瓣评分：8.0/10(from23,263users)</li><li>IMDB评分：7.9/10(from418users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是今年韩国一部大热的电影《燃烧》。这部电影并不是一部容易读懂的电影。改编自村上春树的《烧仓房》，不过导演也为这部电影注入了很多自己的思想。（建议可以看看《烧仓房》，是部短篇小说）这部电影的节奏比较缓慢，很多细节是慢慢地又完整地展现在你面前。而电影里最让人困惑，或者最烧脑，或者说加入了作者最深入的思考的部分，却又是那些可有可无的「线索」。它们有些到最后都没有得到导演给出的解释。开放式的结局，甚至开放式的剧情都是这部电影非常让人难以缓过神来的地方。而平淡地讲述故事的同时，也有着「最美之舞」的唯美画面。</p><p>聚焦着当下韩国年轻人的痛点，在讲述一场可疑的案件的同时，又让你不得不思考，自己活着是一个「little hunger」还是一个「greate hunger」。而为何有些人，莫名其妙地，年纪轻轻就成了「盖茨比」。不平等的阶层注定不平等的追求。好电影，值得一看。</p><hr><h3 id="2018-05-27-WEEK199-国际市场"><a href="#2018-05-27-WEEK199-国际市场" class="headerlink" title="2018-05-27 WEEK199 国际市场"></a>2018-05-27 WEEK199 国际市场</h3><p>国际市场——————————————국제시장<br><img src="https://img.piegg.cn/week199.jpg?imgslim" alt="国际市场"></p><!--more--><ul><li>导演：尹齐均</li><li>主演：黄晸玟/金允珍/吴达洙/张荣男/郑镇荣/罗美兰/金瑟祺/郑允浩/Stella Choe</li><li>片长：126分钟</li><li>影 片类型：剧情/家庭</li><li>豆 瓣评分：8.3/10(from34,907users)</li><li>IMDB评分：7.8/10(from2,500users)</li></ul><p>Hi，各位好久不见。本周给大家推荐的是来自韩国的《国际市场》。初看这部电影的名字，并不能看出什么名堂。不过这部电影类似于《阿甘正传》一样，描述了一部韩国的现代史。从6·25事件（可以认为是朝鲜战争全面爆发）开始，一直延续到如今。</p><p>这是目前韩国影史票房第二的电影。能获得如此巨大的成功，我想除了过硬的演员素质（黄晸玟、金允珍、吴达洙等实力派演员），编剧和导演对于情节穿插的到位把控，还有就是唤起了很多韩国人对于朝鲜战争过后，韩国从无到有，从落后朝鲜到超过朝鲜的那段历史的回忆。这部电影以主角德秀的成长作为主线，对父亲的承诺，对妹妹的愧疚，对姑姑的感恩等等。并不断加入一些暗藏的线索或者说「彩蛋」，在整体氛围是催人泪下的情况下，还能掺杂着不少喜剧的成分，非常具有这几年韩国高分电影的风格。</p><p>影片末尾的那句，「但是爸，我真的好累啊」让我不禁落泪。这部电影能直击你内心最容易被触动的角落，好电影，值得一看。</p><hr><h3 id="2018-05-23-WEEK198-暴烈无声"><a href="#2018-05-23-WEEK198-暴烈无声" class="headerlink" title="2018-05-23 WEEK198 暴烈无声"></a>2018-05-23 WEEK198 暴烈无声</h3><p>暴烈无声——————————————Wrath of Silence<br><img src="https://img.piegg.cn/week198.png?imgslim" alt="暴烈无声"></p><!--more--><ul><li>导演：忻钰坤</li><li>主演：宋洋/姜武/袁文康/谭卓/王梓尘/安琥</li><li>片长：120分钟</li><li>影 片类型：剧情/悬疑/犯罪</li><li>豆 瓣评分：8.3/10(from100,190users)</li><li>IMDB评分：7.2/10(from250users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是来自《心迷宫》导演的第二部佳作《暴烈无声》。好吧依然是一部从名字里看不出说啥的电影。有了《心迷宫》的成功铺垫，《暴烈无声》在经费上也算是大大地改善了。而且宋洋、姜武等实力派演员的出演也是给这部电影添色不少。</p><p>不过相比心迷宫的烧脑，这部电影打出的宣传语是：「烧脑，更烧心」。是的，这部电影虽然是一部悬疑片，但是不仅仅是一部悬疑片。导演其实是想借着这部电影，隐喻现实中的三类人。一类是在社会底层摸爬滚打，有苦说不出，有难没处诉的人；一类是生活过得还可以，努力工作努力养家糊口的中产阶级；一类是生活在社会顶层，物质生活富裕，但是依仗钱、权背地里做些违法乱纪之事的人。</p><p>我们常听「邪不压正，正义或许会迟到，但绝不会缺席」。不过看完这部电影，你会发现其实还是有不少的事，正义的缺席带给你我的，是多么无助，多么的无力。暴烈无声，拳头能换来的，是说不出的绝望。好电影，值得一看。</p><hr><h3 id="2018-05-14-WEEK197-至暗时刻"><a href="#2018-05-14-WEEK197-至暗时刻" class="headerlink" title="2018-05-14 WEEK197 至暗时刻"></a>2018-05-14 WEEK197 至暗时刻</h3><p>至暗时刻——————————————Darkest Hour<br><img src="https://img.piegg.cn/week197.png?imgslim" alt="至暗时刻"></p><!--more--><ul><li>导演：乔·赖特</li><li>主演：加里·奥德曼/克里斯汀·斯科特·托马斯/莉莉·詹姆斯/本·门德尔森/斯蒂芬·迪兰/萨缪尔·韦斯特/汉娜·斯蒂尔/罗纳德·皮卡普/乔丹·沃勒/理查德·拉姆斯登/安娜·伯内特/尼古拉斯·琼斯/查理·帕尔默·罗斯韦尔/布赖恩·佩蒂福/菲利普·马丁·布朗/安杰莉克·琼/希尔顿·麦克雷/詹姆斯·伊莱斯/杰瑞米·查亚德/马汀·麦格/迈克尔·海登/迈克尔·博特</li><li>片长：125分钟</li><li>影 片类型：剧情/传记/历史</li><li>豆 瓣评分：8.6/10(from145,583users)</li><li>IMDB评分：7.4/10(from95,095users)</li></ul><p>Hi，各位好久不见。这段时间确实比较忙，一直拖更我表示非常愧疚。本周给大家带来的是一部来自英国的电影《至暗时刻》。别看名字好像阴森恐怖，但是实际上它并不是一部恐怖电影。它是一部讲述英国著名首相丘吉尔的电影。</p><p>丘吉尔在面对重重困难，做出了一系列后世看来非常正确的决策。但是鲜有人知这些决策背后的故事。如果你知道敦刻尔克大撤退，那么你未必知道为了让敦刻尔克的30万英法联军撤回英国，为了多争取时间，牺牲了临近的一个英国旅（4000人）；你未必知道当时的情况下，征用民船已经是无奈之举，而且几乎是千钧一发之际才正好赶上撤军；你也许知道丘吉尔爱抽雪茄，但是你未必知道丘吉尔还嗜酒，个性分明……</p><p>这部电影里，加里·奥德曼把丘吉尔演绎得惟妙惟肖，十分令人印象深刻。也因此大家都在说他要因为出演丘吉尔这个角色拿到奥斯卡小金人了。好电影，值得一看！</p><hr><h3 id="2018-04-23-WEEK196-1987-黎明到来的那一天"><a href="#2018-04-23-WEEK196-1987-黎明到来的那一天" class="headerlink" title="2018-04-23 WEEK196 1987:黎明到来的那一天"></a>2018-04-23 WEEK196 1987:黎明到来的那一天</h3><p>1987:黎明到来的那一天——————————————일구팔칠<br><img src="https://img.piegg.cn/week196.jpg?imgslim" alt="1987:黎明到来的那一天"></p><!--more--><ul><li>导演：张俊焕</li><li>主演：金允锡/河正宇/柳海真/金泰梨/朴喜洵/李熙俊/..</li><li>片长：129分钟</li><li>影 片类型：剧情</li><li>豆 瓣评分：无</li><li>IMDB评分：8.0/10(from768users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的一部电影是国内豆瓣都「没有办法出现」的韩国电影《1987:黎明到来的那一天》。因为某些原因这部电影在国内被封杀，所以我也不好说得太多。去看看吧，好电影值得一看。</p><hr><h3 id="2018-04-08-WEEK195-头号玩家"><a href="#2018-04-08-WEEK195-头号玩家" class="headerlink" title="2018-04-08 WEEK195 头号玩家"></a>2018-04-08 WEEK195 头号玩家</h3><p>头号玩家——————————————Ready Player One<br><img src="https://img.piegg.cn/week195.jpg?imgslim" alt="头号玩家"></p><!--more--><ul><li>导演：史蒂文·斯皮尔伯格</li><li>主演：泰伊·谢里丹/ 奥利维亚·库克/本·门德尔森/马克·里朗斯/丽娜·维特/森崎温/赵家正/西蒙·佩吉/T·J·米勒/汉娜·乔恩-卡门/拉尔夫·尹爱森/苏珊·林奇/克莱尔·希金斯/劳伦斯·斯佩尔曼/佩蒂塔·维克斯/艾萨克·安德鲁斯</li><li>片长：140分钟</li><li>影 片类型：动作/科幻/冒险</li><li>豆 瓣评分：8.9/10(from311,268users)</li><li>IMDB评分：7.9/10(from68,363users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是最近影院的大热门《头号玩家》。这部电影的豆瓣评分有点「虚高」，不过不可否认确实是一部非常棒的科幻电影。这是斯皮尔伯格送给年轻人、玩家、动漫迷们一份最好的礼物。</p><p>和过往的科幻电影有所不同的是，故事发生在不远的未来，不过科技并没有发展到「变态」的程度。所以电影里的很多东西，包括VR都是在现有的基础上进行的升华。而营造出来的虚拟世界无疑是最吸引眼球的。有人说这部电影是一部彩蛋里插播电影的电影。确实这部电影里彩蛋特别多，但是不用担心，没有人会真的了解所有的彩蛋，所以哪怕你并不关心游戏、动漫、电影，你也能在电影院感受两个半小时的视听盛宴。</p><p>大概最感动的地方就是遇到你所认识、你所熟知的角色、游戏在电影中的一闪而过。你会想起当年在家里打红白机、小霸王的那个年代，你会想起当年守在电视机前只为等待一部好看的动画片的自己。这部电影想要告诉你的也是一样——那些在你脑海中挥之不去的，那些回忆，那些童年才是最真实的。现实世界终究是追求自由追求真实的，在虚拟世界里再如何成功也不过是过眼烟云，现实中的伙伴，生活才是你最应该珍惜的。好电影，值得去一看。</p><hr><h3 id="2018-03-14-WEEK194-启示录"><a href="#2018-03-14-WEEK194-启示录" class="headerlink" title="2018-03-14 WEEK194 启示录"></a>2018-03-14 WEEK194 启示录</h3><p>启示录——————————————Apocalypto<br><img src="https://img.piegg.cn/week194.jpg?imgslim" alt="启示录"></p><!--more--><ul><li>导演：梅尔·吉布森</li><li>主演：鲁迪·杨布拉德/达利娅·埃尔南德斯/乔纳森·布雷维尔/莫里斯·博德耶洛海德/劳尔·特鲁希洛/赫拉多·塔拉塞纳/卡洛斯·伊米里奥·巴厄兹/阿米尔卡尔·拉米瑞兹/伊斯雷尔·康特雷拉斯/伊斯雷尔·里<br>奥斯/玛利亚·迪亚兹/埃斯皮里迪恩·阿科斯塔·卡奇/梅拉·萨布罗/伊阿祖娅·拉里奥斯/艾贝尔·伍尔里奇</li><li>片长：139分钟</li><li>影 片类型：剧情/动作/冒险</li><li>豆 瓣评分：8.5/10(from46,606users)</li><li>IMDB评分：7.8/10(from257,854users)</li></ul><p>Hi，各位好久不见！这部电影是来自公众号的粉丝推荐的一部好电影。很开心来一起分享它！这部电影的背景是玛雅文明衰落时期的故事，但是实际上有些情节又与当时鼎盛的阿兹特克文明有所重合。不过抛去历史背景，这个发生在热带雨林里的故事，却是惊心动魄，让人叹为观止。</p><p>影片的节奏松紧有度。开篇的情节把主要的人物性格、特点都印刻在观众的脑海中。而到了中途，就开始了震撼的追逐。如果从片名里直译的《启示录》里你看不到大致的情节的话，台译版的《阿波卡猎逃》可能就会让你的肾上腺素有所提升。不过如果你读过或者知道圣经里的《启示录》的话，那么这个题目真是太恰当不过了。一场文明的毁灭与新的文明的重生。这是一部让你无法忘却的电影，「文明」世界带去的文明，无非也是野蛮的征服。好电影，值得一看。</p><hr><h3 id="2018-03-14-WEEK193-红海行动"><a href="#2018-03-14-WEEK193-红海行动" class="headerlink" title="2018-03-14 WEEK193 红海行动"></a>2018-03-14 WEEK193 红海行动</h3><p>红海行动——————————————红海行动<br><img src="https://img.piegg.cn/week193.jpg?imageslim" alt="红海行动"></p><!--more--><ul><li>导演：林超贤</li><li>主演：张译/黄景瑜/海清/杜江/蒋璐霞/尹昉/王强/郭郁滨/王雨甜/麦亨利/张涵予/王彦霖</li><li>片长：138分钟</li><li>影 片类型：剧情/动作/犯罪</li><li>豆 瓣评分：8.5/10(from321,371users)</li><li>IMDB评分：7.6/10(from1,254users)</li></ul><p>Hi，各位好久不见！前不久我刚去看了最近大热的《红海行动》。记得当初也给大家推荐过《湄公河行动》和《战狼2》。不得不说这两年来我们自己拍出来的战争、动作片的水准是越来越高了。本片的导演也是《湄公河行动》的导演林超贤。可以说自《湄公河行动》后的两年，真的是卷土重来。并且带来了质量更好，水平更高，更加真实而震撼的场面。</p><p>本片根据真实事件改编，还原度相当高。不仅影片出现的枪械、装备、坦克等都非常写实，而且一些镜头例如汽车炸弹、精密狙击、迫击炮狂轰滥炸等等都有很强的视觉冲击。而最震撼人心的，还有出现的很多「血腥」的场景——以往在国产电影里被剪掉无法搬上荧幕的战争的一些遗体、残骸。而整体剧情也非常紧凑，从头到尾都无尿点啊。而海陆空全面的镜头也让人大呼过瘾。同时，反战的主题也深入人心啊。好电影，值得一看！</p><hr><h3 id="2018-03-01-WEEK192-弱点"><a href="#2018-03-01-WEEK192-弱点" class="headerlink" title="2018-03-01 WEEK192 弱点"></a>2018-03-01 WEEK192 弱点</h3><p>弱点——————————————The Blind Side<br><img src="https://img.piegg.cn/week192.jpg?imageslim" alt="弱点"></p><!--more--><ul><li>导演：约翰·李·汉考克</li><li>主演：桑德拉·布洛克/蒂姆·麦格罗/昆东·亚伦/杰·海德/莉莉·柯林斯/雷·迈克金农/凯西·贝茨</li><li>片长：USA: 129 分钟</li><li>影 片类型：剧情/家庭/传记/运动</li><li>豆 瓣评分：8.4/10(from104,599users)</li><li>IMDB评分：7.7/10(from248,692users)</li></ul><p>Hi，各位好久不见，新年快乐呀！趁新年还未完全过去，赶紧来给大家推荐每周一部的好电影，拖更了好久哈哈。本周给大家推荐的是一部来自美国的温情电影《弱点》。不过我一直觉得翻译有问题，翻译成「盲点」应该更好点。</p><p>这部电影是根据原著《The Blind Side: Evolution of the Game》改编的电影，而原著的原型也是来自于真实的故事。所以说这部电影的真实感让人非常感动——片中的人大多都超出你的想象的好。与大部分的电影不同的是，它的矛盾点、冲突点特别少。虽然在一些细节的处理上有些过快，不过能够在两个小时里塞进一个橄榄球传奇球员从默默无闻青年时代到最后脱颖而出的选秀状元，可以说是真的很不容易了。我在看的时候一直在惯性思考着等着导演「耍把戏」，不过从头到尾都非常地温馨，非常的动人。</p><p>它是一部能够打动你的泪腺的电影，一部好电影，献给新年的第一部推荐。</p><hr><h3 id="2018-02-04-WEEK191-抓住那个家伙"><a href="#2018-02-04-WEEK191-抓住那个家伙" class="headerlink" title="2018-02-04 WEEK191 抓住那个家伙"></a>2018-02-04 WEEK191 抓住那个家伙</h3><p>抓住那个家伙——————————————몽타주<br><img src="https://img.piegg.cn/week191.jpg?imageslim" alt="抓住那个家伙"></p><!--more--><ul><li>导演：郑根燮</li><li>主演：金相庆/严正化/宋永彰/曹熙奉/刘承睦/李俊赫/朴哲民</li><li>片长：120分钟</li><li>影 片类型：剧情/惊悚/犯罪</li><li>豆 瓣评分：7.9/10(from25,085users)</li><li>IMDB评分：7.5/10(from3,342users)</li></ul><p>Hi，各位好久不见！本周依然给大家推荐一部有悬疑色彩的犯罪电影。这部来自韩国的电影从一开始就让我们感到一丝伤感。导演很擅长用暗色调渲染这种压抑而忧伤的气氛。所以从一开始我们就逐渐掉进这个陷阱中了。</p><p>整体上电影是双线并进，两条时间线互相交错，以至于到最后汇合的时候碰撞出的火花恐怕要让你拍案叫绝。两起案件，两个真相。和里面的警察一样，我们大多数人都会被眼前的“证据”蒙蔽，相信一些说不过去的“真相”。而很多事情是需要推敲，需要冷静的。</p><p>受害者也是加害者，这样的双重身份在电影里互相交织，让人性这个词又得以从电影剧本里脱颖而出。事实上，这部电影也是一部关于人性的思考，关于悔过的思考。好电影，值得一看~</p><hr><h3 id="2018-01-28-WEEK190-目击者追凶"><a href="#2018-01-28-WEEK190-目击者追凶" class="headerlink" title="2018-01-28 WEEK190 目击者追凶"></a>2018-01-28 WEEK190 目击者追凶</h3><p>目击者追凶——————————————目擊者<br><img src="https://img.piegg.cn/week190.jpg?imageslim" alt="目击者追凶"></p><!--more--><ul><li>导演：程伟豪</li><li>主演：庄凯勋/许玮甯/柯佳嬿/李铭顺/李淳/陈彦允/郑志伟/汤志伟/卜国耕</li><li>片长：117分钟</li><li>影 片类型：悬疑/惊悚/犯罪</li><li>豆 瓣评分：8.1/10(from55,592users)</li><li>IMDB评分：7.0/10(from1,020users)</li></ul><p>Hi，各位好久不见！本周给大家推荐的是一部来自台湾的悬疑电影《目击者追凶》。我记得去年我曾推荐过一部大热的西班牙悬疑电影《看不见的客人》，精妙的剧本，峰会路转的剧情让很多人拍案叫绝。而这部来自宝岛台湾的电影也不逊色。</p><p>明线、暗线的堆叠，从一开始就埋下的伏笔。导演在一些细节的处理，比如一些闪回的镜头上做的是真的不错的。一次次小规模的反转铸就了最后令人吃惊而毛骨悚然的结局。这部电影里可以说基本没有“好人”。恐怕唯一的好人就是可怜的阿吉了。而所有其他出现在镜头里的主要角色，都有着外表和内在不同的反差。这也是这部电影可圈可点的地方。</p><p>而一部好的悬疑电影自然是到最后一刻才会完美收官。本片也不例外，片末的“鬼故事”，实在是画龙点睛之笔。好电影，值得一看。</p><hr><h3 id="2018-01-21-WEEK189-无问西东"><a href="#2018-01-21-WEEK189-无问西东" class="headerlink" title="2018-01-21 WEEK189 无问西东"></a>2018-01-21 WEEK189 无问西东</h3><p>无问西东——————————————Forever Young<br><img src="https://img.piegg.cn/week189.jpg?imageslim" alt="无问西东"></p><!--more--><ul><li>导演：李芳芳</li><li>主演：章子怡/黄晓明/张震/王力宏/陈楚生/韩童生/王盛德/米雪/保罗·菲利普·克拉克/祖锋/铁政/章泽天</li><li>片长：138分钟</li><li>影 片类型：剧情/爱情/战争</li><li>豆 瓣评分：7.5/10(from140,810users)</li><li>IMDB评分：6.5/10(from138users)</li></ul><p>Hi，各位好久不见！本次给大家推荐的是一部时隔5年重见天日的电影——《无问西东》。这部电影本来是打算献礼给清华大学建校100周年的，因为某些不可知的原因，一再推迟到如今才能上映。剧中的主演也都在这5年中结婚生子，变化之大也令人感慨。</p><p>既然是献礼给清华大学的电影，剧中自然少不了清华大学的身影。电影分成了4段故事来讲述。每段时间内发生的故事都有鲜明的时代特色。而4个故事之间的关联，也在影片“不经意”之间透露出来。而这样的安排也引起了一堆的不认可。然而我却觉得这样的安排非常棒。和云图的前世今生相比，这样的安排不仅更加贴近真实而且更加动人。</p><p>而每个故事里的主人公的演技我认为在当时，哪怕放到现在也都是非常不错的。就像豆瓣里有人说的，“最棒的王力宏和非常好的黄晓明”。两个小时，4个故事，横跨100年。这样庞大的题材，虽然导演确实在某些细节上处理的有些牵强，不过依旧不改这部电影交出的高分答卷。应对人生的选择，人声的苦难，你该如何继续？如果你没有看过《南渡北归》，你无法明白当年西南联大有多么不容易，当年的那些大家能够给本科生上课是有多么珍贵。电影最后给出的一个个那些年顶尖的学者，真是满满的感动和自豪。无问西东，砥砺前行。好电影，值得一看。</p><hr><h3 id="2018-01-08-WEEK188-三块广告牌"><a href="#2018-01-08-WEEK188-三块广告牌" class="headerlink" title="2018-01-08 WEEK188 三块广告牌"></a>2018-01-08 WEEK188 三块广告牌</h3><p>三块广告牌——————————————Three Billboards Outside Ebbing, Missouri<br><img src="https://img.piegg.cn/week188.jpg?imageslim" alt="三块广告牌"></p><!--more--><ul><li>导演：马丁·麦克唐纳</li><li>主演：弗兰西斯·麦克多蒙德/伍迪·哈里森/山姆·洛克威尔/艾比·考尼什/卢卡斯·赫奇斯/彼特·丁拉基/约翰·浩克斯/卡赖伯·兰德里·琼斯/凯瑟琳·牛顿/凯瑞·康顿/泽利科·伊万内克/萨玛拉·维文/克拉克·彼得斯/尼克·西塞</li><li>片长：115分钟</li><li>影 片类型：剧情/犯罪</li><li>豆 瓣评分：8.7/10(from20,455users)</li><li>IMDB评分：8.3/10(from31,903users)</li></ul><p>Hi，各位好久不见！忙完考试之后终于有时间来写本周的电影推荐了。本周给大家推荐的是去年底在美国上映（中国将在18年3月上映）的电影《三块广告牌》。</p><p>在这部充满美式幽默和美式愤怒的电影里，看到了久违的不靠煽情而让你动容的一部电影。不过我认为，真正让这部电影拥有如此好评的原因在于两点：</p><ol><li>导演（同时也是编剧）的讲故事的功力深厚</li><li>演员（尤其是科恩嫂）的演技强劲</li></ol><p>这部是一部讲述愤怒与善良，爱与恨的电影。愤怒不能解决问题，但是爱可以。影片塑造的多个人物都具有两面性——这也是本部电影最棒的地方。没有一个人是可以用好或者不好来形容的。每个人都有自己的阳光和阴暗面——而一开始我们不免进入了导演给我们设置的俗套。而随着剧情的发展你才会发现这一切都不是那么简单。“坏”警长其实不坏——相反还非常受人敬仰，“烂”警察其实不烂——相反他还自损三千地只为抓犯人等等。</p><p>而在被套路或者反套路的同时，你也逐渐了解到美国社会的诸多矛盾以及人的诸多美好品质。愤怒不能解决问题，但是善良与爱是可以的。好电影，值得一看。</p><hr><h3 id="2018-01-01-WEEK187-我能说"><a href="#2018-01-01-WEEK187-我能说" class="headerlink" title="2018-01-01 WEEK187 我能说"></a>2018-01-01 WEEK187 我能说</h3><p>我能说——————————————아이 캔 스피크<br><img src="https://img.piegg.cn/week187.jpg?imageslim" alt="我能说" title="我能说"></p><!--more--><ul><li>导演：金炫锡</li><li>主演：罗文姬/李帝勋/廉惠兰/朴哲民/李相喜/李知勋/郑妍周/金素真</li><li>片长：119分钟</li><li>影 片类型：剧情/喜剧</li><li>豆 瓣评分：8.8/10(from19,693users)</li><li>IMDB评分：7.7/10(from195users)</li></ul><p>Hi，各位新年快乐~转眼之间一周一部好电影已经来到了第5个年头。前四个年头通过一周一部好电影我已经推送了186部各种主题，各种类型，各种风格的电影，希望新的一年里能够有更多的好电影能够分享给各位~</p><p>本周给大家推荐的电影是一部去年韩国的电影《我能说》。一部能用喜剧的形式来讲述“慰安妇”这个沉痛主题的电影，真的无不佩服编剧的功力以及演员的水平。两个主演的表演真的太动人了。</p><p>这部电影能分成两部分。前半部分以喜剧为主，讲述一个“鬼怪奶奶”的各种“鬼怪”行径。而前半部分用尽努力“掩盖”的欢乐，在后半段会被导演“无情”地打碎，同时打碎的还有观众的泪腺。而同时引出的是这部电影的主题啊——那些被人们忽略的受害者们，那些无法说出，不愿说出，不想说出自己曾经经历的受害者们。她们真的需要更多我们的关怀和帮助。国内今年的《二十二》也是同样的主题。不同的角度，不过都是同样的出发点和同样的愿望——日本政府的一句道歉。好电影，值得一看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2018-11-11-WEEK210-网络迷踪&quot;&gt;&lt;a href=&quot;#2018-11-11-WEEK210-网络迷踪&quot; class=&quot;headerlink&quot; title=&quot;2018-11-11 WEEK210 网络迷踪&quot;&gt;&lt;/a&gt;2018-11-11 WEEK210 网络迷踪&lt;/h3&gt;&lt;p&gt;网络迷踪——————————————Searching&lt;br&gt;&lt;img src=&quot;https://img.piegg.cn/week210.jpg?imgslim&quot; alt=&quot;网络迷踪&quot;&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;导演：阿尼什·查甘蒂&lt;/li&gt;&lt;li&gt;主演：约翰·赵/米切尔·拉/黛博拉·梅辛/约瑟夫·李/萨拉·米博·孙/亚历克丝·杰恩·高/梅金·刘/刘卡雅/多米尼克·霍夫曼/西尔维亚·米纳西安/梅丽莎·迪斯尼/康纳·麦克雷斯/科林·伍德尔/约瑟夫·约翰·谢尔勒/阿什丽·艾德纳/托马斯·巴布萨卡/朱莉·内桑森/罗伊·阿布拉姆森/盖奇·&lt;br&gt;比尔托福/肖恩·奥布赖恩/瑞克·萨拉比亚/布拉德·阿布瑞尔/加布里埃尔D·安吉尔&lt;/li&gt;&lt;li&gt;片长：102分钟&lt;/li&gt;&lt;li&gt;影 片类型：剧情/悬疑/惊悚&lt;/li&gt;&lt;li&gt;豆 瓣评分：8.7/10(from85,981users)&lt;/li&gt;&lt;li&gt;IMDB评分：7.8/10(from38,178users)&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="日志" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/"/>
    
      <category term="周电" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/%E5%91%A8%E7%94%B5/"/>
    
    
      <category term="电影" scheme="https://molunerfinn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>PicGo的star数破1000的心路历程</title>
    <link href="https://molunerfinn.com/note-for-picgo/"/>
    <id>https://molunerfinn.com/note-for-picgo/</id>
    <published>2018-06-14T15:28:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<p>大概半年前（2017年11月28日）我在GitHub上开源了一个基于<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>的开源桌面应用<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>。其出发点是为了改善我在写博客的时候贴图困难的问题。在经过了半年的持续维护和一些宣传（<a href="https://sspai.com/post/42310" target="_blank" rel="noopener">《PicGo：基于 Electron 的图片上传工具》</a>、<a href="https://sspai.com/post/44495" target="_blank" rel="noopener">《图床上传工具PicGo v1.5更新：支持腾讯云COSv5版本、支持GitHub图床、支持上传前重命名文件等等》</a>等等）后，6月12日，它的star数也终于突破了1000的关卡。在这过程中我也学习了不少东西。在和大家交流的过程中，我才发现原来大家都有着这些需求，才发现我一开始的实现思路并非到位等等。谨以此文记录与PicGo有关的我的心路历程。</p><blockquote><p>赶巧前不久也有一个开发者chyingp的开源项目破了1000star，也有着类似的<a href="https://juejin.im/post/5b1717a86fb9a01e3e5ce540" target="_blank" rel="noopener">文章</a>，祝贺！</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fs892cewamj21ks0emq5n.jpg" alt></p><a id="more"></a><h2 id="项目诞生"><a href="#项目诞生" class="headerlink" title="项目诞生"></a>项目诞生</h2><p>我以前写博客的时候，由于一开始用的是七牛的图床，所以遇到要在markdown里贴图的时候就必须登录七牛，然后手动上传图片，再找到按钮来复制链接，然后复制到markdown里。要在markdown里显示一张图片我得经过上述4个步骤。</p><p>我自己的笔记本用的是mac，所以我就接触到了一款叫做<a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">iPic</a>的图床神器。在用它的时候我也知道了微博图床。iPic的功能和体验真的特别好。不过如果需要使用七牛等其他图床的时候，我就需要付费了。其实如果iPic支持windows的话，我可能就真的去付费了。（因为实验室的电脑是windows，所以我平时在实验室里得用windows来写东西）。仅为mac一个平台付费我有点不能接受。</p><p>于是我就在想能否我自己写一个工具来简化我的上传图片的流程呢，这个应用可以实现拖拽图片就上传，然后上传完自动复制链接到剪贴板里，我就只要粘贴到markdown里就好了。一开始想用swift写mac的应用，用C#写windows的应用。后来发现工作量不仅大，而且学习成本也很高。于是最后还是选择投入electron的怀抱。</p><p>一开始不选择electron主要是因为我的印象中electron的应用体积都挺大的（100MB以上），所以感觉体积可能有点不友好。不过后来我在用了<code>electron-vue</code>打包出来后发现体积是可以接受的范围（mac端大概50M，windows端大概38M），于是就决定用它来写了。用<code>electron-vue</code>的主要原因是我写vue比较多，想要学习成本低一些，这样开发只要学electron的部分就好了。</p><p>说干就干，在去年年底（11月下旬）我开始写这个应用。</p><h2 id="项目发布"><a href="#项目发布" class="headerlink" title="项目发布"></a>项目发布</h2><blockquote><p>文末会给出electron-vue开发的系列经验教程</p></blockquote><p>经过20多天的间断性地开发，我在12月12号发布了1.0.0版本。由于一开始是在mac上开发的，所以1.0.0版本也只支持了macOS。一开始支持的图床也不多，只支持了微博和七牛两个图床。</p><p>1.0.0版本的截图如下：</p><p><img src="https://user-images.githubusercontent.com/12621342/34242310-b5056510-e655-11e7-8568-60ffd4f71910.gif" alt></p><p><img src="https://user-images.githubusercontent.com/12621342/34242857-d177930a-e658-11e7-9688-7405851dd5e5.gif" alt></p><p>基本实现了我预期的功能，类似iPic能够通过拖拽到顶部栏图标上传。并且为了今后支持windows平台（windows平台的任务栏图标不支持拖拽事件），我就做了一个主窗口，在主窗口里也有拖拽上传的区域。因为有了主窗口，我就顺便把图床的配置也放到了主窗口里。</p><p>应用做出来了，我也想让更多的人用到。于是我在北邮人论坛、cnode、v2ex还有掘金都发了文章。不过一开始看到的人寥寥无几，发了文章也没多少人看到和使用。后来我在少数派上发了同样的文章，意外地被推荐到了首页。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fmvr6uah8rj21z20vk7wh" alt></p><p>这次的契机让PicGo意外地有了些用户和star数。在跟使用者交流的过程中我也开始逐步往PicGo里加功能和修复bug。在1月10日的时候，PicGo更新v1.3.1版本支持了windows系统。</p><p>因为开始有用户了，PicGo早期确实存在着不少功能的缺失，比如<code>快捷键上传</code>，其他常用图床的缺失等等。所以那时候是PicGo迭代最快的一段时间。通过大家在issue里的反馈，我也在不断打磨PicGo。可以看到截止6月14日，已经有61个被关闭的issue了。</p><p><img src="https://i.loli.net/2018/06/14/5b2223c52853f.png" alt></p><h2 id="项目改进"><a href="#项目改进" class="headerlink" title="项目改进"></a>项目改进</h2><p>用户体验这个东西真的并不是开发者在开发的时候能够立马就想到的。这点在开发PicGo上我体会很深。</p><p>比如增加<code>快捷键上传</code>这个功能，我一开始觉得自定义快捷键写起来比较麻烦，干脆我定一个大家基本用不到的快捷键吧。于是我默认给了一个【command/ctrl+shift+p】的快捷键。我自己用的时候没有什么问题。结果有人给我反馈说，快捷键跟某某某软件冲突了，能否给一个快捷键自定义的功能。这是我无法回避的一个问题。于是我就开始去学习如何加入自定义快捷键。并在不久之后实现了个这个<a href="https://github.com/Molunerfinn/PicGo/commit/37a784225e90c9d115367f056957dac88ebcf816" target="_blank" rel="noopener">功能</a>。</p><p>比如自定义链接格式的问题。我一开始给了大家4种复制链接的格式，分别是<code>markdown</code>、<code>HTML</code>、<code>URL</code>、<code>UBB</code>。本来以为这4种格式就足够大家平时使用了。后来有人提了一个<a href="https://github.com/Molunerfinn/PicGo/issues/25" target="_blank" rel="noopener">issue</a>，问PicGo能否自定义链接格式，因为他想基于HTML增加一些属性，比如大小居中等。我觉得这个使用场景确实是有的，于是我便在后来的某个<a href="https://github.com/Molunerfinn/PicGo/commit/4010a09fe48d8109456c3c1b37695f177336f2e4" target="_blank" rel="noopener">提交</a>里实现了这个功能。</p><p>当然并不是大家有这个需求我就一定要做。还有一些需求我觉得并不符合我对于PicGo的定位的，那么我就会给予回绝。比如<a href="https://github.com/Molunerfinn/PicGo/issues/53" target="_blank" rel="noopener">后期能否支持上传视频文件？</a>，由于PicGo的开发初衷只针对图片，所以在流程上（图片-&gt;base64）就不允许上传视频文件。于是我拒绝了这个需求。</p><p>还有一个对我以及PicGo这个项目影响深远的<a href="https://github.com/Molunerfinn/PicGo/issues/26" target="_blank" rel="noopener">issue</a>，ZetaoYang提出了一个想法：</p><p><img src="https://i.loli.net/2018/06/14/5b2228f31219a.png" alt></p><p>这个建议改变了我对PicGo开发的后续想法。我思考了好久，发现确实一步步增加默认的图床支持是不长远的。一个是重复性劳动太多（图床上传除了协议和加密方式不同之外，接收文件，转成base64和最后上传成功后存到本地的流程是一样的），一个是无止尽的图床支持其实也不应该。相比之下，把PicGo做成一个Core+Plugin模式的应用会更好。其中Core的部分可以单独只做图片接收和转码，并预留一些生命周期，供上传过程中不同的需求来调用。Core的部分可以单独发布成一个npm包。Plugin可以实现接入Core的生命周期，可以实现自己的上传逻辑，可以实现图片压缩、加水印等等其他功能。而PicGo只是在Core+Plugin的基础上套了一层electron的皮方便普通用户使用，而Core和Plugin可以独立拆出方便开发者使用和开发。这个也是PicGo的2.0版本将要做的事。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在开发PicGo的过程中我也深刻了解到，写一个DEMO不难，给这个DEMO注入你自己的思想和灵魂是难的。PicGo从一个一开始只是我想简化上传图片流程的玩具应用，发展到现在已经是不少用户的效率工具而言，其实一路走来也并不容易。现在大家对用户体验的要求越来越高，如果只沉醉在自己的DEMO里无法自拔，只会被更好的产品所淘汰。</p><p>开发PicGo也是一件很开心的事。大家给予我的赞赏和感谢，都是给我继续开发的动力。而我也发现越来越多的文章里，都提到了PicGo。如下：</p><ul><li><a href="https://juejin.im/post/5af0021e518825671547926e" target="_blank" rel="noopener">《老司机的神兵利器-效率工具》</a></li><li><a href="https://imwyc.com/picgo/" target="_blank" rel="noopener">《PicGo 强大的免费图床工具》</a></li><li><a href="https://lai.yuweining.cn/archives/2035/" target="_blank" rel="noopener">《PicGo：开源的图片管理工具》</a></li><li><a href="https://blog.csdn.net/weixin_39200308/article/details/80644336" target="_blank" rel="noopener">《图床神器PicGo》</a></li><li><a href="https://zhuanlan.zhihu.com/p/37873730" target="_blank" rel="noopener">《提升生活品质——个人效率工具与资讯网站推荐》</a></li><li><a href="https://sspai.com/post/44150" target="_blank" rel="noopener">《7 款 Windows 国产软件推荐》</a></li></ul><p>我想，得到你们的认可，把它写进你们的文章，这是对我最大的肯定，这个比star数更令我感到开心。</p><p>我在开发PicGo的过程中，也写了一个系列文章<a href="https://molunerfinn.com/tags/Electron-vue/">Electron-vue开发实战</a>。如果你也想学习electron或者electron-vue的开发的话，希望我的文章能够给你带来帮助。如果你之前没有听说过PicGo，那么不妨试试；如果你觉得它挺好用的，不妨点个star~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概半年前（2017年11月28日）我在GitHub上开源了一个基于&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;的开源桌面应用&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;。其出发点是为了改善我在写博客的时候贴图困难的问题。在经过了半年的持续维护和一些宣传（&lt;a href=&quot;https://sspai.com/post/42310&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《PicGo：基于 Electron 的图片上传工具》&lt;/a&gt;、&lt;a href=&quot;https://sspai.com/post/44495&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《图床上传工具PicGo v1.5更新：支持腾讯云COSv5版本、支持GitHub图床、支持上传前重命名文件等等》&lt;/a&gt;等等）后，6月12日，它的star数也终于突破了1000的关卡。在这过程中我也学习了不少东西。在和大家交流的过程中，我才发现原来大家都有着这些需求，才发现我一开始的实现思路并非到位等等。谨以此文记录与PicGo有关的我的心路历程。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;赶巧前不久也有一个开发者chyingp的开源项目破了1000star，也有着类似的&lt;a href=&quot;https://juejin.im/post/5b1717a86fb9a01e3e5ce540&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;，祝贺！&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/8700af19ly1fs892cewamj21ks0emq5n.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>小记VSCode插件amVim的改进以及插件开发</title>
    <link href="https://molunerfinn.com/vscode-extension-develop-1/"/>
    <id>https://molunerfinn.com/vscode-extension-develop-1/</id>
    <published>2018-06-13T14:09:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间在Mac上用VSCode的时候，发现<code>VSCodeVim</code>这个插件严重拖慢了我的开发效率。本来用<code>Vim</code>模式难道不应该是提高效率么？问题是在<code>Normal</code>模式下，光标的移动会有肉眼可见的长延时。比如我按着<code>j</code>，等我松开<code>j</code>后，光标还在移动，而且还移动了一会儿。预期的效果应该是按下移动，松开停止。为此我查了一下相关<a href="https://github.com/VSCodeVim/Vim/issues/2021" target="_blank" rel="noopener">issue</a>，发现跟我一样的情况的人还不少。（不过也有不少人没有这个问题，貌似跟显卡有关系？我的mac是集显的）。</p><p>卸载了<code>VSCodeVim</code>之后，光标移动的速度又恢复了正常，不过没有<code>Vim</code>模式的话非常别扭。所以我就开始看看VSCode还有没有其他<code>Vim</code>模式的插件。于是我又试了另外两个插件：<a href="https://github.com/74th/vscode-vim" target="_blank" rel="noopener">vimStyle</a>和<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank" rel="noopener">amVim</a>。最终我选择了后者。不仅是支持的Vim命令更多，还有就是开发者的维护一直在继续。而且很关键的一点，<code>amVim</code>的光标移动体验就是 <strong>如丝般顺滑</strong> ！</p><p>不过它有个让我很不习惯的地方：不支持<code>:</code>号调起VSCode的<code>Command Line</code>窗口，实现诸如<code>:w</code>保存，<code>:wq</code>退出等常见功能。这些功能在<code>VSCodeVim</code>里是支持的。于是我就在想有没有办法「移植」一下<code>VSCodeVim</code>的功能到<code>amVim</code>来，既能保持光标移动体验顺滑，又能用上<code>Command Line</code>的一些常用命令。所以开启了魔改模式，并在跟开发者的一系列交流后最终我提交的PR被<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/199" target="_blank" rel="noopener">merge</a>了。<br><img src="https://i.loli.net/2018/06/06/5b179b533f190.png" alt><br>本文记录一下我第一次对VSCode插件（修改）开发的过程。</p><a id="more"></a><h2 id="修改插件"><a href="#修改插件" class="headerlink" title="修改插件"></a>修改插件</h2><h3 id="开发前的准备"><a href="#开发前的准备" class="headerlink" title="开发前的准备"></a>开发前的准备</h3><p>VSCode的插件通常是用<code>TypeScript</code>来写的。如果你需要开发或者修改它，先要拥有<code>TypeScript</code>的开发环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn global add typescript</span><br></pre></td></tr></table></figure><p>通常<code>TypeScript</code>的项目都会用上<code>tslint</code>。所以你也最好全局安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tslint</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn global add tslint</span><br></pre></td></tr></table></figure><p>然后打开VSCode，安装一下<code>tslint</code>这个插件，它将通过我们上面安装在系统里的<code>tslint</code>给我们的项目提供代码检查。</p><p>修改别人的插件，可以先<code>fork</code>一份别人的代码。也为了之后方便提PR做准备。</p><p>然后就可以把插件<code>clone</code>到本地了。比如本文的<a href="https://github.com/aioutecism/amVim-for-VSCode" target="_blank" rel="noopener">amVim-for-VSCode</a>。</p><h3 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h3><p>用VSCode打开这个项目，点击左侧的<code>debug</code>可以看到一个<code>launch extension</code>的配置：</p><p><img src="https://i.loli.net/2018/06/06/5b17a25905266.png" alt></p><p>运行它，你会得到另外一个窗口，这个就是可以调试插件功能的窗口了：</p><p><img src="https://i.loli.net/2018/06/06/5b17a2e5d0a1b.png" alt></p><h3 id="改进插件"><a href="#改进插件" class="headerlink" title="改进插件"></a>改进插件</h3><blockquote><p>我的改进源码在这里：<a href="https://github.com/Molunerfinn/amVim-for-VSCode" target="_blank" rel="noopener">https://github.com/Molunerfinn/amVim-for-VSCode</a> 作者合并之后做了一些修改，本文是以我的版本为主。</p></blockquote><p>为了实现<code>VSCodeVim</code>通过<code>:</code>调起VSCode的<code>inputBox</code>效果，我需要翻阅一下<code>VSCodeVim</code>的源代码。</p><p>大致效果如下：</p><p><img src="https://user-images.githubusercontent.com/12621342/40241750-61d5160c-5aee-11e8-9d21-6f96cbc4fa88.gif" alt></p><p>在查看了<code>amVim</code>和<code>VSCodeVim</code>在实现命令上的部分源码后，发现二者的实现上差距还是不小的。不过相比<code>VSCodeVim</code>代码的庞大（甚至还有neoVim的支持），<code>amVim</code>在实现上就比较精巧了。</p><p>在我的PR未被merge之前，<code>amVim</code>插件提供了一个功能，按<code>:</code>打开一个<code>GoToLine</code>的<code>inputBox</code>：</p><p><img src="https://i.loli.net/2018/06/06/5b17a73b1bf15.png" alt></p><p>不过只能用于输入数字并跳转到相应行数。好在查看release更新日志，追溯这个<a href="https://github.com/aioutecism/amVim-for-VSCode/pull/192" target="_blank" rel="noopener">commit</a>，我们可以很容易找到它是如何实现的。</p><p><img src="https://i.loli.net/2018/06/06/5b17aa66c2030.png" alt></p><p>代码不多，就几行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Modes/Normal.ts</span></span><br><span class="line">&#123; <span class="attr">keys</span>: <span class="string">':'</span>, <span class="attr">actions</span>: [ActionCommand.goToLine] &#125;, <span class="comment">// 增加`:`打开GoToLine的inputBox的快捷键</span></span><br></pre></td></tr></table></figure><p>具体实现代码如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Actions/Command.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123;commands&#125; <span class="keyword">from</span> <span class="string">'vscode'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> goToLine(): Thenable&lt;boolean | <span class="literal">undefined</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> commands.executeCommand(<span class="string">'workbench.action.gotoLine'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以是通过<code>vscode</code>的<code>commands</code>来打开的<code>gotoLine</code>的<code>inputBox</code>窗口。</p><p>再来看看<code>VSCodeVim</code>是如何打开<code>inputBox</code>的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd_line/commandLine.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CommandLine &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> PromptAndRun(initialText: <span class="built_in">string</span>, vimState: VimState): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vscode.window.activeTextEditor) &#123;</span><br><span class="line">      Logger.debug(<span class="string">'CommandLine: No active document'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cmd = <span class="keyword">await</span> vscode.window.showInputBox(<span class="keyword">this</span>.getInputBoxOptions(initialText)); <span class="comment">// 通过showInputBox打开</span></span><br><span class="line">    <span class="keyword">if</span> (cmd &amp;&amp; cmd[<span class="number">0</span>] === <span class="string">':'</span> &amp;&amp; configuration.cmdLineInitialColon) &#123;</span><br><span class="line">      cmd = cmd.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._history.add(cmd);</span><br><span class="line">    <span class="keyword">this</span>._history.save();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> CommandLine.Run(cmd!, vimState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> getInputBoxOptions(text: <span class="built_in">string</span>): vscode.InputBoxOptions &#123; <span class="comment">// inputBox的Options</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      prompt: <span class="string">'Vim command line'</span>,</span><br><span class="line">      value: configuration.cmdLineInitialColon ? <span class="string">':'</span> + text : text,</span><br><span class="line">      ignoreFocusOut: <span class="literal">false</span>,</span><br><span class="line">      valueSelection: [</span><br><span class="line">        configuration.cmdLineInitialColon ? text.length + <span class="number">1</span> : text.length,</span><br><span class="line">        configuration.cmdLineInitialColon ? text.length + <span class="number">1</span> : text.length,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到关键的部分是通过<code>vscode.window.showInputBox</code>打开的<code>inputBox</code>。所以我也根据这个关键的入口来一步步实现我想要的功能。</p><h4 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h4><p>参考<code>VSCodeVim</code>的实现，在<code>amVim</code>里可以大概分四个部分：</p><ol><li><code>src/Modes/Normal.ts</code>作为入口文件，当用户输入<code>:</code>键时触发后续功能。【已有】</li><li><code>src/Actions/CommandLine/CommandLine.ts</code>作为打开<code>inputBox</code>的入口函数，打开<code>inputBox</code>，然后负责把用户输入的内容传给下一级的<code>parser</code>，用于解析并执行相应命令。</li><li><code>src/Actions/CommandLine/Parser.ts</code>，负责接收上一级传进来的命令，然后找到命令对应的函数，并执行该函数。如果找不到相应则返回。</li><li><code>src/Actions/CommandLine/Commands/*</code>，存放各个命令的实现函数。</li></ol><p>其中<code>src/Actions/CommandLine/CommandLine.ts</code>的逻辑跟<code>VSCodeVim</code>的<code>src/cmd_line/commandLine.ts</code>非常类似。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ol><li>src/Actions/CommandLine/CommandLine.ts</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">'vscode'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; parser &#125; <span class="keyword">from</span> <span class="string">'./Parser'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CommandLine &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Run(command: <span class="built_in">string</span> | <span class="literal">undefined</span>): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!command || command.length === <span class="number">0</span>) &#123; <span class="comment">// 如果命令为空则直接返回</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> cmd = parser(command); <span class="comment">// 将命令传给parser并返回一个可执行的函数</span></span><br><span class="line">          <span class="keyword">if</span> (cmd) &#123;</span><br><span class="line">              <span class="keyword">await</span> cmd.execute(command); <span class="comment">// 调用该函数的execute方法</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> PromptAndRun(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vscode.window.activeTextEditor) &#123; <span class="comment">// 如果当前没有打开的激活的文本，则命令不执行，返回空。</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> cmd = <span class="keyword">await</span> vscode.window.showInputBox(CommandLine.getInputBoxOptions()); <span class="comment">// 打开inputBox</span></span><br><span class="line">          <span class="keyword">if</span> (cmd &amp;&amp; cmd[<span class="number">0</span>] === <span class="string">':'</span>) &#123;</span><br><span class="line">              cmd = cmd.slice(<span class="number">1</span>); <span class="comment">// 如果命令带有:则将它去掉并传给parser</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">await</span> CommandLine.Run(cmd);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> getInputBoxOptions(): vscode.InputBoxOptions &#123; <span class="comment">// 打开的inputBox框里的文本和一些其他配置</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          prompt: <span class="string">'Vim command line'</span>,</span><br><span class="line">          value: <span class="string">':'</span>,</span><br><span class="line">          ignoreFocusOut: <span class="literal">false</span>,</span><br><span class="line">          valueSelection: [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>src/Actions/CommandLine/Parser.ts</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CommandBase &#125; <span class="keyword">from</span> <span class="string">'./Commands/Base'</span>;</span><br><span class="line"><span class="keyword">import</span> WriteCommand <span class="keyword">from</span> <span class="string">'./Commands/Write'</span>;</span><br><span class="line"><span class="keyword">import</span> WallCommand <span class="keyword">from</span> <span class="string">'./Commands/WriteAll'</span>;</span><br><span class="line"><span class="keyword">import</span> QuitCommand <span class="keyword">from</span> <span class="string">'./Commands/Quit'</span>;</span><br><span class="line"><span class="keyword">import</span> QuitAllCommand <span class="keyword">from</span> <span class="string">'./Commands/QuitAll'</span>;</span><br><span class="line"><span class="keyword">import</span> WriteQuitCommand <span class="keyword">from</span> <span class="string">'./Commands/WriteQuit'</span>;</span><br><span class="line"><span class="keyword">import</span> WriteQuitAllCommand <span class="keyword">from</span> <span class="string">'./Commands/WriteQuitAll'</span>;</span><br><span class="line"><span class="keyword">import</span> VisualSplitCommand <span class="keyword">from</span> <span class="string">'./Commands/VisualSplit'</span>;</span><br><span class="line"><span class="keyword">import</span> NewFileCommand <span class="keyword">from</span> <span class="string">'./Commands/NewFile'</span>;</span><br><span class="line"><span class="keyword">import</span> VerticalNewFileCommand <span class="keyword">from</span> <span class="string">'./Commands/VerticalNewFile'</span>;</span><br><span class="line"><span class="keyword">import</span> GoToLineCommand <span class="keyword">from</span> <span class="string">'./Commands/GoToLine'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commandParsers = &#123; <span class="comment">// 对于命令的解析，用哈希表做映射</span></span><br><span class="line">    w: WriteCommand,</span><br><span class="line">    write: WriteCommand,</span><br><span class="line">    wa: WallCommand,</span><br><span class="line">    wall: WallCommand,</span><br><span class="line"></span><br><span class="line">    q: QuitCommand,</span><br><span class="line">    quit: QuitCommand,</span><br><span class="line">    qa: QuitAllCommand,</span><br><span class="line">    qall: QuitAllCommand,</span><br><span class="line"></span><br><span class="line">    wq: WriteQuitCommand,</span><br><span class="line">    x: WriteQuitCommand,</span><br><span class="line"></span><br><span class="line">    wqa: WriteQuitAllCommand,</span><br><span class="line">    wqall: WriteQuitAllCommand,</span><br><span class="line">    xa: WriteQuitAllCommand,</span><br><span class="line">    xall: WriteQuitAllCommand,</span><br><span class="line"></span><br><span class="line">    vs: VisualSplitCommand,</span><br><span class="line">    vsp: VisualSplitCommand,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span>: NewFileCommand,</span><br><span class="line">    vne: VerticalNewFileCommand,</span><br><span class="line">    vnew: VerticalNewFileCommand</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parser</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">CommandBase</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (commandParsers[input]) &#123;</span><br><span class="line">        <span class="keyword">return</span> commandParsers[input]; <span class="comment">// 接收inputBox里传来的命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Number</span>.isInteger(<span class="built_in">Number</span>(input))) &#123;</span><br><span class="line">        <span class="keyword">return</span> GoToLineCommand;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>命令的实现</li></ol><p>由于命令很多，我就举三个例子。一个是<code>w</code>，一个是<code>q</code>，和一个<code>wq</code>。VSCode自己的一些功能比如关闭当前文件、保存文件等都是有自己的command的。在实现Vim模式的时候，实际上最后也是去调用VSCode自带的功能而已。</p><h5 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">'vscode'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandBase &#125; <span class="keyword">from</span> <span class="string">'./Base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> WriteCommand <span class="keyword">extends</span> CommandBase &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> execute(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123; <span class="comment">// 暴露execute方法用于调用</span></span><br><span class="line">    <span class="keyword">await</span> vscode.commands.executeCommand(<span class="string">'workbench.action.files.save'</span>); <span class="comment">// 调用vscode的命令保存文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> WriteCommand();</span><br></pre></td></tr></table></figure><h5 id="Quit"><a href="#Quit" class="headerlink" title="Quit"></a>Quit</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">'vscode'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CommandBase &#125; <span class="keyword">from</span> <span class="string">'./Base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> QuitCommand <span class="keyword">extends</span> CommandBase &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> execute(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> vscode.commands.executeCommand(<span class="string">'workbench.action.closeActiveEditor'</span>); <span class="comment">// 调用vscode的命令关闭当前的文件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> QuitCommand();</span><br></pre></td></tr></table></figure><h5 id="WriteQuit"><a href="#WriteQuit" class="headerlink" title="WriteQuit"></a>WriteQuit</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CommandBase &#125; <span class="keyword">from</span> <span class="string">'./Base'</span>;</span><br><span class="line"><span class="keyword">import</span> WriteCommand <span class="keyword">from</span> <span class="string">'./Write'</span>;</span><br><span class="line"><span class="keyword">import</span> QuitCommand <span class="keyword">from</span> <span class="string">'./Quit'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> WriteQuitCommand <span class="keyword">extends</span> CommandBase &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> execute(): <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> WriteCommand.execute();</span><br><span class="line">    <span class="keyword">await</span> QuitCommand.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> WriteQuitCommand();</span><br></pre></td></tr></table></figure><p>这一步就很有意思了，因为我们之前实现了<code>Write</code>和<code>Quit</code>的功能，所以可以在这里调用它们。看到这里你可能会有问题，虽然我知道VSCode有这些功能，但是你是怎么知道这些功能是怎么写的呢？</p><p>如果只是我这篇文章的话，我在实现Vim模式的这些命令的时候，大部分是参考了<code>VSCodeVim</code>的一些写法。它主要的命令实现在<code>src/cmd_line/commands/*</code>里。但是只这样显然还是不够的。因此我给出几个比较有用的地方供大家开发插件的时候参考：</p><ol><li>VSCode官方文档里的<a href="https://code.visualstudio.com/docs/extensions/overview" target="_blank" rel="noopener">Extending Visual Studio Code</a>，介绍扩展VSCode的原理和给出了一些例子。</li><li>VSCode官方文档里的<a href="https://code.visualstudio.com/docs/extensionAPI/overview" target="_blank" rel="noopener">Extensibility Reference</a>，介绍VSCode扩展的api文档。</li><li>VSCode官方文档里的<a href="https://code.visualstudio.com/docs/getstarted/keybindings" target="_blank" rel="noopener">Key Bindings for Visual Studio Code</a>，介绍VSCode的快捷键和相应的<strong>命令id</strong>。</li><li>VSCode本身的快捷键编辑面板：<br><img src="https://i.loli.net/2018/06/13/5b20c5d23fda2.png" alt></li></ol><p>说实话VSCode的文档写得不是特别好。我要实现一个功能，查找文档查了半天。其实其中很大一部分操作，你可以在上面的第3点、第4点里通过快捷键的提供的<code>Command id</code>去实现：</p><p><img src="https://i.loli.net/2018/06/13/5b20c6a5bcccd.png" alt></p><p>比如你要实现一个剪切的功能，有了<code>Command id</code>，你就可以通过<code>vscode.commands.executeCommand(&#39;editor.action.clipboardCutAction&#39;)</code>来实现。因此我推荐，如果你要实现的功能有些可以用已有快捷键实现的，那么就能在这个列表里找到对应的<code>Command id</code>来手动实现了。</p><p>至于其他的一些非快捷键提供的功能，就还需要阅读第2点的api文档做出更深层次的修改了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在改进完这个插件之后，我向作者提交了PR。在和作者交流后做出了一些修改，并最终被作者接受并合并。为开源项目贡献代码的感觉是真的很不错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间在Mac上用VSCode的时候，发现&lt;code&gt;VSCodeVim&lt;/code&gt;这个插件严重拖慢了我的开发效率。本来用&lt;code&gt;Vim&lt;/code&gt;模式难道不应该是提高效率么？问题是在&lt;code&gt;Normal&lt;/code&gt;模式下，光标的移动会有肉眼可见的长延时。比如我按着&lt;code&gt;j&lt;/code&gt;，等我松开&lt;code&gt;j&lt;/code&gt;后，光标还在移动，而且还移动了一会儿。预期的效果应该是按下移动，松开停止。为此我查了一下相关&lt;a href=&quot;https://github.com/VSCodeVim/Vim/issues/2021&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt;，发现跟我一样的情况的人还不少。（不过也有不少人没有这个问题，貌似跟显卡有关系？我的mac是集显的）。&lt;/p&gt;&lt;p&gt;卸载了&lt;code&gt;VSCodeVim&lt;/code&gt;之后，光标移动的速度又恢复了正常，不过没有&lt;code&gt;Vim&lt;/code&gt;模式的话非常别扭。所以我就开始看看VSCode还有没有其他&lt;code&gt;Vim&lt;/code&gt;模式的插件。于是我又试了另外两个插件：&lt;a href=&quot;https://github.com/74th/vscode-vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vimStyle&lt;/a&gt;和&lt;a href=&quot;https://github.com/aioutecism/amVim-for-VSCode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;amVim&lt;/a&gt;。最终我选择了后者。不仅是支持的Vim命令更多，还有就是开发者的维护一直在继续。而且很关键的一点，&lt;code&gt;amVim&lt;/code&gt;的光标移动体验就是 &lt;strong&gt;如丝般顺滑&lt;/strong&gt; ！&lt;/p&gt;&lt;p&gt;不过它有个让我很不习惯的地方：不支持&lt;code&gt;:&lt;/code&gt;号调起VSCode的&lt;code&gt;Command Line&lt;/code&gt;窗口，实现诸如&lt;code&gt;:w&lt;/code&gt;保存，&lt;code&gt;:wq&lt;/code&gt;退出等常见功能。这些功能在&lt;code&gt;VSCodeVim&lt;/code&gt;里是支持的。于是我就在想有没有办法「移植」一下&lt;code&gt;VSCodeVim&lt;/code&gt;的功能到&lt;code&gt;amVim&lt;/code&gt;来，既能保持光标移动体验顺滑，又能用上&lt;code&gt;Command Line&lt;/code&gt;的一些常用命令。所以开启了魔改模式，并在跟开发者的一系列交流后最终我提交的PR被&lt;a href=&quot;https://github.com/aioutecism/amVim-for-VSCode/pull/199&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;merge&lt;/a&gt;了。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/06/06/5b179b533f190.png&quot; alt&gt;&lt;br&gt;本文记录一下我第一次对VSCode插件（修改）开发的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
      <category term="TypeScript" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/TypeScript/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
      <category term="TypeScript" scheme="https://molunerfinn.com/tags/TypeScript/"/>
    
      <category term="VSCode" scheme="https://molunerfinn.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>基于Koa2开发微信二维码扫码支付相关流程</title>
    <link href="https://molunerfinn.com/koa2-wechatpay/"/>
    <id>https://molunerfinn.com/koa2-wechatpay/</id>
    <published>2018-05-15T13:50:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在开发一个功能，要求是通过微信二维码进行扫码支付。这个情景我们屡见不鲜了，各种电子商城、线下的自动贩卖机等等都会有这个功能。平时只是使用者，如今变为开发者，也是有不小的坑。所以特此写一篇博客记录一下。</p><blockquote><p><strong>注</strong>： 要开发微信二维码支付，你必须要有相应的商户号的权限，否则你是无法开发的。若无相应权限，本文不推荐阅读。</p></blockquote><a id="more"></a><h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p>打开微信支付的文档，我们可以看到两种支付模式：<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_4" target="_blank" rel="noopener">模式一</a>和<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5" target="_blank" rel="noopener">模式二</a>。这二者的流程图微信的文档里都给出了（不过说实话画得真的有点丑）。</p><p>文档里指出了二者的区别：</p><blockquote><p>模式一开发前，商户必须在公众平台后台设置支付回调URL。URL实现的功能：接收用户扫码后微信支付系统回调的productid和openid。</p></blockquote><blockquote><p>模式二与模式一相比，流程更为简单，不依赖设置的回调支付URL。商户后台系统先调用微信支付的统一下单接口，微信后台系统返回链接参数code_url，商户后台系统将code_url值生成二维码图片，用户使用微信客户端扫码后发起支付。注意：code_url有效期为2小时，过期后扫码不能再发起支付。</p></blockquote><p>模式一是我们平时在网购的时候比较常见的，会弹出一个专门的页面用于扫码支付，然后支付成功后这个页面会再次跳转回回调页面，通知你支付成功。第二种的话想对少一些，不过第二种开发起来相对简单点。<strong>本文主要介绍模式二的开发</strong>。</p><h2 id="搭建Koa2的简单开发环境"><a href="#搭建Koa2的简单开发环境" class="headerlink" title="搭建Koa2的简单开发环境"></a>搭建Koa2的简单开发环境</h2><p>快速搭建Koa2的开发环境我推荐可以使用<a href="https://github.com/17koa/koa-generator" target="_blank" rel="noopener">koa-generator</a>。脚手架能帮我们省去Koa项目一开始的一些基本中间件的书写步骤。（如果你想学习Koa最好自己搭建一个。如果你已经会Koa了就可以使用一些快速脚手架了。）</p><p>首先全局安装<code>koa-generator</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g koa-generator</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">yarn global add koa-generator</span><br></pre></td></tr></table></figure><p>然后找一个目录用来存放Koa项目，我们打算给这个项目取个名字叫做<code>koa-wechatpay</code>，然后就可以输入<code>koa2 koa-wechatpay</code>。然后脚手架会自动创建相应文件夹<code>koa-wechatpay</code>，并生成基本骨架。进入这个文件夹，安装相应的插件。输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">yarn</span><br></pre></td></tr></table></figure><p>接着你可以输入<code>npm start</code> 或者 <code>yarn start</code>来运行项目（默认监听在3000端口）。</p><p>如果不出意外，你的项目跑起来了，然后我们用postman测试一下：</p><blockquote><p>这条路由是在<code>routes/index.js</code>里。</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1frc14ddfn9j21iq0r2n0p.jpg" alt></p><p>如果你看到了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"koa2 json"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就说明没问题。（如果有问题，检查一下是不是端口被占用了等等。）</p><p>接下来在<code>routes</code>文件夹里我们新建一个<code>wechatpay.js</code>的文件用来书写我们的流程。</p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>跟微信的服务器交流很关键的一环是签名必须正确，如果签名不正确，那么一切都白搭。</p><p>首先我们需要去公众号的后台获取我们所需要的如下相应的id或者key的信息。其中<code>notify_url</code>和<code>server_ip</code>是用于当我们支付成功后，微信会主动往这个url<code>post</code>支付成功的信息。</p><p>签名算法如下：<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3" target="_blank" rel="noopener">https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3</a></p><p>为了签名正确，我们需要安装一下<code>md5</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install md5 --save</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">yarn add md5</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">'md5'</span>)</span><br><span class="line"><span class="keyword">const</span> appid = <span class="string">'xxx'</span></span><br><span class="line"><span class="keyword">const</span> mch_id = <span class="string">'yyy'</span></span><br><span class="line"><span class="keyword">const</span> mch_api_key = <span class="string">'zzz'</span></span><br><span class="line"><span class="keyword">const</span> notify_url = <span class="string">'http://xxx/api/notify'</span> <span class="comment">// 服务端可访问的域名和接口</span></span><br><span class="line"><span class="keyword">const</span> server_ip = <span class="string">'xx.xx.xx.xx'</span> <span class="comment">// 服务端的ip地址</span></span><br><span class="line"><span class="keyword">const</span> trade_type = <span class="string">'NATIVE'</span> <span class="comment">// NATIVE对应的是二维码扫码支付</span></span><br><span class="line"><span class="keyword">let</span> body = <span class="string">'XXX的充值支付'</span> <span class="comment">// 用于显示在支付界面的提示词</span></span><br></pre></td></tr></table></figure><p>然后开始写签名函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> signString = <span class="function">(<span class="params">fee, ip, nonce</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tempString = <span class="string">`appid=<span class="subst">$&#123;appid&#125;</span>&amp;body=<span class="subst">$&#123;body&#125;</span>&amp;mch_id=<span class="subst">$&#123;mch_id&#125;</span>&amp;nonce_str=<span class="subst">$&#123;nonce&#125;</span>&amp;notify_url=<span class="subst">$&#123;notify_url&#125;</span>&amp;out_trade_no=<span class="subst">$&#123;nonce&#125;</span>&amp;spbill_create_ip=<span class="subst">$&#123;ip&#125;</span>&amp;total_fee=<span class="subst">$&#123;fee&#125;</span>&amp;trade_type=<span class="subst">$&#123;trade_type&#125;</span>&amp;key=<span class="subst">$&#123;mch_api_key&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> md5(tempString).toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>fee</code>是要充值的费用，以分为单位。比如要充值1块钱，<code>fee</code>就是100。ip是个比较随意的选项，只要符合规则的ip经过测试都是可以的，下文里我用的是<code>server_ip</code>。<code>nonce</code>就是微信要求的不重复的32位以内的字符串，通常可以使用订单号等唯一标识的字符串。</p><p>由于跟微信的服务器交流都是用xml来交流，所以现在我们要手动组装一下post请求的<code>xml</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xmlBody = <span class="function">(<span class="params">fee, nonce_str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> xml = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;xml&gt;</span></span><br><span class="line"><span class="string">    &lt;appid&gt;<span class="subst">$&#123;appid&#125;</span>&lt;/appid&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;<span class="subst">$&#123;body&#125;</span>&lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;mch_id&gt;<span class="subst">$&#123;mch_id&#125;</span>&lt;/mch_id&gt;</span></span><br><span class="line"><span class="string">    &lt;nonce_str&gt;<span class="subst">$&#123;nonce_str&#125;</span>&lt;/nonce_str&gt;</span></span><br><span class="line"><span class="string">    &lt;notify_url&gt;<span class="subst">$&#123;notify_url&#125;</span>&lt;/notify_url&gt;</span></span><br><span class="line"><span class="string">    &lt;out_trade_no&gt;<span class="subst">$&#123;nonce_str&#125;</span>&lt;/out_trade_no&gt;</span></span><br><span class="line"><span class="string">    &lt;total_fee&gt;<span class="subst">$&#123;fee&#125;</span>&lt;/total_fee&gt;</span></span><br><span class="line"><span class="string">    &lt;spbill_create_ip&gt;<span class="subst">$&#123;server_ip&#125;</span>&lt;/spbill_create_ip&gt;</span></span><br><span class="line"><span class="string">    &lt;trade_type&gt;NATIVE&lt;/trade_type&gt;</span></span><br><span class="line"><span class="string">    &lt;sign&gt;<span class="subst">$&#123;signString(fee, server_ip, nonce_str)&#125;</span>&lt;/sign&gt;</span></span><br><span class="line"><span class="string">    &lt;/xml&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    xml,</span><br><span class="line">    out_trade_no: nonce_str</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你怕自己的签名的<code>xml</code>串有问题，可以提前在微信提供的<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=20_1" target="_blank" rel="noopener">签名校验工具</a>里先校验一遍，看看是否能通过。</p></blockquote><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>因为需要跟微信服务端发请求，所以我选择了<code>axios</code>这个在浏览器端和node端都能发起ajax请求的库。</p><p>安装过程不再赘述。继续在<code>wechatpay.js</code>写发请求的逻辑。</p><p>由于微信给我们返回的也将是一个xml格式的字符串。所以我们需要预先写好解析函数，将xml解析成js对象。为此你可以安装一个<a href="https://github.com/Leonidas-from-XIV/node-xml2js" target="_blank" rel="noopener">xml2js</a>。安装过程跟上面的类似，不再赘述。</p><p>微信会给我们返回一个诸如下面格式的<code>xml</code>字符串：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span><span class="tag">&lt;<span class="name">return_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span class="tag">&lt;/<span class="name">return_code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">return_msg</span>&gt;</span>&lt;![CDATA[OK]]&gt;<span class="tag">&lt;/<span class="name">return_msg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appid</span>&gt;</span>&lt;![CDATA[wx742xxxxxxxxxxxxx]]&gt;<span class="tag">&lt;/<span class="name">appid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mch_id</span>&gt;</span>&lt;![CDATA[14899xxxxx]]&gt;<span class="tag">&lt;/<span class="name">mch_id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nonce_str</span>&gt;</span>&lt;![CDATA[R69QXXXXXXXX6O]]&gt;<span class="tag">&lt;/<span class="name">nonce_str</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sign</span>&gt;</span>&lt;![CDATA[79F0891XXXXXX189507A184XXXXXXXXX]]&gt;<span class="tag">&lt;/<span class="name">sign</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result_code</span>&gt;</span>&lt;![CDATA[SUCCESS]]&gt;<span class="tag">&lt;/<span class="name">result_code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prepay_id</span>&gt;</span>&lt;![CDATA[wx152316xxxxxxxxxxxxxxxxxxxxxxxxxxx]]&gt;<span class="tag">&lt;/<span class="name">prepay_id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">trade_type</span>&gt;</span>&lt;![CDATA[NATIVE]]&gt;<span class="tag">&lt;/<span class="name">trade_type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code_url</span>&gt;</span>&lt;![CDATA[weixin://wxpay/xxxurl?pr=dQNakHH]]&gt;<span class="tag">&lt;/<span class="name">code_url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们的目标是转为如下的js对象，好让我们用js来操作数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  return_code: <span class="string">'SUCCESS'</span>, <span class="comment">// SUCCESS 或者 FAIL</span></span><br><span class="line">  return_msg: <span class="string">'OK'</span>,</span><br><span class="line">  appid: <span class="string">'wx742xxxxxxxxxxxxx'</span>,</span><br><span class="line">  mch_id: <span class="string">'14899xxxxx'</span>,</span><br><span class="line">  nonce_str: <span class="string">'R69QXXXXXXXX6O'</span>,</span><br><span class="line">  sign: <span class="string">'79F0891XXXXXX189507A184XXXXXXXXX'</span>,</span><br><span class="line">  result_code: <span class="string">'SUCCESS'</span>,</span><br><span class="line">  prepay_id: <span class="string">'wx152316xxxxxxxxxxxxxxxxxxxxxxxxxxx'</span>,</span><br><span class="line">  trade_type: <span class="string">'NATIVE'</span>,</span><br><span class="line">  code_url: <span class="string">'weixin://wxpay/xxxurl?pr=dQNakHH'</span> <span class="comment">// 用于生成支付二维码的链接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们写一个函数，调用<code>xml2js</code>来解析xml：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将XML转为JS对象</span></span><br><span class="line"><span class="keyword">const</span> parseXML = <span class="function">(<span class="params">xml</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    xml2js.parseString(xml, &#123;<span class="attr">trim</span>: <span class="literal">true</span>, <span class="attr">explicitArray</span>: <span class="literal">false</span>&#125;, (err, json) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        rej(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res(json.xml)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码返回了一个<code>Promise</code>对象，因为<code>xml2js</code>的操作是在回调函数里返回的结果，所以为了配合Koa2的<code>async</code>、<code>await</code>，我们可以将其封装成一个<code>Promise</code>对象，将解析完的结果通过<code>resolve</code>返回回去。这样就能用<code>await</code>来取数据了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'https://api.mch.weixin.qq.com/pay/unifiedorder'</span> <span class="comment">// 微信服务端地址</span></span><br><span class="line"><span class="keyword">const</span> pay = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> form = ctx.request.body <span class="comment">// 通过前端传来的数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> orderNo = <span class="string">'XXXXXXXXXXXXXXXX'</span> <span class="comment">// 不重复的订单号</span></span><br><span class="line">  <span class="keyword">const</span> fee = form.fee <span class="comment">// 通过前端传来的费用值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = xmlBody(fee, orderNo) <span class="comment">// fee是费用，orderNo是订单号（唯一）</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios.post(url, &#123;</span><br><span class="line">    data: data.xml</span><br><span class="line">  &#125;).then(<span class="keyword">async</span> res =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> resJson = <span class="keyword">await</span> parseXML(res.data)</span><br><span class="line">    <span class="keyword">return</span> resJson <span class="comment">// 拿到返回的数据</span></span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (res.return_code === <span class="string">'SUCCESS'</span>) &#123; <span class="comment">// 如果返回的</span></span><br><span class="line">    <span class="keyword">return</span> ctx.body = &#123;</span><br><span class="line">      success: <span class="literal">true</span>,</span><br><span class="line">      message: <span class="string">'请求成功'</span>,</span><br><span class="line">      code_url: res.code_url, <span class="comment">// code_url就是用于生成支付二维码的链接</span></span><br><span class="line">      order_no: orderNo <span class="comment">// 订单号</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    success: <span class="literal">false</span>,</span><br><span class="line">    message: <span class="string">'请求失败'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/api/pay'</span>, pay)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><p>然后我们要将这个router挂载到根目录的<code>app.js</code>里去。</p><p>找到之前默认的两个路由，一个<code>index</code>，一个<code>user</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>)</span><br><span class="line"><span class="keyword">const</span> users = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>)</span><br><span class="line"><span class="keyword">const</span> wechatpay = <span class="built_in">require</span>(<span class="string">'./routes/wechatpay'</span>) <span class="comment">// 加在这里</span></span><br></pre></td></tr></table></figure><p>然后到页面底下挂载这个路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes</span></span><br><span class="line">app.use(index.routes(), index.allowedMethods())</span><br><span class="line">app.use(users.routes(), users.allowedMethods())</span><br><span class="line">app.use(wechatpay.routes(), users.allowedMethods()) <span class="comment">// 加在这里</span></span><br></pre></td></tr></table></figure><p>于是你就可以通过发送<code>/api/pay</code>来请求二维码数据啦。（如果有跨域需要自己考虑解决跨域方案，可以跟Koa放在同域里，也可以开一层proxy来转发，也可以开CORS头等等）</p><p><strong>注意</strong>， 本例里是用前端来生成二维码，其实也可以通过后端生成二维码，然后再返回给前端。不过为了简易演示，本例采用前端通过获取<code>code_url</code>后，在前端生成二维码。</p><h2 id="展示支付二维码"><a href="#展示支付二维码" class="headerlink" title="展示支付二维码"></a>展示支付二维码</h2><p>前端我用的是<code>Vue</code>，当然你可以选择你喜欢的前端框架。这里关注点在于通过拿到刚才后端传过来的<code>code_url</code>来生成二维码。</p><p>在前端，我使用的是<a href="https://github.com/xkeshi/vue-qrcode" target="_blank" rel="noopener">@xkeshi/vue-qrcode</a>这个库来生成二维码。它调用特别简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueQrcode <span class="keyword">from</span> <span class="string">'@xkeshi/vue-qrcode'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    VueQrcode</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在前端里用<code>&lt;vue-qrcode&gt;</code>的组件来生成二维码了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vue-qrcode</span> <span class="attr">:value</span>=<span class="string">"codeUrl"</span> <span class="attr">:options</span>=<span class="string">"&#123; size: 200 &#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>放到Dialog里就是这样的效果：</p><blockquote><p>文本是我自己添加的</p></blockquote><p><img src="http://mofinn123-1251750343.costj.myqcloud.com/wechat-pay.png" alt></p><h2 id="付款成功自动刷新页面"><a href="#付款成功自动刷新页面" class="headerlink" title="付款成功自动刷新页面"></a>付款成功自动刷新页面</h2><p>有两种将支付成功写入数据库的办法。</p><p>一种是在打开了扫码对话框后，不停向微信服务端轮询支付结果，如果支付成功，那么就向后端发起请求，告诉后端支付成功，让后端写入数据库。</p><p>一种是后端一直开着接口，等微信主动给后端的<code>notify_url</code>发起post请求，告诉后端支付结果，让后端写入数据库。然后此时前端向后端轮询的时候应该是去数据库取轮询该订单的支付结果，如果支付成功就关闭Dialog。</p><p>第一种比较简单但是不安全：试想万一用户支付成功的同时关闭了页面，或者用户支付成功了，但是网络有问题导致前端没法往后端发支付成功的结果，那么后端就一直没办法写入支付成功的数据。</p><p>第二种虽然麻烦，但是保证了安全。所有的支付结果都必须等微信主动向后端通知，后端存完数据库后再返回给前端消息。这样哪怕用户支付成功的同时关闭了页面，下次再打开的时候，由于数据库已经写入了，所以拿到的也是支付成功的结果。</p><p>所以<code>付款成功自动刷新页面</code>这个部分我们分为两个部分来说：</p><h3 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h3><p>Vue的data部分<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  payStatus: <span class="literal">false</span>, <span class="comment">// 未支付成功</span></span><br><span class="line">  retryCount: <span class="number">0</span>, <span class="comment">// 轮询次数，从0-200</span></span><br><span class="line">  orderNo: <span class="string">'xxx'</span>, <span class="comment">// 从后端传来的order_no</span></span><br><span class="line">  codeUrl: <span class="string">'xxx'</span> <span class="comment">// 从后端传来的code_url</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在methods里写一个查询订单信息的方法：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">handleCheckBill () &#123;</span><br><span class="line">  <span class="keyword">return</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.payStatus &amp;&amp; <span class="keyword">this</span>.retryCount &lt; <span class="number">120</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.retryCount += <span class="number">1</span></span><br><span class="line">      axios.post(<span class="string">'/api/check-bill'</span>, &#123; <span class="comment">// 向后端请求订单支付信息</span></span><br><span class="line">        orderNo: <span class="keyword">this</span>.orderNo</span><br><span class="line">      &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.data.success) &#123;</span><br><span class="line">            <span class="keyword">this</span>.payStatus = <span class="literal">true</span></span><br><span class="line">            location.reload() <span class="comment">// 偷懒就用reload重新刷新页面</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleCheckBill()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      location.reload()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在打开二维码Dialog的时候，这个方法就启用了。然后就开始轮询。我订了一个时间，200s后如果还是没有付款信息也自动刷新页面。实际上你可以自己根据项目的需要来定义这个时间。</p><h3 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h3><p>前端到后端只有一个接口，但是后端有两个接口。一个是用来接收微信的推送，一个是用来接收前端的查询请求。</p><p>先来写最关键的微信的推送请求处理。由于我们接收微信的请求是在Koa的路由里，并且是以流的形式传输的。需要让Koa支持解析xml格式的body，所以需要安装一个<a href="https://github.com/stream-utils/raw-body" target="_blank" rel="noopener">rawbody</a>来获取xml格式的body。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理微信支付回传notify</span></span><br><span class="line"><span class="comment">// 如果收到消息要跟微信回传是否接收到</span></span><br><span class="line"><span class="keyword">const</span> handleNotify = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> xml = <span class="keyword">await</span> rawbody(ctx.req, &#123;</span><br><span class="line">    length: ctx.request.length,</span><br><span class="line">    limit: <span class="string">'1mb'</span>,</span><br><span class="line">    encoding: ctx.request.charset || <span class="string">'utf-8'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> parseXML(xml) <span class="comment">// 解析xml</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res.return_code === <span class="string">'SUCCESS'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.result_code === <span class="string">'SUCCESS'</span>) &#123; <span class="comment">// 如果都为SUCCESS代表支付成功</span></span><br><span class="line">      <span class="comment">// ... 这里是写入数据库的相关操作</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始回传微信</span></span><br><span class="line">      ctx.type = <span class="string">'application/xml'</span> <span class="comment">// 指定发送的请求类型是xml</span></span><br><span class="line">      <span class="comment">// 回传微信，告诉已经收到</span></span><br><span class="line">      <span class="keyword">return</span> ctx.body = <span class="string">`&lt;xml&gt;</span></span><br><span class="line"><span class="string">        &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;</span></span><br><span class="line"><span class="string">        &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;</span></span><br><span class="line"><span class="string">      &lt;/xml&gt;</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果支付失败，也回传微信</span></span><br><span class="line">  ctx.status = <span class="number">400</span></span><br><span class="line">  ctx.type = <span class="string">'application/xml'</span></span><br><span class="line">  ctx.body = <span class="string">`&lt;xml&gt;</span></span><br><span class="line"><span class="string">    &lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;</span></span><br><span class="line"><span class="string">    &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;</span></span><br><span class="line"><span class="string">  &lt;/xml&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/api/notify'</span>, handleNotify)</span><br></pre></td></tr></table></figure><p>这里的坑就是Koa处理微信回传的xml。如果不知道是以<code>raw-body</code>的形式回传的，会调试半天。。</p><p>接下来这个就是比较简单的给前端回传的了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkBill = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> form = ctx.request.body</span><br><span class="line">  <span class="keyword">const</span> orderNo = form.orderNo</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> 数据库操作</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result) &#123; <span class="comment">// 如果订单支付成功</span></span><br><span class="line">    <span class="keyword">return</span> ctx.body = &#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.status = <span class="number">400</span></span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    success: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/api/check-bill'</span>, checkBill)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，一整个基于Koa2的微信二维码支付流程就简单演示完了，由于不是公开的项目，所以没有实际的GitHub仓库。不过基本上关键的代码我都已经注释出来啦。我参考了不少人的实现，曾考虑过用一些比如<code>wechatpay</code>的npm库，不过最终还是自己解决了。这里面感谢很多前人的分享，也希望我这篇文章能给你一些帮助。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>微信支付文章</p><p><a href="https://www.itbaby.me/blog/59e21af45d21b31fcd4e02c6" target="_blank" rel="noopener">https://www.itbaby.me/blog/59e21af45d21b31fcd4e02c6</a></p><p><a href="https://juejin.im/post/5a8e84faf265da4e7e10c92f" target="_blank" rel="noopener">https://juejin.im/post/5a8e84faf265da4e7e10c92f</a></p><p>返回接口</p><p><a href="http://webcache.googleusercontent.com/search?q=cache:iFC0HZuFB1gJ:jeffdeng.me/wx/2017/03/13/wx-platform-conect.html+&amp;cd=4&amp;hl=zh-CN&amp;ct=clnk&amp;gl=us" target="_blank" rel="noopener">http://webcache.googleusercontent.com/search?q=cache:iFC0HZuFB1gJ:jeffdeng.me/wx/2017/03/13/wx-platform-conect.html+&amp;cd=4&amp;hl=zh-CN&amp;ct=clnk&amp;gl=us</a></p><p>XML流处理</p><p><a href="https://blog.csdn.net/yxz1025/article/details/52313221" target="_blank" rel="noopener">https://blog.csdn.net/yxz1025/article/details/52313221</a></p><p><a href="https://juejin.im/post/5a6c558ef265da3e4b77030f" target="_blank" rel="noopener">https://juejin.im/post/5a6c558ef265da3e4b77030f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在开发一个功能，要求是通过微信二维码进行扫码支付。这个情景我们屡见不鲜了，各种电子商城、线下的自动贩卖机等等都会有这个功能。平时只是使用者，如今变为开发者，也是有不小的坑。所以特此写一篇博客记录一下。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;： 要开发微信二维码支付，你必须要有相应的商户号的权限，否则你是无法开发的。若无相应权限，本文不推荐阅读。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/Nodejs/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
      <category term="Koa" scheme="https://molunerfinn.com/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>【NOTE】观察者模式VS订阅发布模式</title>
    <link href="https://molunerfinn.com/observer-vs-pubsub-pattern/"/>
    <id>https://molunerfinn.com/observer-vs-pubsub-pattern/</id>
    <published>2018-05-12T23:34:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看了一篇<a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank" rel="noopener">《不好意思，观察者模式跟发布订阅模式就是不一样》</a>的文章之后对于这两个模式产生了比较浓厚的兴趣。不过奈何我的水平有限，看完那篇文章还是不能理解。不过在和朋友讨论之后，我想我应该是弄懂了。所以特地记下一篇笔记，以便回头翻阅的时候能够想起来。如果理解有误，欢迎在下方评论指出，一起讨论！</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有人说这两个模式其实是一个模式。我想这句话的对错对半分吧。它们有类似的地方，不过也不能说完全一致。先来一张图，这张图解释了<code>观察者模式</code>和<code>发布订阅模式</code>在流程上的一些区别：</p><p><img src="https://img.piegg.cn/observer-pubsub.png?imageslim" alt></p><p>左边是观察者模式，右边是订阅发布模式。</p><p>简单阐述二者的模型：</p><p>观察者模式里，观察者（Observer）直接订阅（subscribe）主题（Subject），而当主题被激活的时候，会触发（fire）观察者里的事件。</p><p>订阅发布模式里，订阅者（Subscriber）通过监听（on）事件总线（Event Bus）里的事件，当事件总线里的事件被触发（emit）的时候，订阅者将会执行相应的操作。而这里需要注意的是，事件总线里的事件是通过发布者（Publisher）进行发布（publish）和 通知事件总线 <strong>触发</strong> 的。</p><blockquote><p>注：事件总线也有说法叫为调度中心。本质上是一样的。不过因为写Vue时候习惯用Event Bus来说了，所以本文的调度中心皆以事件总线称呼。</p></blockquote><p>所以事件总线本身不独自发布和触发事件，它会借由发布者来操作。这是跟观察者模式有着比较大的区别的地方。</p><p>当然只看这两张图和上面的解释，应该还是无法很好的理解。下面这张图能把流程讲得更清楚点。</p><p><img src="https://img.piegg.cn/observer-vs-pubsub-2.png?imageslim" alt></p><p>这个例子可以理解为这样：左边是微信里的<code>微商-顾客</code>之间的关系。右边是<code>商家-淘宝-顾客</code>之间的关系。</p><p>观察者模式：顾客关注了微商的商品，微商会记住顾客关注的商品，一旦上新就直接 <strong>私聊</strong> 通知所有关注这个商品的顾客。这里的顾客就相当于观察者，这里的微商就相当于主题。<br>订阅发布模式：顾客通过淘宝（APP或者网站）关注了商家的商品，商家一旦上新就通过淘宝（APP或者网站）向关注了它的顾客 <strong>群发</strong> 消息。这里的顾客就是订阅者，这里的淘宝就是事件总线，这里的商家就是发布者。</p><p>所以可以看出，观察者模式的模型跟发布订阅模型里，差距就差在有没有一个中央的事件总线。如果有这个事件总线，我们就可以认为是个发布订阅模型。如果没有，那么就可以认为是个观察者模型。因为其实它们都实现了一个关键的功能：发布事件-订阅事件并触发事件。</p><p>下面用代码简单解释一下。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><p>由于最近在学习TypeScript，所以下面的代码也会用TypeScript来书写。</p></blockquote><p>我们先写一个定义观察者和主题的文件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer-pattern.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Subjects &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">class</span> Observer &#123;</span><br><span class="line">  subject: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params">subject: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subject = subject</span><br><span class="line">  &#125;</span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`This <span class="subst">$&#123;this.subject&#125;</span> was fired!`</span>)</span><br><span class="line">    <span class="keyword">this</span>.subject = <span class="string">`Done`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题</span></span><br><span class="line"><span class="keyword">class</span> Subject &#123;</span><br><span class="line">  <span class="comment">// 根据主题的不同收集相应的订阅者</span></span><br><span class="line">  subjects: Subjects = &#123;&#125;</span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  add (subject, observer: Observer): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.subjects[subject]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subjects[subject] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解除订阅</span></span><br><span class="line">  remove (subject, observer: Observer): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item === observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subjects[subject].splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  fire (subject): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.notify())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  Observer,</span><br><span class="line">  Subject</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是在调用的时候，是这样调用的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> op <span class="keyword">from</span> <span class="string">'./observer-pattern'</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> op.Observer(<span class="string">'click'</span>)</span><br><span class="line"><span class="keyword">let</span> subjects = <span class="keyword">new</span> op.Subject()</span><br><span class="line">subjects.add(<span class="string">'click'</span>, observer)</span><br><span class="line">subjects.fire(<span class="string">'click'</span>) <span class="comment">// subjects 主动通知</span></span><br></pre></td></tr></table></figure><p>经过上述调用，subjects触发观察者订阅的click事件，<code>observer.subject</code>的值将会变为<code>Done</code>（原先为<code>click</code>）。</p><h2 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h2><p>接下来我们来实现一些订阅发布模式。订阅发布模式最关键的地方就在于中间的<code>Event Bus</code>部分。它接管着事件总线的订阅和发布。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pubsub.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Subjects &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Event Bus</span></span><br><span class="line"><span class="keyword">class</span> EventBus &#123;</span><br><span class="line">  subjects: Subjects = &#123;&#125;</span><br><span class="line">  on (subject, callback): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.subjects[subject]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subjects[subject] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  off (subject, callback = <span class="literal">null</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subjects[subject] = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.subjects[subject].forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">        <span class="keyword">if</span> (item === callback) &#123;</span><br><span class="line">          <span class="keyword">this</span>.subjects[subject].splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  emit (subject, data = <span class="literal">null</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subjects[subject].forEach(<span class="function"><span class="params">item</span> =&gt;</span> item(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> EventBus()</span><br></pre></td></tr></table></figure><p>可以看出在这里的<code>EventBus</code>和观察者模式里的<code>Subject</code>几乎一致对吧。但是需要注意的是，最后一行里，我们<code>export default new EventBus()</code>，所以我们在项目里不同的地方<code>import</code>它，都会指向同一个<code>Event Bus</code>实例，这样的话就可以起到一个事件总线的作用了。它不在乎谁来监听，谁来发布。只要有人监听了，就把它放进监听队列中。只要有人发布了事件，就从相应的监听队列中触发回调。不过所有相关的事件都必须经过<code>Event Bus</code>这个实例，而不能越过它直接由发布者通知监听者。</p><blockquote><p>再次祭出这张图</p></blockquote><p><img src="https://img.piegg.cn/observer-vs-pubsub-2.png?imageslim" alt></p><p>所以在订阅发布模型里，发布者或者订阅者的身份已经被弱化。发布者可以在任何时候发布事件，而订阅者可能只是一个回调函数。而最关键的事件总线部分，则是发布订阅模型的核心。</p><p>如果你用过Vue的<code>Event Bus</code>，相信不会陌生。接下来我们来用用我们刚才写的简单的<code>Event Bus</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">'./pubsub.ts'</span></span><br><span class="line"><span class="keyword">const</span> people = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我收到了新的商品通知：'</span>, val) <span class="comment">// 收到消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bus.on(<span class="string">'newItem'</span>, people) <span class="comment">// 订阅newItem这个消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merchant = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123; <span class="comment">// 由商户向event bus发布新商品</span></span><br><span class="line">  <span class="keyword">const</span> item = &#123;</span><br><span class="line">    item: val</span><br><span class="line">  &#125;</span><br><span class="line">  bus.emit(<span class="string">'newItem'</span>, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merchant(<span class="string">'Book'</span>) <span class="comment">// 发布</span></span><br></pre></td></tr></table></figure><p>所以你可以看到，这个事件总线是可以单独抽离出来的。如果要把我们这个文件丢到一个现有的项目里也是完全没问题的。</p><p>其实在写Vue组件通信的时候，你如果用到了<code>Event Bus</code>的话，也是一样的。在全局声明一个<code>new Vue()</code>做<code>Event Bus</code>总线，然后在不同的组件里只要引入了这个事件总线，就能订阅或者发布不同的消息。这个就是一个非常典型的订阅发布模型。</p><p>而如果只是Vue的父子组件通信，子组件用的是<code>this.$emit</code>来触发事件，父组件用的是<code>this.$on</code>这样的方式去订阅事件，那么你可以认为这个就是一个简单的观察者模型。因为它们之间的联系是紧密耦合的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管是观察者模式也好，订阅发布模式也好，关键在于实现了在某个特定时间触发某个特定事件，从而触发监听这个特定事件的组件进行相应操作的功能。这个设计模式在很多时候非常有用。平时只是用到了它，但是没有深入去看看如何实现，这次借由这个机会把二者的关系和区别记录下来，也算是给自己加深了印象。</p><p>本文的代码你可以在我的学习仓库<a href="https://github.com/Molunerfinn/FE-Learning/tree/master/design-pattern" target="_blank" rel="noopener">FE-Learning</a>找到。如有错误欢迎指出！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zcfy.cc/article/observer-vs-pub-sub-pattern-hacker-noon" target="_blank" rel="noopener">https://www.zcfy.cc/article/observer-vs-pub-sub-pattern-hacker-noon</a></p><p><a href="http://blog.zxbing0066.com/design-patterns/2016/09/12/observer-pattern.html" target="_blank" rel="noopener">http://blog.zxbing0066.com/design-patterns/2016/09/12/observer-pattern.html</a></p><p><a href="https://juejin.im/post/5af05d406fb9a07a9e4d2799" target="_blank" rel="noopener">https://juejin.im/post/5af05d406fb9a07a9e4d2799</a></p><p><a href="https://www.cnblogs.com/weebly/p/5279952.html" target="_blank" rel="noopener">https://www.cnblogs.com/weebly/p/5279952.html</a></p><p><a href="https://www.jianshu.com/p/3098b1176357" target="_blank" rel="noopener">https://www.jianshu.com/p/3098b1176357</a></p><p><a href="https://www.zhihu.com/question/23486749/answer/314072549" target="_blank" rel="noopener">https://www.zhihu.com/question/23486749/answer/314072549</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看了一篇&lt;a href=&quot;https://juejin.im/post/5af05d406fb9a07a9e4d2799&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《不好意思，观察者模式跟发布订阅模式就是不一样》&lt;/a&gt;的文章之后对于这两个模式产生了比较浓厚的兴趣。不过奈何我的水平有限，看完那篇文章还是不能理解。不过在和朋友讨论之后，我想我应该是弄懂了。所以特地记下一篇笔记，以便回头翻阅的时候能够想起来。如果理解有误，欢迎在下方评论指出，一起讨论！&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://molunerfinn.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="note" scheme="https://molunerfinn.com/tags/note/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
      <category term="JS" scheme="https://molunerfinn.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>【NOTE】进程-线程-协程 关系与区别</title>
    <link href="https://molunerfinn.com/process-thread-coroutine/"/>
    <id>https://molunerfinn.com/process-thread-coroutine/</id>
    <published>2018-05-11T22:02:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<p>在平时总会听到「进程」、「线程」，甚至最近由于Golang的火热我还听到了「协程」。但是平时我对这三个概念并不能很好的理解，甚至不知它们之间的区别和联系。所以专门找了时间了解了一下它们。本文仅为个人笔记，如有错误或者侵权行为请及时在下方评论里指出！感谢。</p><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>一个进程好比是一个程序，它是 <strong>资源分配的最小单位</strong> 。同一时刻执行的进程数不会超过核心数。不过如果问单核CPU能否运行多进程？答案又是肯定的。单核CPU也可以运行多进程，只不过不是同时的，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。</p><p>电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>如果说进程和进程之间相当于程序与程序之间的关系，那么线程与线程之间就相当于程序内的任务和任务之间的关系。所以线程是依赖于进程的，也称为 <strong>「微进程」</strong> 。它是 <strong>程序执行过程中的最小单元</strong> 。</p><p>一个程序内包含了多种任务。打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是：</p><p>拖动进度条-&gt;画面更新-&gt;声音更新。你会明显感到画面和声音和进度条不同步。</p><p>但是加上了线程之后，线程能够共享进程的大部分资源，并参与CPU的调度。意味着它能够在进程间进行切换，实现「并发」，从而反馈到使用上就是拖动进度条的同时，画面和声音都同步了。所以我们经常能听到的一个词是「多线程」，就是把一个程序分成多个任务去跑，让任务更快处理。不过线程和线程之间由于某些资源是独占的，会导致锁的问题。例如Python的GIL多线程锁。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程在线程中实现调度。你可以理解为它是 <strong>「微线程」</strong> 。它的调度不来自于CPU，而是完全来自于用户控制（可以理解为用代码控制流程）。协程的执行效率非常高，它的切换不是线程切换，没有线程切换的开销。而且只要线程越多，协程的性能优势就越明显。协程不需要多线程的锁机制，只需要判断状态即可。不过协程本身无法利用多核CPU，因为它基于线程，而线程又依赖于进程。</p><p>在JS里，常见的协程就是ES6的<code>yield Generator</code>或者ES7的<code>async await</code>。我们知道JS引擎是单线程的。所以在处理异步任务队列的时候，以往我们会陷入「回调金字塔」或者「回调地狱」。而有了协程之后我们可以在代码层面上来控制我们的程序。</p><p>比如我们有这么一个需求，等两个请求都返回之后，用它们的返回值共同做些事。（此处不用<code>Promise.all()</code>来实现，不是说不行，而是为了更好地说明主题）</p><p><strong>ES6 + co</strong> 的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>)</span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> getData = <span class="keyword">yield</span> axios.get(<span class="string">'xxx'</span>)</span><br><span class="line">  <span class="keyword">const</span> postData = <span class="keyword">yield</span> axios.post(<span class="string">'xxx'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(getData, postData)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>ES7</strong> 的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> getData = <span class="keyword">await</span> axios.get(<span class="string">'xxx'</span>)</span><br><span class="line">  <span class="keyword">const</span> postData = <span class="keyword">await</span> axios.post(<span class="string">'xxx'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(getData, postData)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>上述用「同步」的方式写的代码实际上依然是异步执行的。不过因为了有协程，在单线程的JS里也能够让我们在代码层面上实现了任务调度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以说三者虽然是不同的东西，但是有着很密切的关系和类似的特性。它们的关系是从大到小，从上而下的。没有进程也就没有线程也就没有协程。总的来说，在多核处理器的情况下，多进程+多协程可以发挥最优的性能。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.jianshu.com/p/f11724034d50" target="_blank" rel="noopener">进程，线程，协程与并行，并发</a></li><li><a href="http://www.cnblogs.com/lxmhhy/p/6041001.html" target="_blank" rel="noopener">进程和线程、协程的区别</a></li><li><a href="https://blog.csdn.net/blateyang/article/details/78088851" target="_blank" rel="noopener">进程、线程和协程的比较</a></li><li><a href="http://jsonliangyoujun.iteye.com/blog/2358274" target="_blank" rel="noopener">线程、进程与处理器</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时总会听到「进程」、「线程」，甚至最近由于Golang的火热我还听到了「协程」。但是平时我对这三个概念并不能很好的理解，甚至不知它们之间的区别和联系。所以专门找了时间了解了一下它们。本文仅为个人笔记，如有错误或者侵权行为请及时在下方评论里指出！感谢。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://molunerfinn.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="note" scheme="https://molunerfinn.com/tags/note/"/>
    
      <category term="Nodejs" scheme="https://molunerfinn.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>基于Electron-vue的图床上传工具PicGo v1.5更新说明</title>
    <link href="https://molunerfinn.com/picgo-v1.5-update/"/>
    <id>https://molunerfinn.com/picgo-v1.5-update/</id>
    <published>2018-05-08T21:25:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<p>经过一个多月的努（lan）力（duo）开发，基于electron的图床上传工具<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>终于迎来了一个minor版本的更新。如果你对此感兴趣，不妨看看都更新了哪些有趣而实用的功能吧。</p><a id="more"></a><h3 id="支持GitHub图床"><a href="#支持GitHub图床" class="headerlink" title="支持GitHub图床"></a>支持GitHub图床</h3><p>早先PicGo所支持的图床基本上都是属于国内的服务商提供的图床（如七牛、腾讯云COS等），这次更新加入了GitHub图床的支持。用GitHub做图床其实是不少写博客的朋友的做法。免费、原生支持HTTPS、GitHub仓库易于管理、和issue等功能无缝衔接都是它的优点。如果能接受GitHub在国内的访问速度不是特别快的缺点的话，用它来做你的图床是个不错的选择。来看看在PicGo里如何配置它：</p><p><strong>1. </strong>首先你得有一个GitHub账号。注册GitHub就不用我多言。</p><p><strong>2. </strong>新建一个仓库</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/create_new_repo.png" alt></p><p>记下你取的仓库名。</p><p><strong>3. </strong>生成一个token用于PicGo操作你的仓库：</p><p>访问：<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a></p><p>然后点击<code>Generate new token</code>。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/generate_new_token.png" alt></p><p>把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/20180508210435.png" alt></p><p><strong>注意：</strong>这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/copy_token.png" alt></p><p><strong>4. </strong>配置PicGo</p><p><strong>注意：</strong>仓库名的格式是<code>用户名/仓库</code>，比如我创建了一个叫做<code>test</code>的仓库，在PicGo里我要设定的仓库名就是<code>Molunerfinn/test</code>。一般我们选择<code>master</code>分支即可。然后记得点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是GitHub。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/setup_github.png" alt></p><p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/success.png" alt></p><h3 id="支持腾讯云COS-v5版本"><a href="#支持腾讯云COS-v5版本" class="headerlink" title="支持腾讯云COS v5版本"></a>支持腾讯云COS v5版本</h3><blockquote><p>在支持腾讯云COS的路上，我可谓是费了一番心血。首先是官方提供的node-sdk对我来说基本属于瘫痪状态，只能上传具体文件而不能上传base64编码后的文件。而且居然还有v4和v5两个版本的COS，甚至两个版本的认证签名、上传url等等都<strong>完！全！不！同！</strong>。由于之前我只有v4版本的COS权限，只能开发和测试出v4版本的上传。而近来发现很多朋友用的都已经是v5版本的了，所以我提交了一个工单向腾讯云申请了v5版本的权限，没想到很快就给我派发权限了。于是就有了v5版本的面世。目前市面上能同时支持v4、v5版本COS的估计也只有PicGo了！</p></blockquote><p>如果你是v5用户，但是之前下载了PicGo却不能用的话，别担心，v1.5版本的配置跟之前的配置几乎一致，而且可以一键切换v4\v5版本。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/v5_setup.png" alt></p><p><strong>1. </strong>获取你的APPID、SecretId和SecretKey</p><p>访问：<a href="https://console.cloud.tencent.com/cam/capi" target="_blank" rel="noopener">https://console.cloud.tencent.com/cam/capi</a></p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/get_key_id_secret.png" alt></p><p><strong>2. </strong>获取bucket名以及存储区域代号</p><p>访问：<a href="https://console.cloud.tencent.com/cos5/bucket" target="_blank" rel="noopener">https://console.cloud.tencent.com/cos5/bucket</a></p><p>创建一个存储桶。然后找到你的存储桶名和存储区域代号：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/get_bucket_area.png" alt></p><p>v5版本的存储桶名称格式是<code>bucket-appId</code>，类似于<code>xxxx-12312313</code>。存储区域代码和v4版本的也有所区别，v5版本的如我的是<code>ap-beijing</code>，别复制错了。</p><p><strong>3. </strong>选择v5版本并点击确定</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/choose_v5.png" alt></p><p>然后记得点击<code>设为默认图床</code>，这样上传才会默认走的是腾讯云COS。</p><h3 id="支持编辑相册的图片信息"><a href="#支持编辑相册的图片信息" class="headerlink" title="支持编辑相册的图片信息"></a>支持编辑相册的图片信息</h3><p>有些时候可能上传的图片的url事后需要更改，比如修改http到https，比如加上一些操作后缀（例：七牛图床支持的<code>?imgslim</code>）等等。PicGo本次的更新也让你能够更方便地管理你的图片库。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo_edit_info.gif" alt></p><h3 id="支持上传图片前重命名文件名"><a href="#支持上传图片前重命名文件名" class="headerlink" title="支持上传图片前重命名文件名"></a>支持上传图片前重命名文件名</h3><p>PicGo总共有三种上传模式：</p><ol><li>menubar图标拖拽上传（仅支持macOS）</li><li>主窗口拖拽或者选择图片上传</li><li>剪贴板图片（最常见的是截图）上传（支持自定义快捷键）</li></ol><p>其中前两种都是可以明确获得文件名，而第三种无法获取文件名（因为剪贴板里有些图片比如截图根本就不存在文件名），所以PicGo此前采取的规则是使用时间戳来命名剪贴板里的图片。这也导致了无法自定义文件名的问题。本次更新你可以选择开启「上传前重命名」这个选项：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/rename_before_upload.png" alt></p><p>之后你在上传的时候就会弹出一个小窗口让你重命名文件。如果你不想重命名，点击确定、取消或者直接关闭这个窗口都是可以的。如果你想要重命名就在输入框里输入想要更改的名字，然后点击确定即可。另外这个特性也支持批量上传，如下：</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo_rename.gif" alt></p><h3 id="支持查看当前上传的图床"><a href="#支持查看当前上传的图床" class="headerlink" title="支持查看当前上传的图床"></a>支持查看当前上传的图床</h3><p>在主窗口的上传区，你可以直观地看到当前默认上传的图床，再也不用到处找当前的默认图床是哪个啦。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/current_picbed.png" alt></p><h3 id="支持显示或隐藏相应的图床"><a href="#支持显示或隐藏相应的图床" class="headerlink" title="支持显示或隐藏相应的图床"></a>支持显示或隐藏相应的图床</h3><p>很多时候你并不会使用上PicGo给你提供的全部的图床。所以为了精简显示你可以只选择你想要的图床来显示，这样侧边栏也就不会出现滚动条了。不过需要注意的是，这个仅仅是显示/隐藏而并不是剔除相应的功能。假如你隐藏了七牛云，你依然是可以通过七牛云来上传图片的。</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picbed-choose.gif" alt></p><h3 id="支持开机自启动"><a href="#支持开机自启动" class="headerlink" title="支持开机自启动"></a>支持开机自启动</h3><p>如果你觉得每次开机要主动开启PicGo是一件麻烦事，不妨试试让它开机自启吧~</p><p><img src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/autoStart.png" alt></p><h3 id="修复若干bugs"><a href="#修复若干bugs" class="headerlink" title="修复若干bugs"></a>修复若干bugs</h3><p>v1.5不光更新了上述功能，也修复了不少问题。其中一个尤为重要的是从v1.4.1开始的一个bug——macOS的menubar无法拖拽上传。该bug也在这个版本被修复。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>PicGo第一个稳定版本是在少数派上发布的，详见<a href="https://sspai.com/post/42310" target="_blank" rel="noopener">PicGo：基于 Electron 的图片上传工具</a>。支持macOS和windows双平台，开源免费，界面美观，也得到了很多朋友的认可。本次更新也是充分聆听了大家的<a href="https://github.com/Molunerfinn/PicGo/issues/29" target="_blank" rel="noopener">意见</a>。如果你对它有什么意见或者建议，也欢迎在<a href="https://github.com/Molunerfinn/PicGo/issues" target="_blank" rel="noopener">issues</a>里指出。如果你喜欢它，不妨给它点个star或者请我喝杯咖啡（PicGo的GitHub<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">首页</a>有赞助的二维码）？</p><blockquote><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p></blockquote><blockquote><p>Windows用户请下载<code>.exe</code>文件，macOS用户请下载<code>.dmg</code>文件。</p></blockquote><p>Happy uploading！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过一个多月的努（lan）力（duo）开发，基于electron的图床上传工具&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;终于迎来了一个minor版本的更新。如果你对此感兴趣，不妨看看都更新了哪些有趣而实用的功能吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战4——通过CI发布以及更新的方式</title>
    <link href="https://molunerfinn.com/electron-vue-5/"/>
    <id>https://molunerfinn.com/electron-vue-5/</id>
    <published>2018-04-24T14:11:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇<a href="https://molunerfinn.com/tags/Electron-vue/">系列文章</a>或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从<a href="https://molunerfinn.com/tags/Electron-vue/">之前的文章</a>跟着看。</p><a id="more"></a><h2 id="LOGO的准备"><a href="#LOGO的准备" class="headerlink" title="LOGO的准备"></a>LOGO的准备</h2><p>经过前面几篇文章的实战，我相信大家已经对于构建一个基本的electron应用没有太多的问题了。本文主要阐述一下如何让我们的应用通过CI系统来自动帮我们构建应用，然后发布给用户使用。以及之后如果有更新，要如何通知用户更新。</p><p>当然，在此之前，我们还需要做一件事：给你应用加上好看的LOGO。LOGO的设计和制作不在本文的设计范围内。为了我们的应用能够跨平台地使用，不同平台上应用的LOGO尺寸和格式也不尽相同。三个平台所需的图片格式如下：</p><ul><li>Linux - png</li><li>macOS - icns</li><li>Windows - ico</li></ul><p>准备一张1024*1024以下，256*256以上（长宽一致）的png图片，(推荐512 * 512）然后我们可以用一些工具来实现从png到其他两种格式。搜索png转ico或者png转icns的话有很多在线转换的网站，可以去上面在线转换。在mac上我推荐用的是<a href="http://www.img2icnsapp.com/" target="_blank" rel="noopener">image2icon</a>这个工具。</p><p>然后我们将所得的三个图片文件，放到electron-vue项目根目录的<code>build/icons/</code>目录下。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqnr7sfuvjj20h806cglq.jpg" alt></p><h2 id="不同平台的构建配置"><a href="#不同平台的构建配置" class="headerlink" title="不同平台的构建配置"></a>不同平台的构建配置</h2><p>本文我们主要采用electron-vue已经配置好的基于<a href="https://github.com/electron-userland/electron-builder" target="_blank" rel="noopener">electron-builder</a>的构建脚本来进行我们的应用构建。构建脚本会读取<code>package.json</code>里的<code>build</code>字段里的配置来进行构建。electron-vue默认的配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">  "productName": "ElectronVue",</span><br><span class="line">  "appId": "org.simulatedgreg.electron-vue",</span><br><span class="line">  "dmg": &#123;</span><br><span class="line">    "contents": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/Applications"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"file"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  "directories": &#123;</span><br><span class="line">    "output": "build"</span><br><span class="line">  &#125;,</span><br><span class="line">  "files": [</span><br><span class="line">    "dist/electron",</span><br><span class="line">    "node_modules/",</span><br><span class="line">    <span class="string">"package.json"</span></span><br><span class="line">  ],</span><br><span class="line">  "mac": &#123;</span><br><span class="line">    "icon": "build/icons/icon.icns"</span><br><span class="line">  &#125;,</span><br><span class="line">  "win": &#123;</span><br><span class="line">    "icon": "build/icons/icon.ico"</span><br><span class="line">  &#125;,</span><br><span class="line">  "linux": &#123;</span><br><span class="line">    "icon": "build/icons"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单讲述一下build配置里的一些字段的含义。</p><p>首先<code>productName</code>是你的应用的名字。<code>appId</code>的作用是用于Windows平台区分应用的标识。（<strong>注意</strong>该配置必须配置，而且稍后会有使用该配置的地方。如果不配置不使用的话，构建出来的Windows平台的应用将无法发送eletron的桌面通知）<code>dmg</code>这个配置里描述了macOS平台里，打开<code>dmg</code>安装包后显示的界面里的信息。如下图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqnrlfwfcej20u00mct9y.jpg" alt></p><p>表示了有两个标识，一个是应用文件，坐标是<code>(130, 150)</code>， 一个是应用文件夹的快捷方式，坐标是<code>(410, 150)</code>。</p><p><code>directories</code>的<code>output</code>字段是你应用打包完生成的文件放置的目录。</p><p><code>files</code>指明了要打包的目录。</p><p>而<code>mac</code>，<code>win</code>，<code>linux</code>是针对三个平台的不同的配置了。可以看出默认的配置里对它们的配置都是指向了不同的icon图标（也就是上一节所说的LOGO）。</p><p>PicGo在实际开发中，针对一些情况对默认的<code>build</code>配置项做出了一些增改：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">  "productName": "PicGo",</span><br><span class="line">  "appId": "com.molunerfinn.picgo",</span><br><span class="line">  "directories": &#123;</span><br><span class="line">    "output": "build"</span><br><span class="line">  &#125;,</span><br><span class="line">  "files": [</span><br><span class="line">    <span class="string">"dist/electron/**/*"</span></span><br><span class="line">  ],</span><br><span class="line">  "dmg": &#123;</span><br><span class="line">    "contents": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/Applications"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"x"</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="attr">"y"</span>: <span class="number">150</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"file"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  "mac": &#123;</span><br><span class="line">    "icon": "build/icons/icon.icns",</span><br><span class="line">    "extendInfo": &#123;</span><br><span class="line">      "LSUIElement": 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "win": &#123;</span><br><span class="line">    "icon": "build/icons/icon.ico",</span><br><span class="line">    "target": "nsis"</span><br><span class="line">  &#125;,</span><br><span class="line">  "nsis": &#123;</span><br><span class="line">    "oneClick": false,</span><br><span class="line">    "allowToChangeInstallationDirectory": true</span><br><span class="line">  &#125;,</span><br><span class="line">  "linux": &#123;</span><br><span class="line">    "icon": "build/icons"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>由于PicGo在macOS上主要是一个顶部栏应用，所以在底部docker栏我并不想拥有一个占位的图标，所以在<code>mac</code>字段里加入了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"extendInfo": &#123;</span><br><span class="line">  "LSUIElement": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个属性。参考相关<a href="https://github.com/electron-userland/electron-builder/issues/1456" target="_blank" rel="noopener">issue</a>。</p><p>在Windows平台上，默认打包出来的安装包并没有办法选择安装的路径，只会默认装到C盘的用户目录。这个并不是我们想要的。我们想要的是让用户自己选择安装的路径。</p><p>所以需要修改<code>windows</code>的一些配置以及加上一个<code>nsis</code>的配置来实现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"win": &#123;</span><br><span class="line">  "icon": "build/icons/icon.ico",</span><br><span class="line">  "target": "nsis"</span><br><span class="line">&#125;,</span><br><span class="line">"nsis": &#123;</span><br><span class="line">  "oneClick": false,</span><br><span class="line">  "allowToChangeInstallationDirectory": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于目前我还没有打包过Linux平台的应用，所以Linux相关的配置暂时先不做修改。</p><h3 id="Windows平台打包的一个小坑"><a href="#Windows平台打包的一个小坑" class="headerlink" title="Windows平台打包的一个小坑"></a>Windows平台打包的一个小坑</h3><p>还记得前面说到的一个配置：<code>appId</code>么，这个配置需要我们在主进程<code>index.js</code>里也要使用。否则打包后的应用将失去Windows平台的应用通知功能。这个<code>appId</code>是可以任意取的，只要保证不和其他应用重复即可。对于PicGo而言，<code>appId</code>是<code>com.molunerfinn.picgo</code>。</p><p>打开你的<code>main/index.js</code>，在Windows平台的时候加上这个<code>appId</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> pkg <span class="keyword">from</span> <span class="string">'../../package.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123;</span><br><span class="line">  app.setAppUserModelId(pkg.build.appId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了通知的那个问题。</p><h2 id="通过CI系统自动构建与发布"><a href="#通过CI系统自动构建与发布" class="headerlink" title="通过CI系统自动构建与发布"></a>通过CI系统自动构建与发布</h2><h3 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h3><p>发布应用其实是一个比较繁琐的活，往往跟你的版本控制绑在一块，所以通常在项目开始的阶段就要有所布局。我说说我的做法吧，不一定很科学，不过简单易行。</p><ol><li>仓库主要两个分支，一个dev一个master。平时在dev上开发，只有在发布新版的时候merge到master上。</li><li>书写简单的更新版本的脚本，一键打tag+push到GitHub。</li><li>结合CI系统，自动构建master分支的代码，并将应用推送到GitHub仓库去。</li></ol><p>其中简单的更新版本的脚本我是在<code>package.json</code>里写了简单的<code>scripts</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "patch": "npm version patch &amp;&amp; git push origin master &amp;&amp; git push origin --tags", // 小版本</span><br><span class="line">  "minor": "npm version minor &amp;&amp; git push origin master &amp;&amp; git push origin --tags", // 次版本</span><br><span class="line">  "major": "npm version major &amp;&amp; git push origin master &amp;&amp; git push origin --tags"  // 大版本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面用到了npm的一个命令，<code>npm version [options]</code>，具体可以参考version的<a href="https://docs.npmjs.com/cli/version" target="_blank" rel="noopener">文档</a>。简单来说，它能够自动帮你升级版本，修改<code>package.json</code>里的version，并打上相应的git tag，很方便。</p><p>举个例子，一个符合语义的版本号通常由如下三个部分组成：<code>major.minor.patch</code>，比如<code>1.5.3</code>。如果我运行了<code>npm run patch</code>，那么将会将小版本更新：<code>1.5.4</code>，同时修改<code>package.json</code>里的<code>version</code>字段为<code>1.5.4</code>并自动打上一个git tag <code>1.5.4</code>，并将这个修改和tag推送到远端。</p><p>不过需要注意的是，一开始我是通过electron-vue自带的<code>npm run build</code>这个脚本让CI去执行构建，但是发现无法自动上传到GitHub的release里。所以通过查阅相关资料后，发现最简单的就是把对应的npm scripts命名为<code>release</code>。于是我把原本的<code>npm run build</code>的脚本复制了一遍，起了一个新名<code>release</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...</span><br><span class="line">  "release": "node .electron-vue/build.js &amp;&amp; electron-builder",</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CI相关"><a href="#CI相关" class="headerlink" title="CI相关"></a>CI相关</h3><p>说到这里都还没说到CI系统。什么是CI？可以参考阮一峰老师给出的解释<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">《持续集成是什么？》</a>。我们如果每次发布应用都需要我们在本地构建，然后手动上传到GitHub（或者其他地方）去，然后让别人能下载的话，未免太累了。而且通常我们开发electron应用就是为了能够跨平台，但是要构建不同的平台的应用意味着我们要在不同的平台分别构建。这也是不能忍受的。</p><p>于是网上有一些第三方的CI系统，它们能够帮我们，在某些分支（比如master）发生了某些更新（比如更新了tag）的时候帮我们执行某些脚本（比如构建、测试）。这样就省却了我们在本地、多平台构建的烦心事，而且让一些都变得「自动化」了起来。</p><p>有了CI之后，我的electron应用的发布就变成这样的流程了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqq9mnpumwj20rb04bt9a.jpg" alt></p><p>这样，我们只需要Push代码足矣。</p><p>针对Linux或者macOS的构建，我们可以使用<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a>，针对Windows平台的构建，我们可以使用<a href="https://www.appveyor.com/" target="_blank" rel="noopener">AppVeyor</a>。一个好消息是，它们对于在GitHub上的开源项目都是可以免费构建的，并且和GitHub的仓库结合地特别好，配置也比较简单，可以说的非常良心了。</p><p>在使用它们之前，我们需要给予它们一定的权限让它们能够访问我们的GitHub仓库。所以需要：</p><ol><li>用你的GitHub账号注册它们，才能获取你的仓库列表。</li><li>在GitHub上生成<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">token</a>，赋予CI系统读写你的仓库的权限。生成token的具体操作可以查看之前我写的一篇针对hexo持久化构建的<a href="https://molunerfinn.com/hexo-travisci-https/">文章</a>。</li><li>针对不同的CI平台创建不同的配置文件，好让它们知道你要它们执行什么操作。不过electron-vue很友好地为我们准备了Travis-CI的配置文件模板<code>.travis.yml</code>和AppVeyor的配置文件模板<code>appveyor.yml</code>。所以我们基本上只需要在它们的基础上小修改即可。</li></ol><h3 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis-CI"></a>Travis-CI</h3><p>注册并登录Travis-CI后，找到你要构建的仓库，然后打开，点击设置进入如下页面：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19gy1fi438l5g9sj218a0wmn1u.jpg" alt></p><p>配置一下环境变量，名为<code>GH_TOKEN</code>，token的值就是上一步我们在GitHub生成的token。等会会有用。</p><p>PicGo经过修改后的<code>.travis.yml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Commented sections below can be used to run tests on the CI server</span></span><br><span class="line"><span class="comment"># https://simulatedgreg.gitbooks.io/electron-vue/content/en/testing.html#on-the-subject-of-ci-testing</span></span><br><span class="line"><span class="attr">osx_image:</span> <span class="string">xcode8.3</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"><span class="attr">dist:</span> <span class="string">trusty</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">c</span></span><br><span class="line"><span class="attr">matrix:</span></span><br><span class="line"><span class="attr">  include:</span></span><br><span class="line"><span class="attr">  - os:</span> <span class="string">osx</span></span><br><span class="line">  <span class="comment"># - os: linux</span></span><br><span class="line"><span class="attr">    env:</span> <span class="string">CC=clang</span> <span class="string">CXX=clang++</span> <span class="string">npm_config_clang=1</span></span><br><span class="line"><span class="attr">    compiler:</span> <span class="string">clang</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"$HOME/.electron"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"$HOME/.cache"</span></span><br><span class="line"><span class="attr">addons:</span></span><br><span class="line"><span class="attr">  apt:</span></span><br><span class="line"><span class="attr">    packages:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">libgnome-keyring-dev</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">icnsutils</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">mkdir</span> <span class="bullet">-p</span> <span class="string">/tmp/git-lfs</span> <span class="string">&amp;&amp;</span> <span class="string">curl</span> <span class="bullet">-L</span> <span class="attr">https://github.com/github/git-lfs/releases/download/v1.2.1/git-lfs-$([</span></span><br><span class="line">  <span class="string">"$TRAVIS_OS_NAME"</span> <span class="string">==</span> <span class="string">"linux"</span> <span class="string">]</span> <span class="string">&amp;&amp;</span> <span class="string">echo</span> <span class="string">"linux"</span> <span class="string">||</span> <span class="string">echo</span> <span class="string">"darwin"</span><span class="string">)-amd64-1.2.1.tar.gz</span></span><br><span class="line">  <span class="string">| tar -xz -C /tmp/git-lfs --strip-components 1 &amp;&amp; /tmp/git-lfs/git-lfs pull</span></span><br><span class="line"><span class="string"></span><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">nvm</span> <span class="string">install</span> <span class="number">8.9</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">curl</span> <span class="bullet">-o-</span> <span class="bullet">-L</span> <span class="attr">https://yarnpkg.com/install.sh</span> <span class="string">| bash</span></span><br><span class="line"><span class="string">- source ~/.bashrc</span></span><br><span class="line"><span class="string">- npm install -g xvfb-maybe</span></span><br><span class="line"><span class="string">- yarn</span></span><br><span class="line"><span class="string"></span><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">release</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">yarn</span> <span class="string">run</span> <span class="attr">build:docs</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">docs/dist</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"Molunerfinn"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"marksz@teamsz.xyz"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Travis build docs"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span>  <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@github.com/Molunerfinn/PicGo.git"</span> <span class="attr">master:gh-pages</span></span><br></pre></td></tr></table></figure><p>抛去很多前置依赖（比如C++编译库之类的）和构建环境（是什么系统，是什么语言），那些都是electron-vue给我们预置好的。我们需要注意的仅仅是几个部分：</p><ol><li>script</li><li>branches</li><li>after_script</li></ol><p><code>script</code>是当系统和环境和依赖都准备好之后，你要CI运行的命令。在这里我运行了两个命令，一个是<code>npm run release</code>，这个就是打包构建应用啦，并且执行了这个命令之后，<code>electron-builder</code>会自动将生成好的安装包推送到我们GitHub仓库的draft release里。另一个是构建PicGo<a href="https://molunerfinn.com/PicGo/">主页</a>的命令<code>yarn run build:docs</code>。</p><p><code>branches</code>声明了你要在哪些分支在GitHub接收到了代码更新之后就构建，这里我们自然选择的是master。</p><p><code>after_script</code>是当你执行完script里的脚本之后要做的事。可以为空。对于我而言主要在这个部分将上一步构建好的PicGo主页推送到GitHub的<code>gh-pages</code>分支。当然如果你的应用有使用说明、文档之类的网站，也可以在这里进行构建和推送。</p><p>注意到，在<code>after_script</code>命令的最后一行，有个<code>${GH_TOKEN}</code>，这个就是我们之前在Travis-CI配置里配置的环境变量<code>GH_TOKEN</code>。用环境变量的好处是不会暴露你的TOKEN，只有构建系统知道。</p><h3 id="AppVeyor"><a href="#AppVeyor" class="headerlink" title="AppVeyor"></a>AppVeyor</h3><p>有了之前的经验，AppVeyor就更简单了。注册登录后，我们在主页添加一个PROJECT，选中你要构建的仓库。然后找到SETTING设置：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqawmvu6sj21ji06e3z0.jpg" alt></p><p>然后在左侧的<code>Genral</code>一栏的内容区中，找到构建的分支为master，以及设置我们仅在<code>tag</code>更新的时候构建：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqazwrslxj21600emjse.jpg" alt></p><blockquote><p>当然这个都是根据项目实际来的配置，我只是说PicGo的项目是这样配置的。</p></blockquote><p>然后在左侧的<code>Environment</code>区，找到环境变量配置，我们依然写入<code>GH_TOKEN</code>:</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqb1ufhj7j21ow0gydhu.jpg" alt></p><p><strong>修改完配置都别忘了拉到底部去保存！</strong></p><p>这样就算配置完了网页端的。而现在我们来看看<code>appveyor.yml</code>这个配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Commented sections below can be used to run tests on the CI server</span></span><br><span class="line"><span class="comment"># https://simulatedgreg.gitbooks.io/electron-vue/content/en/testing.html#on-the-subject-of-ci-testing</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.1</span><span class="string">.&#123;build&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span> <span class="string">Visual</span> <span class="string">Studio</span> <span class="number">2017</span></span><br><span class="line"><span class="attr">platform:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">x64</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'%APPDATA%\npm-cache'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'%USERPROFILE%\.electron'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'%USERPROFILE%\AppData\Local\Yarn\cache'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">init:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">core.autocrlf</span> <span class="string">input</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="attr">  - ps:</span> <span class="string">Install-Product</span> <span class="string">node</span> <span class="number">8</span> <span class="string">x64</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">reset</span> <span class="bullet">--hard</span> <span class="string">HEAD</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node</span> <span class="bullet">--version</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_script:</span></span><br><span class="line">  <span class="comment">#- yarn test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">release</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span> <span class="string">off</span></span><br></pre></td></tr></table></figure><p>依然是只需要关注我们所关心的配置即可。一个是<code>branches</code>，一个是<code>build_script</code>。有了<code>Travis-CI</code>的<code>.travis.yml</code>的经验，我相信你也能很快理解它。</p><p>经过上述配置之后，你已经实现了一个简单的前端工程的自动化构建推送流程了。而今你只需要关注代码提交，应用的构建都将会由CI系统自动帮你完成。当然CI系统也不仅仅是拿来构建electron应用的，正如你所见的，你能想到的其他项目的构建、测试其实它都能帮你通过预定义好的脚本完成。</p><h3 id="发布Release"><a href="#发布Release" class="headerlink" title="发布Release"></a>发布Release</h3><p>当CI构建玩应用，会将其推送到你的GitHub的release页面成为一个<code>draf</code>（草稿），你可以编辑这个草稿，加上标题和更新说明，就可以点击<code>publish</code>发布你的新版本的应用啦。</p><h2 id="electron应用的更新"><a href="#electron应用的更新" class="headerlink" title="electron应用的更新"></a>electron应用的更新</h2><p>electron应用的自动更新其实社区有很好的解决方案<a href="https://github.com/electron-userland/electron-builder/tree/master/packages/electron-updater" target="_blank" rel="noopener">electron-updater</a>。而electron-vue也在主进程的<code>main/index.js</code>里预先帮我们写好了一段注释的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#123; autoUpdater &#125; from 'electron-updater'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// autoUpdater.on('update-downloaded', () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   autoUpdater.quitAndInstall()</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.on('ready', () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   if (process.env.NODE_ENV === 'production') &#123;</span></span><br><span class="line"><span class="comment">//     autoUpdater.checkForUpdates()</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>只要引入autoUpdater就能自动帮我们检查更新和自动下载安装更新。不过，凡事都有不过。这个方式虽然很简单，但是它需要的条件比较严格，需要你拥有证书用于应用签名。而macOS平台下的证书需要你申请开发者，一年99$的费用让我望而却步。</p><p>于是我只能退而求其次，能不能通过查询GitHub的release版本号，来比对当前版本，是否需要更新，并提醒用户呢？经过尝试，发现可行。我的实现方法如下:</p><p>我首先写了一个<code>updateChecker</code>的助手：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dialog, shell &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../../datastore'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> pkg <span class="keyword">from</span> <span class="string">'../../../package.json'</span></span><br><span class="line"><span class="keyword">const</span> version = pkg.version</span><br><span class="line"><span class="keyword">const</span> release = <span class="string">'https://api.github.com/repos/Molunerfinn/PicGo/releases/latest'</span></span><br><span class="line"><span class="keyword">const</span> downloadUrl = <span class="string">'https://github.com/Molunerfinn/PicGo/releases/latest'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkVersion = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> showTip = db.read().get(<span class="string">'picBed.showUpdateTip'</span>).value()</span><br><span class="line">  <span class="keyword">if</span> (showTip === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    db.read().set(<span class="string">'picBed.showUpdateTip'</span>, <span class="literal">true</span>).write()</span><br><span class="line">    showTip = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 自动更新的弹窗如果用户没有设置不再提醒，就可以去查询是否需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (showTip) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(release)</span><br><span class="line">    <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> latest = res.data.name <span class="comment">// 获取版本号</span></span><br><span class="line">      <span class="keyword">const</span> result = compareVersion2Update(version, latest) <span class="comment">// 比对版本号，如果本地版本低于远端则更新</span></span><br><span class="line">      <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        dialog.showMessageBox(&#123;</span><br><span class="line">          type: <span class="string">'info'</span>,</span><br><span class="line">          title: <span class="string">'发现新版本'</span>,</span><br><span class="line">          buttons: [<span class="string">'Yes'</span>, <span class="string">'No'</span>],</span><br><span class="line">          message: <span class="string">'发现新版本，更新了很多功能，是否去下载最新的版本？'</span>,</span><br><span class="line">          checkboxLabel: <span class="string">'以后不再提醒'</span>,</span><br><span class="line">          checkboxChecked: <span class="literal">false</span></span><br><span class="line">        &#125;, (res, checkboxChecked) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (res === <span class="number">0</span>) &#123; <span class="comment">// if selected yes</span></span><br><span class="line">            shell.openExternal(downloadUrl)</span><br><span class="line">          &#125;</span><br><span class="line">          db.read().set(<span class="string">'picBed.showUpdateTip'</span>, !checkboxChecked).write()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if true -&gt; update else return false</span></span><br><span class="line"><span class="keyword">const</span> compareVersion2Update = <span class="function">(<span class="params">current, latest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentVersion = current.split(<span class="string">'.'</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item))</span><br><span class="line">  <span class="keyword">const</span> latestVersion = latest.split(<span class="string">'.'</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item))</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentVersion[i] &lt; latestVersion[i]) &#123;</span><br><span class="line">      flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> checkVersion</span><br></pre></td></tr></table></figure><p>然后在<code>main/index.js</code>里，我在app准备启动的时候，调用这个更新助手：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> uploader <span class="keyword">from</span> <span class="string">'./utils/uploader.js'</span></span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  updateChecker()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就能在启动应用的时候弹出更新提示：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fqqbm19ptvj20nc08swf7" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简要地讲述了electron应用用上CI系统帮我们自动化构建和推送，以及在没有申请开发者，没有证书用于应用的代码签名的情况下如何告知用户进行应用更新。要做一个健壮的应用就应该考虑到应用的版本发布、版本更新和对用户的更新通知。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及<a href="https://molunerfinn.com/tags/Electron-vue/">本系列文章</a>的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;系列文章&lt;/a&gt;或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-5/&quot;&gt;通过CI发布以及更新的方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-6/&quot;&gt;开发插件系统——CLI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-7/&quot;&gt;开发插件系统——GUI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;想到再写…&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从&lt;a href=&quot;https://molunerfinn.com/tags/Electron-vue/&quot;&gt;之前的文章&lt;/a&gt;跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前后端路由与前后端渲染</title>
    <link href="https://molunerfinn.com/fe-be-router-render/"/>
    <id>https://molunerfinn.com/fe-be-router-render/</id>
    <published>2018-03-27T21:26:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<p>最近经常会遇到有人问诸如类似下面的问题：</p><ul><li>为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了<code>/</code>的页面呢</li><li>为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢</li><li>啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢</li></ul><p>这个问题是很多初学者会问的问题，于是结合我自己的学习经历也来简单的讲解一下这二者的区别与联系，希望能对你们有所帮助。</p><p>老手可以绕道，去看些更有用的文章吧~</p><a id="more"></a><h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p><a href="https://zhuanlan.zhihu.com/p/24814675" target="_blank" rel="noopener">理解Web路由</a>这篇文章讲得特别好了。</p><blockquote><p>在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。</p></blockquote><p>访问的URL会映射到相应的函数里（这个函数是广义的，可以是前端的函数也可以是后端的函数），然后由相应的函数来决定返回给这个URL什么东西。路由就是在做一个匹配的工作。</p><h2 id="从后端路由讲起"><a href="#从后端路由讲起" class="headerlink" title="从后端路由讲起"></a>从后端路由讲起</h2><p>在web开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。不管是php，还是jsp、asp，用户能通过URL访问到的页面，大多是通过后端路由匹配之后再返回给浏览器的。经典面试题，「你从浏览器地址栏里输入<code>www.baidu.com</code>到你看到网页这个过程中经历了什么」其实讲的也是这个道理。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fproibqucxj20lu03odg9.jpg" alt></p><p>在web后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的URL地址，以及一些表单提交、ajax请求的地址。通常遇到无法匹配的路由，后端将会返回一个<code>404</code>状态码。这也是我们常说的<code>404 NOT FOUND</code>的由来。</p><h3 id="URL与Methods"><a href="#URL与Methods" class="headerlink" title="URL与Methods"></a>URL与Methods</h3><p>如果你关注RESTful API，那么将会很熟悉下面四种发起请求的类型：<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>。</p><blockquote><p>它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong> ——来自阮一峰<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">《理解RESTful架构》</a></p></blockquote><p>虽然上面说的是RESTful API，但是实际上我们在地址栏输入一个URL，并回车的时候，是以<code>GET</code>请求发出去的。这也体现了，URL地址和请求的method也应该是一一对应。下面给出一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.post(<span class="string">'/user/:id'</span>, addUser)</span><br></pre></td></tr></table></figure><p>假如我的后端路由配置里只有这一句路由。那么我通过浏览器里访问：<code>http://xxx.com/user/123</code>的话是无法访问到的，也会返回一个404。因为后端只配了一个<code>post</code>方法的路由。如果要接受这个请求，那么必须有如下的路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/user/:id'</span>, getUser) <span class="comment">// 配置get路由</span></span><br><span class="line">router.post(<span class="string">'/user/:id'</span>, addUser)</span><br></pre></td></tr></table></figure><h3 id="后端路由与服务端渲染"><a href="#后端路由与服务端渲染" class="headerlink" title="后端路由与服务端渲染"></a>后端路由与服务端渲染</h3><p>前面说了，「刀耕火种」的年代里，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的html一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是通过预先写在页面里的jQuery、Bootstrap等常见的前端框架去负责的。</p><p>如果你说有些网站已经是通过ajax去实现的页面，比如gmail，比如qq邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过ajax去实现的，依然还是后端直出——这也就是我们现在又老生常谈的<strong>服务端渲染</strong>。</p><p>服务端渲染的好处有很多，比如对于SEO友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有node.js的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如Laravel的blade，用在Django上的jinja2，用在Struts的jsp等等。实际上到如今，一门后端语言想要能实现自己的web功能，都需要有自己对应的模板引擎。</p><p>node.js诞生之后，前端拥有自己的后端渲染的模板引擎也成为了现实。常见的比如pug、ejs、nunjucks等。这些模板引擎搭配Express、Koa等后端框架也在一开始风靡一时。</p><p>不过在这个过程中，随着web应用的开发越来越复杂，单纯服务端渲染的问题开始慢慢的暴露出来了——耦合性太强了，jQuery时代的页面不好维护，页面切换白屏严重等等。耦合性问题虽然能通过良好的代码结构、规范来解决，不过jQuery时代的页面不好维护这是有目共睹的，全局变量满天飞，代码入侵性太高。后续的维护通常是在给前面的代码打补丁。而页面切换的白屏问题虽然可以通过ajax、或者iframe等来解决，但是在实现上就麻烦了——进一步增加了可维护的难度。</p><p>于是，我们开始进入了前端路由的时代。</p><h2 id="过渡到前端路由"><a href="#过渡到前端路由" class="headerlink" title="过渡到前端路由"></a>过渡到前端路由</h2><p>前端路由——顾名思义，<strong>页面跳转的URL规则匹配</strong>由前端来控制。而前端路由主要是有两种显示方式：</p><ul><li>带有hash的前端路由，优点是兼容性高。缺点是URL带有<code>#</code>号不好看</li><li>不带hash的前端路由，优点是URL不带<code>#</code>号，好看。缺点是既需要浏览器支持也需要后端服务器支持</li></ul><p>前端路由应用最广泛的例子就是当今的SPA的web项目。不管是Vue、React还是Angular的页面工程，都离不开相应配套的router工具。前端路由带来的最明显的好处就是，地址栏URL的跳转不会白屏了——这也得益于前端渲染带来的好处。</p><h3 id="前端路由与前端渲染"><a href="#前端路由与前端渲染" class="headerlink" title="前端路由与前端渲染"></a>前端路由与前端渲染</h3><p>讲前端路由就不能不说前端渲染。我以Vue项目为例。如果你是用官方的<code>vue-cli</code>搭配webpack模板构建的项目，你有没有想过你的浏览器拿到的html是什么样的？是你页面长的那样有<code>button</code>有<code>form</code>的样子么？我想不是的。在生产模式下，你看看构建出来的<code>index.html</code>长什么样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"xxxx.xxx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"yyyy.yyy.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"zzzz.zzz.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通常长上面这个样子。可以看到，这个其实就是你的浏览器从服务端拿到的html。这里面空荡荡的只有一个<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>这个入口的div以及下面配套的一系列js文件。所以你看到的页面其实是通过那些js渲染出来的。这也是我们常说的前端渲染。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fproyjjjlij20jg03oq3a.jpg" alt></p><p>前端渲染把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建，这个很大程度上缓解了服务端的压力。而且配合前端路由，无缝的页面切换体验自然是对用户友好的。不过带来的坏处就是对SEO不友好，毕竟搜索引擎的爬虫只能爬到上面那样的html，对浏览器的版本也会有相应的要求。</p><p>需要明确的是，只要在浏览器地址栏输入URL再回车，是一定会去后端服务器请求一次的。而如果是在页面里通过点击按钮等操作，利用router库的api来进行的URL更新是不会去后端服务器请求的。</p><h4 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h4><p>hash模式利用的是浏览器不会对<code>#</code>号后面的路径对服务端发起路由请求。也即在浏览器里输入如下这两个地址：<code>http://localhost/#/user/1</code>和<code>http://localhost/</code>其实到服务端都是去请求<code>http://localhost</code>这个页面的内容。</p><p>而前端的router库通过捕捉<code>#</code>号后面的参数、地址，来告诉前端库（比如Vue）渲染对应的页面。这样，不管是我们在浏览器的地址栏输入，或者是页面里通过router的api进行的跳转，都是一样的跳转逻辑。所以这个模式是不需要后端配置其他逻辑的，只要给前端返回<code>http://localhost</code>对应的html，剩下具体是哪个页面，就由前端路由去判断便可。</p><h4 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h4><p>不带<code>#</code>号的路由，也就是我们通常能见到的URL形式。router库要实现这个功能一般都是通过HTML5提供的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener">history</a>这个api。比如<code>history.pushState()</code>可以向浏览器地址栏push一个URL，而这个URL是不会向后端发起请求的！通过这个特性，便能很方便地实现漂亮的URL。不过需要注意的是，这个api对于IE9及其以下版本浏览器是不支持的，IE10开始支持，所以对于浏览器版本是有要求的。vue-router会检测浏览器版本，当无法启用history模式的时候会自动降级为hash模式。</p><p>上面说了，你在页面里的跳转，通常是通过router的api去进行的跳转，router的api调用的通常是<code>history.pushState()</code>这个api，所以跟后端没什么关系。但是<strong>一旦你从浏览器地址栏里输入一个地址，比如<code>http://localhost/user/1</code></strong>,这个URL是会向后端发起一个get请求的。后端路由表里如果没有配置相应的路由，那么自然就会返回一个404了！这也就是很多朋友在生产模式遇到404页面的原因。</p><p>那么很多人会问了，那为什么我在开发模式下没问题呢？那是因为<code>vue-cli</code>在开发模式下帮你启动的那个<code>express</code>开发服务器帮你做了这方面的配置。理论上在开发模式下本来也是需要配置服务端的，只不过<code>vue-cli</code>都帮你配置好了，所以你就不用手动配置了。</p><p>那么该如何配置呢？其实在生产模式下配置也很简单，参考vue-router给出的<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">配置例子</a>。一个原则就是，在所有后端路由规则的最后，配置一个规则，如果前面其他路由规则都不匹配的情况下，就执行这个规则——把构建好的那个<code>index.html</code>返回给前端。这样就解决了后端路由抛出的404的问题了，因为只要你输入了<code>http://localhost/user/1</code>这地址，那么由于后端其他路由都不匹配，那么就会返回给浏览器<code>index.html</code>。</p><p>浏览器拿到这个html之后，router库就开始工作，开始获取地址栏的URL信息，然后再告诉前端库（比如Vue）渲染对应的页面。到这一步就跟hash模式是类似的了。</p><p>当然，由于后端无法抛出404的页面错误，404的URL规则自然是交给前端路由来决定了。你可以自己在前端路由里决定什么URL都不匹配的404页面应该显示什么。</p><h2 id="前端路由与服务端渲染"><a href="#前端路由与服务端渲染" class="headerlink" title="前端路由与服务端渲染"></a>前端路由与服务端渲染</h2><p>虽然前端渲染有诸多好处，不过SEO的问题，还是比较突出的。所以react、vue等框架在后来也在服务端渲染上做着自己的努力。基于前端库的服务端渲染跟以前基于后端语言的服务端渲染又有所不同。前端框架的服务端渲染大多依然采用的是前端路由，并且由于引入了状态统一、vnode等等概念，它们的服务端渲染对服务器的性能要求比php等语言基于的字符串填充的模板引擎渲染对于服务器的性能要求高得多。所以在这方面不仅是框架本身在不断改进算法、优化，服务端的性能也必须要有所提升。当初掘金换成SSR的时候也遇到了对应的性能问题，就是这个原因。</p><p>当然在二者之间，也出现了预渲染的概念。也即先在服务端构建出一部分静态的html文件，用于直出浏览器。然后剩下的页面再通过常用的前端渲染来实现。通常我们可以把首页采用预渲染的方式。这个的好处是明显的，兼顾了SEO和服务器的性能要求。不过它无法做到全站SEO，生产构建阶段耗时也会有所提高，这也是遗憾所在。</p><p>关于预渲染，可以考虑使用<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a>这个webapck的插件，它的3.x版本开始使用<strong>puppeteer</strong>来构建html文件了。</p><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>得益于前端路由和现代前端框架的完整的前后端渲染能力，跟页面渲染、组织、组件相关的东西，后端终于可以不用再参与了。</p><p>前后端分离的开发模式也逐渐开始普及。前端开始更加注重页面开发的工程化、自动化，而后端则更专注于api的提供和数据库的保障。代码层面上耦合度也进一步降低，分工也更加明确。我们也摆脱了当初「刀耕火种」的web开发年代。撒花~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望通过此文能够让你对于前后端路由和前后端渲染有所了解。在实际开发的过程中，也不应该仅仅关注于自己所在的领域，相关的领域也要有所涉猎，这样才能面对问题游刃有余。</p><blockquote><p>注：文中的图我使用OmniGraffle制作。转载请注明作者！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近经常会遇到有人问诸如类似下面的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为啥我写的Vue应用在开发阶段都没问题，部署到服务端之后访问不了除了&lt;code&gt;/&lt;/code&gt;的页面呢&lt;/li&gt;&lt;li&gt;为啥我写的SPA页面的路由用hash模式都没问题，改成history模式就问题百出呢&lt;/li&gt;&lt;li&gt;啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个问题是很多初学者会问的问题，于是结合我自己的学习经历也来简单的讲解一下这二者的区别与联系，希望能对你们有所帮助。&lt;/p&gt;&lt;p&gt;老手可以绕道，去看些更有用的文章吧~&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="https://molunerfinn.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="笔记" scheme="https://molunerfinn.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战3——跨平台的一些兼容措施</title>
    <link href="https://molunerfinn.com/electron-vue-4/"/>
    <id>https://molunerfinn.com/electron-vue-4/</id>
    <published>2018-03-20T14:40:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="跨平台的重要性"><a href="#跨平台的重要性" class="headerlink" title="跨平台的重要性"></a>跨平台的重要性</h2><p>虽然electron在大多数情况下的跨平台措施已经帮我们做得很好了。不过需要注意的是，不同平台必然存在细节上的差异。我们在书写跨平台应用的时候，如果只在自己书写平台下测试通过的话是不足以说明我们的应用是健壮的。（当然如果你只想提供给某个平台那另当别论）所以针对不同的发布平台，就需要做一些兼容性措施。</p><p>就我自己的感受而言，macOS平台支持的特性相对比较多，而这里面又很多是独有的，所以很多能在macOS上实现的功能却不一定能在windows上实现。所以对于windows用户而言，在保证整体应用的可用性的情况下，就有可能要相应地做一些妥协和牺牲。不过在windows上的一些操作习惯也可以反过来服务于macOS平台。这点我会在下面给出一个例子详细说明。</p><h2 id="留意不同平台的独有功能"><a href="#留意不同平台的独有功能" class="headerlink" title="留意不同平台的独有功能"></a>留意不同平台的独有功能</h2><p>在开发electron应用的时候，很多时候我们只注意去查找api名，却容易忽视这个api能够使用的平台。在官方文档里，对于一些独占的api，大多都会有标识标出：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpifmc1muoj21mo0ti0wa.jpg" alt></p><p>不过需要注意的是一些未有平台标识的api里的配置项，也有可能是某个平台的独占：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpifrhg1r8j21k804w0tt.jpg" alt></p><p>平时开发的过程中，用到文档的地方还是需要细细留心，避免后续不必要的麻烦。</p><h2 id="跨平台措施入门"><a href="#跨平台措施入门" class="headerlink" title="跨平台措施入门"></a>跨平台措施入门</h2><p>上面讲了这么多，该到实例的时候了。在electron应用中，通常来说<code>renderer</code>进程的东西不需要做太多的跨平台措施——毕竟不管是哪个平台，都是跑在Chrome里的页面。所以大多数情况下，这个方面的工作会放在<code>main</code>进程里。不过也有例外：</p><h3 id="title-bar的操作区处理"><a href="#title-bar的操作区处理" class="headerlink" title="title-bar的操作区处理"></a>title-bar的操作区处理</h3><p>下面是PicGo的windows版：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpig60gzw6j20m80ciwf1.jpg" alt></p><p>下面是PicGo的macOS版：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fpig71431kj218g0p0tav.jpg" alt></p><p>可以发现除了颜色有些区别之外，顶部的<code>title-bar</code>操作栏也有些区别。macOS的程序窗口习惯将窗口的缩放、关闭按钮放在窗口的左上角。而windows程序则相反，它们喜欢放在窗口的右上角。所以为了迎合用户的操作习惯，我们在开发electron程序的时候也应该注意到这一点。</p><p>当然，如果是通过普通的<code>BrowserWindow</code>创建的窗口，那么将会自动拥有常见的macOS、windows的顶部栏，以及默认的样式。</p><p>我在这里想说的是如果想要更加美观的界面，通常我们喜欢「沉浸式」的顶部栏。对于macOS而言，沉浸式的顶部栏就是将顶部栏的三个操作按钮直接「嵌入」窗口主题的左上角。而对于windows而言，只能删去顶部的三个操作按钮，自己用前端的方式来实现了。所以这个地方两个平台的差异性就出来了。</p><p>在<code>main</code>进程里创建该窗口的时候，主要代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSettingWindow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    height: <span class="number">450</span>,</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    show: <span class="literal">false</span>, <span class="comment">// 当window创建的时候不用打开</span></span><br><span class="line">    center: <span class="literal">true</span>,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    resizable: <span class="literal">false</span>,</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>, <span class="comment">// 窗口模糊的样式</span></span><br><span class="line">    transparent: <span class="literal">true</span>,</span><br><span class="line">    titleBarStyle: <span class="string">'hidden'</span>, <span class="comment">// title-bar的样式——隐藏顶部栏的横条，把操作按钮嵌入窗口</span></span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123; <span class="comment">// 如果平台是win32，也即windows</span></span><br><span class="line">    options.show = <span class="literal">true</span> <span class="comment">// 当window创建的时候打开</span></span><br><span class="line">    options.frame = <span class="literal">false</span> <span class="comment">// 创建一个frameless窗口，详情：https://electronjs.org/docs/api/frameless-window</span></span><br><span class="line">    options.backgroundColor = <span class="string">'#3f3c37'</span></span><br><span class="line">  &#125;</span><br><span class="line">  settingWindow = <span class="keyword">new</span> BrowserWindow(options)</span><br><span class="line"></span><br><span class="line">  settingWindow.loadURL(settingWinURL)</span><br><span class="line"></span><br><span class="line">  settingWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    settingWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的工具是通过<code>process.platform</code>来判断不同的平台。当前可能的值有：</p><ul><li>‘aix’</li><li>‘darwin’</li><li>‘freebsd’</li><li>‘linux’</li><li>‘openbsd’</li><li>‘sunos’</li><li>‘win32’</li></ul><p>在这里我们基本上只需要关心<code>darwin</code>（macOS）、<code>win32</code>（windows）、<code>linux</code>（Linux）这三个平台即可。注意，由于electron的对于<code>renderer</code>进程的加持，在<code>renderer</code>进程里也能直接使用<code>process.platform</code>来判断当前的操作系统。这是一个很方便的特性。</p><p>针对windows平台，由于采用了<a href="https://electronjs.org/docs/api/frameless-window" target="_blank" rel="noopener">frameless-window</a>，所以我们需要手动「绘制」顶部的缩放和关闭按钮，并配上相应的事件来模拟真实的按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fake-title-bar"</span>&gt;</span></span><br><span class="line">  PicGo - &#123;&#123; version &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"handle-bar"</span> <span class="attr">v-if</span>=<span class="string">"process.platform === 'win32'"</span>&gt;</span><span class="comment">&lt;!-- 如果是windows平台 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-minus"</span> @<span class="attr">click</span>=<span class="string">"minimizeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-close"</span> @<span class="attr">click</span>=<span class="string">"closeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相应的事件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">minimizeWindow () &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = BrowserWindow.getFocusedWindow()</span><br><span class="line">  <span class="built_in">window</span>.minimize()</span><br><span class="line">&#125;,</span><br><span class="line">closeWindow () &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">window</span> = BrowserWindow.getFocusedWindow()</span><br><span class="line">  <span class="built_in">window</span>.close()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>简单来说就是调用了<code>BrowserWindow</code>的方法来获取当前激活的窗口，然后再对这个窗口进行缩小或关闭的操作。其实也不难对吧！</p><h3 id="任务栏图标交互"><a href="#任务栏图标交互" class="headerlink" title="任务栏图标交互"></a>任务栏图标交互</h3><p>针对不同的平台，我对PicGo的任务栏图标交互也有所区别。对于macOS而言，点击顶部菜单栏的时候会弹出一个小窗口：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fma907llb5j20m30ed46a" alt></p><p>由于macOS的顶部栏图标可以接受拖拽事件，所以就针对macOS的顶部栏制作了顶部栏图标对应的小窗口。让大部分操作不经过主窗口也能实现。而对于windows而言，没有顶部栏，取而代之的是位于底部栏的右侧的任务栏，通常点击任务栏里的图标就会把应用的主窗口调出来。所以为了迎合不同平台的操作习惯，我对于这个地方也做了相应的兼容性适配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'click'</span>, () =&gt; &#123; <span class="comment">// 不管是顶部栏的图标还是任务栏的图标都是Tray组件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果是macOS平台</span></span><br><span class="line">    <span class="keyword">let</span> img = clipboard.readImage()</span><br><span class="line">    <span class="keyword">let</span> obj = []</span><br><span class="line">    <span class="keyword">if</span> (!img.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 从剪贴板来的图片默认转为png</span></span><br><span class="line">      <span class="keyword">const</span> imgUrl = <span class="string">'data:image/png;base64,'</span> + Buffer.from(img.toPNG(), <span class="string">'binary'</span>).toString(<span class="string">'base64'</span>)</span><br><span class="line">      obj.push(&#123;</span><br><span class="line">        width: img.getSize().width,</span><br><span class="line">        height: img.getSize().height,</span><br><span class="line">        imgUrl</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    toggleWindow() <span class="comment">// 打开小窗口</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.webContents.send(<span class="string">'clipboardFiles'</span>, obj)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.hide()</span><br><span class="line">    <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123; <span class="comment">// 如果主窗口未创建</span></span><br><span class="line">      createSettingWindow() <span class="comment">// 创建</span></span><br><span class="line">      settingWindow.show() <span class="comment">// 并打开</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      settingWindow.show() <span class="comment">// 如果已存在，打开</span></span><br><span class="line">      settingWindow.focus() <span class="comment">// 并激活</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="窗口关闭与应用退出"><a href="#窗口关闭与应用退出" class="headerlink" title="窗口关闭与应用退出"></a>窗口关闭与应用退出</h3><p>在windows平台上，通常我们把应用的窗口都关了之后也就默认把这个应用给退出了。而如果在macOS系统上却不是这样。我们把应用的窗口关闭了，但是并非完全退出这个应用。所以为了实现这个操作习惯，我们也可以增加一个情况判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123; <span class="comment">// 当窗口都被关闭了</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果不是macOS</span></span><br><span class="line">    app.quit() <span class="comment">// 应用退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简要地讲述了electron应用在跨平台开发的时候的一些注意事项。可能很多人会觉得奇怪我为啥把这个章节单独拎出来讲。很多时候我们只关注于应用的开发过程，把应用的功能实现是很多情况下的「终极」目标。然而真实情况是，应用的功能实现只是「基本」目标。一个应用要给用户使用的话必然不仅要考虑到应用的功能，还必须考虑用户的使用习惯。要站在用户的角度来做应用。而不是做自嗨型的应用。所以这篇文章也希望能够帮助想要开发electron应用的你。</p><p>本文很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到，欢迎star~如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-5/&quot;&gt;通过CI发布以及更新的方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-6/&quot;&gt;开发插件系统——CLI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-7/&quot;&gt;开发插件系统——GUI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;想到再写…&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从之前的文章跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>hexo-theme-melody v1.5 supports slides &amp; iframe</title>
    <link href="https://molunerfinn.com/slide-support/"/>
    <id>https://molunerfinn.com/slide-support/</id>
    <published>2018-03-06T19:57:52.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-theme-melody-v1-5"><a href="#hexo-theme-melody-v1-5" class="headerlink" title="hexo-theme-melody v1.5"></a>hexo-theme-melody <small>v1.5</small></h2><p>Supports iframe &amp; slides. You can use a layout called <code>slides</code> to enabled the slides layout.</p><p>Also you can add a <code>iframe</code> front-matter with the <code>slides</code> layout in your <code>md</code> file to enable the iframe page.</p><p>===</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><h3 id="1-Add-a-slides-page"><a href="#1-Add-a-slides-page" class="headerlink" title="1. Add a slides page"></a>1. Add a slides page</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page slides</span><br><span class="line"><span class="built_in">cd</span> ./<span class="built_in">source</span>/slides</span><br></pre></td></tr></table></figure><p>===</p><h3 id="2-Add-the-layout-type"><a href="#2-Add-the-layout-type" class="headerlink" title="2. Add the layout type"></a>2. Add the layout type</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.md</span><br></pre></td></tr></table></figure><p>Add a type called <code>slides</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">slides</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-03</span><span class="bullet">-06</span> <span class="number">20</span><span class="string">:24:48</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">slides</span></span><br></pre></td></tr></table></figure><p>===</p><h3 id="3-Modified-the-melody-yml"><a href="#3-Modified-the-melody-yml" class="headerlink" title="3. Modified the melody.yml"></a>3. Modified the melody.yml</h3><p>Add slides default config:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slide:</span></span><br><span class="line"><span class="attr">  separator:</span> <span class="string">whatever</span> <span class="string">you</span> <span class="string">like</span></span><br><span class="line"><span class="attr">  separator_vertical:</span> <span class="string">whatever</span> <span class="string">you</span> <span class="string">like</span></span><br><span class="line"><span class="attr">  charset:</span> <span class="string">utf-8</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">black</span></span><br><span class="line"><span class="attr">  mouseWheel:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  transition:</span> <span class="string">slide</span></span><br><span class="line"><span class="attr">  transitionSpeed:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  parallaxBackgroundImage:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundSize:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundHorizontal:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  parallaxBackgroundVertical:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><blockquote><p>See reveal.js <a href="https://github.com/hakimel/reveal.js#configuration" target="_blank" rel="noopener">config</a></p></blockquote><p>===</p><h3 id="4-Write-a-md-file-with-slides-layout"><a href="#4-Write-a-md-file-with-slides-layout" class="headerlink" title="4. Write a md file with slides layout"></a>4. Write a md file with slides layout</h3><p>In <code>_posts</code> folder, add a <code>md</code> file.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// balalala...</span><br></pre></td></tr></table></figure><p>Then you will get a post of slides type.</p><p>===</p><h2 id="Slides-layout-with-iframe"><a href="#Slides-layout-with-iframe" class="headerlink" title="Slides layout with iframe"></a>Slides layout with iframe</h2><p>If you want to add a website whatever you like within an iframe, try this:</p><p>In <code>_posts</code> folder, add a <code>md</code> file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">iframe: https://the-url-whatever-you-like</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>Then you will get a post of iframe.</p><p>===</p><h2 id="Configurate-single-slides-in-md"><a href="#Configurate-single-slides-in-md" class="headerlink" title="Configurate single slides in md"></a>Configurate single slides in md</h2><p>The slides config in <code>meldoy.yml</code> can change whole slides page.</p><p>But if you set the config in the md file, it will effect the single page.</p><p>==</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: hexo-theme-melody v1.5 supports iframe &amp; slides</span><br><span class="line">date: 2018-03-06 19:57:52</span><br><span class="line">layout: slides</span><br><span class="line">slide:</span><br><span class="line">  theme: white</span><br><span class="line">  transition: zoom</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// balalala...</span><br></pre></td></tr></table></figure><p>===</p><h1 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy!"></a>Enjoy!</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo-theme-melody-v1-5&quot;&gt;&lt;a href=&quot;#hexo-theme-melody-v1-5&quot; class=&quot;headerlink&quot; title=&quot;hexo-theme-melody v1.5&quot;&gt;&lt;/a&gt;hexo-theme-melody &lt;s
      
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="hexo" scheme="https://molunerfinn.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>用新版的Chrome把PWA网站添加到桌面，获得媲美原生应用的体验</title>
    <link href="https://molunerfinn.com/PC-Chrome-PWA/"/>
    <id>https://molunerfinn.com/PC-Chrome-PWA/</id>
    <published>2018-03-03T16:12:00.000Z</published>
    <updated>2019-03-17T14:42:12.470Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2018.03.06 更新：</strong>非PWA网站也能通过独立窗口而非浏览器打开。具体看「注意事项」。</p><h2 id="PWA是什么"><a href="#PWA是什么" class="headerlink" title="PWA是什么"></a>PWA是什么</h2><p>引用自<a href="http://harttle.land/2017/01/28/pwa-explore.html" target="_blank" rel="noopener">Harttle.Land</a>的说法：</p><blockquote><p><a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">PWA</a>(Progressive Web Apps)是 Google 最近在提的一种 Web App 形态 （或者如 Wikipedia 所称的“软件开发方法”）。 Harttle 能找到的关于 PWA 最早的一篇文章是 2015年6月 Alex Russell 的一篇博客： <a href="https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/" target="_blank" rel="noopener">Progressive apps escaping tabs without losing our soul</a>， <strong>让 Web App 从标签页跳出来，同时保持 Web 的灵魂。</strong></p></blockquote><blockquote><p>如 Alex 所述，PWA 意图让 Web 在保留其本质（开放平台、易于访问、可索引）的同时， 在离线、交互、通知等方面达到类似 App 的用户体验。按 <a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">Google 官方的解释</a> PWA 具有这些特性：Reliable, Fast, Engaging。</p></blockquote><p>它比原生应用更轻量，但是却比现有的Web APP的功能更加丰富。最大也是最关键的区别是它能够脱离浏览器的「束缚」（虽然依然是基于浏览器的技术），能够把PWA网站添加到你的桌面上，不管是PC操作系统还是手机操作系统，类似于一个原生应用一样，并且拥有媲美原生应用的体验。</p><p>它也能拥有原生APP应用一般的启动闪屏，它也能像原生APP应用一般能有消息推送——不过要知道，它源自Web，通常只有传统APP的体积的十分之一甚至更小。它不用等待下载安装的时间，打开网页的时候就已经「下载」并且「安装」完毕。</p><p>要想体验这项技术，如果你是安卓用户，那最新版的Chrome已经支持；如果你是iOS用户，可以等待3月份的11.3版本更新；如果你是PC电脑用户，那么来看看怎么在电脑上也体验体验PWA吧。</p><a id="more"></a><h2 id="配置Chrome"><a href="#配置Chrome" class="headerlink" title="配置Chrome"></a>配置Chrome</h2><p>首先更新你的Chrome版本到64或以上。</p><p>然后在地址栏输入<code>chrome://flags</code>，找到<code>Desktop PWAs</code>的选项将其<code>Enabled</code>了，然后Chrome会提示你重启浏览器。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozgv6nxloj20l7050q37" alt></p><p>重启浏览器后，PWA添加到桌面的特性就已经具备了。</p><h2 id="将PWA网站添加到桌面"><a href="#将PWA网站添加到桌面" class="headerlink" title="将PWA网站添加到桌面"></a>将PWA网站添加到桌面</h2><p>我这里使用的是我的<a href="https://molunerfinn.com">博客</a>（基于自己写的<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>主题搭建的）。打开网站，然后在浏览器右侧找到设置的按钮。接下去我针对Windows平台和macOS平台做分开讲解。</p><h3 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h3><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1foznbd9gcdj20x10iw4mx" alt></p><p>Windows平台找到<code>添加到桌面</code>这个按钮，点击，然后会出现一个确认框：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1foznebsdhvj20w50gwhba" alt></p><p>点击添加。然后你就可以在桌面上看到相应的图标：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozng6ajhhj20bq09hwj9" alt></p><p>双击打开：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1foznhijnsdj20q30gjx1u" alt></p><p>你会发现打开了一个没有浏览器痕迹的网页，或者说是个应用——这就是PWA了。PWA支持离线启动技术，即使在没网的情况下也能启动应用。不过在需要网络条件下才能发送的请求依然需要网络环境。</p><h3 id="macOS平台"><a href="#macOS平台" class="headerlink" title="macOS平台"></a>macOS平台</h3><p>相对于Windows平台比较简单的操作，macOS平台的操作相对有点绕弯，不过也大致相同。macOS的Chrome无法一次性就把PWA应用添加到桌面。需要先把PWA网站生成一个app应用，然后你再手动把这个app应用以快捷方式复制到桌面。</p><p>接下来是具体步骤：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozny8dva4j20zk0m81kx" alt></p><p>打开一个PWA网站，此处依然以我的<a href="https://molunerfinn.com">博客</a>作为例子，然后再右侧找到配置菜单，下拉选中<code>添加到“应用”文件夹</code>。然后等待几秒钟，会出现一个对话框：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozo1ww7ubj20zj0cnx29" alt></p><p>此时这个PWA应用已经生成完毕了。我们点击添加。之后你就可以在你的应用列表看到它了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozo2gf2xij20zk0m8qcm" alt></p><p>不过如果你要在你的桌面上添加这个应用的话，还需要找到这个app的位置，一般是在<code>/Users/你的用户名/Applications/Chrome\ Apps.localized/</code>这个文件夹下。用finder打开：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fozo545tmij20h50470tp" alt></p><p>然后选中这个应用，按住<code>alt+command</code>键把它拖拽到桌面上，就会生成一个快捷方式啦。这个方法也同样适用于其他应用。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果是非PWA应用，也会有<code>添加到桌面</code>或者<code>添加到应用文件夹</code>的选项。不过当你双击打开它们的时候依然会调用Chrome浏览器去打开，跟以前的书签的作用无差别。</p><p><strong>不过</strong>，依然可以通过一个小操作来实现。感谢@<a href="https://weibo.com/5319395630" target="_blank" rel="noopener">RiiSan</a>指出我原文的错误。</p><p>前置步骤跟之前说的一样，然后打开<code>chrome://apps</code>，找到你制作的应用，然后右键，选择<code>在窗口中打开</code>。那么就能获得跟PWA应用单独窗口的类似体验。不过它是不具备PWA离线打开的能力哦，只是纯粹的一个网页通过独立窗口打开而已。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fp32grp8nmj21ns0s8k4a" alt></p><p>目前<code>Desktop PWAs</code>还是实验性的功能，所以有可能出现不稳定的情况，依照自己的情况作出决定~</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>就目前来说，我能想到的比较理想的使用条件是，在一些功能性网站支持PWA的情况下，是不用再去下它们的桌面客户端了，直接通过PWA添加到桌面，就能像使用原生应用一样使用它们啦。比如推特，比如Medium等。</p><p>下面给出一个别人总结的PWA网站列表，可以去体验一波~</p><p><a href="https://github.com/hemanth/awesome-pwa" target="_blank" rel="noopener">https://github.com/hemanth/awesome-pwa</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2018.03.06 更新：&lt;/strong&gt;非PWA网站也能通过独立窗口而非浏览器打开。具体看「注意事项」。&lt;/p&gt;&lt;h2 id=&quot;PWA是什么&quot;&gt;&lt;a href=&quot;#PWA是什么&quot; class=&quot;headerlink&quot; title=&quot;PWA是什么&quot;&gt;&lt;/a&gt;PWA是什么&lt;/h2&gt;&lt;p&gt;引用自&lt;a href=&quot;http://harttle.land/2017/01/28/pwa-explore.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Harttle.Land&lt;/a&gt;的说法：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PWA&lt;/a&gt;(Progressive Web Apps)是 Google 最近在提的一种 Web App 形态 （或者如 Wikipedia 所称的“软件开发方法”）。 Harttle 能找到的关于 PWA 最早的一篇文章是 2015年6月 Alex Russell 的一篇博客： &lt;a href=&quot;https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Progressive apps escaping tabs without losing our soul&lt;/a&gt;， &lt;strong&gt;让 Web App 从标签页跳出来，同时保持 Web 的灵魂。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;如 Alex 所述，PWA 意图让 Web 在保留其本质（开放平台、易于访问、可索引）的同时， 在离线、交互、通知等方面达到类似 App 的用户体验。按 &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google 官方的解释&lt;/a&gt; PWA 具有这些特性：Reliable, Fast, Engaging。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;它比原生应用更轻量，但是却比现有的Web APP的功能更加丰富。最大也是最关键的区别是它能够脱离浏览器的「束缚」（虽然依然是基于浏览器的技术），能够把PWA网站添加到你的桌面上，不管是PC操作系统还是手机操作系统，类似于一个原生应用一样，并且拥有媲美原生应用的体验。&lt;/p&gt;&lt;p&gt;它也能拥有原生APP应用一般的启动闪屏，它也能像原生APP应用一般能有消息推送——不过要知道，它源自Web，通常只有传统APP的体积的十分之一甚至更小。它不用等待下载安装的时间，打开网页的时候就已经「下载」并且「安装」完毕。&lt;/p&gt;&lt;p&gt;要想体验这项技术，如果你是安卓用户，那最新版的Chrome已经支持；如果你是iOS用户，可以等待3月份的11.3版本更新；如果你是PC电脑用户，那么来看看怎么在电脑上也体验体验PWA吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="PWA" scheme="https://molunerfinn.com/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战2——引入基于Lodash的JSON数据库lowdb</title>
    <link href="https://molunerfinn.com/electron-vue-3/"/>
    <id>https://molunerfinn.com/electron-vue-3/</id>
    <published>2018-02-12T21:04:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="数据持久化存储的必要性"><a href="#数据持久化存储的必要性" class="headerlink" title="数据持久化存储的必要性"></a>数据持久化存储的必要性</h2><p>不像平时很多人写的一些demo，就是请求一下api然后把web页面展示出来就了事了。electron应用毕竟是个桌面级应用，如果思维还留在纯web开发的思路上，那么也就失去了用electron的意义了吧。</p><p>数据持久化存储实际上对于后端很熟悉。通常是指的是把内存里的数据以不同的存储模型存储到磁盘上，在需要的时候再从存储模型里读取读入内存中的整个流程。这里面的存储模型通常就是我们熟悉的数据库。说到数据库，很多人会想到MySQL，Mongodb，SQLite等等。常见的这些数据库都是Server-Client模式的，需要启动服务端——通常我们装的就是这个。但是你一般很少见到叫别人装个桌面软件的同时，叫别人配数据库的吧。</p><p>因为有些数据我们必须在本地存下来，方便下次使用的时候读取。而对于electron来说，既然让用户装MySQL、Mongodb是不太优雅的解决办法的话，那么如果能用其他方式，将数据存到本地而不用用户操心如何存储的，对我们和用户来说都是一件好事。</p><h2 id="纯JavaScript数据库的选择"><a href="#纯JavaScript数据库的选择" class="headerlink" title="纯JavaScript数据库的选择"></a>纯JavaScript数据库的选择</h2><p>既然是JS技术栈的，于是我就找了一些纯JavaScript实现的数据库。经过初步筛选，我找到如下两个：</p><ol><li><a href="https://github.com/louischatriot/nedb" target="_blank" rel="noopener">nedb</a> 7800star（2018-02-12）</li><li><a href="https://github.com/typicode/lowdb" target="_blank" rel="noopener">lowdb</a> 7269star（2018-02-12）</li></ol><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>其中就目前来看，nedb用的更为广泛，star数更多（截止2018-02-12），而且有很多讲到nedb和electron配合使用的文章。不过，nedb已经有快两年没有维护了，而且原生不支持Promise，采用的是异步回调（虽然可以通过第三方插件实现Promise）。</p><p>lowdb是用JSON为基本存储结构基于lodash开发的，有lodash的加持，用起来很顺手。优势在于它在持续的维护，有不少好用的插件。并且很关键的是同步操作，采用链式调用的写法，写起来有种jQuery的感觉。再者，用JSON存储的数据，不管是调用还是备份都很方便，这也是让我很喜欢的一点。</p><p>综上，PicGo采用的是lowdb。</p><h2 id="lowdb的初始化"><a href="#lowdb的初始化" class="headerlink" title="lowdb的初始化"></a>lowdb的初始化</h2><p>由于electron给main进程和renderer进程都置入了Node的<code>fs</code>模块，所以我们可以很方便的在两端都使用跟<code>fs</code>相关的操作。而lowdb本质上就是通过<code>fs</code>来读写JSON文件实现的，正好符合我们的要求。所以根据官方给出的文档，我们首先先初始化一下。</p><p><strong>为了操作<code>fs</code>更方便，不妨安装一个<a href="https://github.com/jprichardson/node-fs-extra" target="_blank" rel="noopener">fs-extra</a>。</strong></p><p>创建一个<code>datastore.js</code>文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; app &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STORE_PATH = app.getPath(<span class="string">'userData'</span>) <span class="comment">// 获取electron应用的用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>)) <span class="comment">// 初始化lowdb读写的json文件名以及存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter) <span class="comment">// lowdb接管该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db <span class="comment">// 暴露出去</span></span><br></pre></td></tr></table></figure><p>接着我们在main进程和renderer进程里就可以这样引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../datastore'</span> <span class="comment">// 取决于你的datastore.js的位置</span></span><br></pre></td></tr></table></figure><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>如果仅仅是上面的基本操作，那么这篇文章未免也太简单了。关于electron引入lowdb的踩坑之路现在才开始。</p><h4 id="1-renderer进程要使用remote模块"><a href="#1-renderer进程要使用remote模块" class="headerlink" title="1. renderer进程要使用remote模块"></a>1. renderer进程要使用remote模块</h4><p>首先由上面的初始化能明显看到一个问题。<code>app</code>模块是main进程里特有的，renderer进程应该使用<code>remote.app</code>模块。所以上面的代码在<code>renderer</code>进程里会报错。</p><p>因此第一次修改，使其既能跑在main进程也能跑在renderer进程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; app, remote &#125; <span class="keyword">from</span> <span class="string">'electron'</span> <span class="comment">// 引入remote模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP = process.type === <span class="string">'renderer'</span> ? remote.app : app <span class="comment">// 根据process.type来分辨在哪种模式使用哪种模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STORE_PATH = APP.getPath(<span class="string">'userData'</span>) <span class="comment">// 获取electron应用的用户目录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>)) <span class="comment">// 初始化lowdb读写的json文件名以及存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter) <span class="comment">// lowdb接管该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db <span class="comment">// 暴露出去</span></span><br></pre></td></tr></table></figure><h4 id="2-开发模式和生产模式初始化路径问题"><a href="#2-开发模式和生产模式初始化路径问题" class="headerlink" title="2. 开发模式和生产模式初始化路径问题"></a>2. 开发模式和生产模式初始化路径问题</h4><p>在开发模式的时候，通过<code>APP.getPath(&#39;userData&#39;)</code>获取到的路径形如：<code>/Users/molunerfinn/Library/Application Support/Electron</code>（macOS下）。这个是一个已经自动创建好的路径。所以在开发模式的时候，初始化路径是已经存在的。</p><p>然而在生产模式下不是这样。生产模式下，第一次打开应用的过程中，<code>APP.getPath(&#39;userData&#39;)</code>获取的路径并未创建，而<code>datastore.js</code>却已经被加载。所以这个时候初始化路径并不存在。用户在第一次打开应用的时候就会遇到如下报错：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fodwgwq9k6j20nc176dov" alt></p><p>所以我们必须在<code>datastore.js</code>里做一次路径是否存在的判断：</p><blockquote><p>此处的fs是来自fs-extra模块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.type !== <span class="string">'renderer'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fs.pathExistsSync(STORE_PATH)) &#123; <span class="comment">// 如果不存在路径</span></span><br><span class="line">    fs.mkdirpSync(STORE_PATH) <span class="comment">// 就创建</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-初始化数据"><a href="#3-初始化数据" class="headerlink" title="3. 初始化数据"></a>3. 初始化数据</h4><p>因为有的时候我们需要预先指定数据库的基本结构，比如是个数组，这样我们就初始化为<code>[]</code>。如果是个Object，有具体值，就指定为具体值。而初始化数据结构不应该在每次对数据读写的时候来判断，应该在数据库一开始创建的时候就初始化，所以写在<code>datastore.js</code>里是合适的。</p><p>比如我要初始化上传列表应该是一个数组，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'uploaded'</span>).value()) &#123; <span class="comment">// 先判断该值存不存在</span></span><br><span class="line">  db.set(<span class="string">'uploaded'</span>, []).write() <span class="comment">// 不存在就创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-唯一标识的id字段"><a href="#4-唯一标识的id字段" class="headerlink" title="4. 唯一标识的id字段"></a>4. 唯一标识的id字段</h4><p>用过MySQL的人大多都会在表里初始化一个自增的id字段作为数据的唯一标识。而lowdb虽然无法很方便地创建一个自增的id字段，但是通过<a href="https://github.com/typicode/lodash-id" target="_blank" rel="noopener">lodash-id</a>这个插件可以很方便地为每个新增的数据自动加上一个唯一标识的id字段。</p><p>形如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"height"</span>: <span class="number">514</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"weibo"</span>,</span><br><span class="line">  <span class="attr">"width"</span>: <span class="number">514</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"7f247aa7-ffeb-4bb1-87f1-a0d69824ec78"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化也很方便：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> LodashId <span class="keyword">from</span> <span class="string">'lodash-id'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter)</span><br><span class="line">db._.mixin(LodashId) <span class="comment">// 通过._mixin()引入</span></span><br></pre></td></tr></table></figure><h3 id="初始化完整代码"><a href="#初始化完整代码" class="headerlink" title="初始化完整代码"></a>初始化完整代码</h3><p>通过上述的踩坑，PicGo的初始化代码如下，仅供参考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Datastore <span class="keyword">from</span> <span class="string">'lowdb'</span></span><br><span class="line"><span class="keyword">import</span> LodashId <span class="keyword">from</span> <span class="string">'lodash-id'</span></span><br><span class="line"><span class="keyword">import</span> FileSync <span class="keyword">from</span> <span class="string">'lowdb/adapters/FileSync'</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs-extra'</span></span><br><span class="line"><span class="keyword">import</span> &#123; remote, app &#125; <span class="keyword">from</span> <span class="string">'electron'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP = process.type === <span class="string">'renderer'</span> ? remote.app : app</span><br><span class="line"><span class="keyword">const</span> STORE_PATH = APP.getPath(<span class="string">'userData'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.type !== <span class="string">'renderer'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fs.pathExistsSync(STORE_PATH)) &#123;</span><br><span class="line">    fs.mkdirpSync(STORE_PATH)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="keyword">new</span> FileSync(path.join(STORE_PATH, <span class="string">'/data.json'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = Datastore(adapter)</span><br><span class="line">db._.mixin(LodashId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'uploaded'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'uploaded'</span>, []).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'picBed'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'picBed'</span>, &#123;</span><br><span class="line">    current: <span class="string">'weibo'</span></span><br><span class="line">  &#125;).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!db.has(<span class="string">'shortKey'</span>).value()) &#123;</span><br><span class="line">  db.set(<span class="string">'shortKey'</span>, &#123;</span><br><span class="line">    upload: <span class="string">'CommandOrControl+Shift+P'</span></span><br><span class="line">  &#125;).write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> db</span><br></pre></td></tr></table></figure><h2 id="lowdb的基本操作"><a href="#lowdb的基本操作" class="headerlink" title="lowdb的基本操作"></a>lowdb的基本操作</h2><p>数据库的基本操作无非就是CURD。</p><blockquote><p>它代表创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete）操作。</p></blockquote><p>下面介绍lowdb的基本使用方法。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>主要通过<code>set()</code>或者<code>defaults()</code>方法。其中<code>defaults()</code>专门针对空JSON文件进行初始化。（不过用set也是可以实现类似的，如上一小节说到的初始化）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.defaults(&#123; <span class="attr">posts</span>: [], <span class="attr">user</span>: &#123;&#125;, <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  .write() <span class="comment">// 一定要显式调用write方法将数据存入JSON</span></span><br></pre></td></tr></table></figure><p><strong>注意任何写的操作，都必须显式的使用<code>write()</code>方法来保存。</strong></p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>).value() <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>当然还可以用lodash的一些方法来查询你的JSON。</p><p>比如<code>find()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .find(&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  .value()</span><br></pre></td></tr></table></figure><p><strong>注意任何读的操作，都必须显式使用<code>value()</code>方法来获取值。</strong></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>通过不同的方法对不同的结构来更新。</p><p>比如针对对象就用赋值，针对数组就用<code>push()</code>或者<code>insert()</code>（lowdb-id提供的方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>).insert(&#123; <span class="comment">// 对数组进行insert操作</span></span><br><span class="line">  title: <span class="string">'xxx'</span>,</span><br><span class="line">  content: <span class="string">'xxxx'</span></span><br><span class="line">&#125;).write()</span><br></pre></td></tr></table></figure><p>针对对象可以直接用<code>set()</code>来更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.set(<span class="string">'user.name'</span>, <span class="string">'typicode'</span>) <span class="comment">// 通过set方法来对对象操作</span></span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>还可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.set(<span class="string">'user'</span>, &#123;</span><br><span class="line">  name: <span class="string">'typicode'</span></span><br><span class="line">&#125;).write()</span><br></pre></td></tr></table></figure><p>很灵活对吧。</p><p>针对原有的数据进行更新的可以用update。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.update(<span class="string">'count'</span>, n =&gt; n + <span class="number">1</span>) <span class="comment">// update方法使用已存在的值来操作</span></span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>可以通过<code>remove()</code>方法删除一个符合条件的项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .remove(&#123; <span class="attr">title</span>: <span class="string">'low!'</span> &#125;)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>可以通过<code>unset</code>来删除一个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.unset(<span class="string">'user.name'</span>)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><p>还可以通过<code>lodash-id</code>提供的<code>removeById()</code>来删除指定id的项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.get(<span class="string">'posts'</span>)</span><br><span class="line">  .removeById(id)</span><br><span class="line">  .write()</span><br></pre></td></tr></table></figure><h2 id="lowdb实际使用的坑"><a href="#lowdb实际使用的坑" class="headerlink" title="lowdb实际使用的坑"></a>lowdb实际使用的坑</h2><p>lowdb在使用的过程中会遇到一个大坑在于，如果就按照基本操作，那么有可能出现我在<code>main</code>进程里存入的值，在<code>renderer</code>进程里读不到。</p><p>为啥？因为直接引用的<code>db</code>实际上只是那个时刻在内存里的数据。lowdb在使用过程中会把JSON数据读入内存中。只有在需要写操作的时候才会将新的数据写入磁盘。</p><p>main进程和renderer进程拿到的db都是应用打开时所读取的。在没有额外处理的情况下，在main进程拿到的内存里的db，和renderer拿到的内存里的db不是同一个db，也就是所谓的不是一个db的两份引用，而是一个db的两份拷贝。main进程对其进行的操作，renderer进程是不知道的。换句话说，main进程对db进行了任何读写操作，renderer拿到的db依然是当初应用打开时所读取的db。所以就会遇到main进程更新了数据，而renderer进程依然无法拿到新的数据。</p><p>那有没有办法解决呢？有的。就是有点麻烦。那就是在所有的db操作的最开始，都重新读取一遍db的最新状态：</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.read().get(<span class="string">'xxx'</span>).value()</span><br><span class="line"></span><br><span class="line">db.read().set(<span class="string">'xxx'</span>, <span class="string">'xxx'</span>)</span><br></pre></td></tr></table></figure><p>强制在每个db操作前，都通过read()刷新一遍内存区，这样就能保证拿到的数据都是最新的啦。</p><h2 id="Vue里使用lowdb的便捷方法"><a href="#Vue里使用lowdb的便捷方法" class="headerlink" title="Vue里使用lowdb的便捷方法"></a>Vue里使用lowdb的便捷方法</h2><p>类似于很多人会在Vue里把axios挂在vue的原型链上一样，我们也可以用类似的方法来方便我们在Vue里使用lowdb。</p><p>打开Vue项目的入口文件，通常是<code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">'../datastore'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$db = db</span><br></pre></td></tr></table></figure><p>这样我们就可以在项目里，用<code>this.$db</code>的方法来使用lowdb啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细地介绍了lowdb以及lowdb在electron里的使用。很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到。如果本文能够给你带来帮助，那么将是我最开心的地方。如果喜欢，欢迎关注我的<a href="https://molunerfinn.com">博客</a>以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-5/&quot;&gt;通过CI发布以及更新的方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-6/&quot;&gt;开发插件系统——CLI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-7/&quot;&gt;开发插件系统——GUI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;想到再写…&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从之前的文章跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战1——Main进程和Renderer进程的简单开发</title>
    <link href="https://molunerfinn.com/electron-vue-2/"/>
    <id>https://molunerfinn.com/electron-vue-2/</id>
    <published>2018-01-17T10:55:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="Main进程和Renderer进程的基本认识"><a href="#Main进程和Renderer进程的基本认识" class="headerlink" title="Main进程和Renderer进程的基本认识"></a>Main进程和Renderer进程的基本认识</h2><p>从上一篇文章结尾部分我们运行成功的一个electron-vue的<a href="https://molunerfinn.com/electron-vue-1/#electron-vue%E5%AE%89%E8%A3%85">DEMO</a>来直观看看这两个进程的粗浅认识：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnh28jgs8nj20ms098wge" alt></p><p>可以看到Main进程管理的是这个app窗口（<a href="https://electronjs.org/docs/api/browser-window" target="_blank" rel="noopener">BrowserWindow</a>），而Renderer进程负责的就是我们熟悉的页面UI渲染。不过实际上，它们远远不仅如此。下面一张图能够把它们所支持、管理的electron或者原生的模块大致列出来：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhcn82n7sj21wu1fmn6v" alt="main &amp; renderer process tree"></p><blockquote><p>图中列出来的大部分模块都是我们会在开发过程中用到的。</p></blockquote><p>它们有各自的模块，也有共有的模块比如<code>clipboard</code>等。还有一部分是Main进程里的模块，不过可以通过<code>remote</code>模块，让renderer进程也能使用。比如<code>Menu</code>比如<code>shell</code>等。</p><p>了解一下哪些模块在哪些进程里，哪些模块可以通过<code>remote</code>模块让renderer进程也能使用是有必要的，这样我们后续开发的时候才能正确的使用。</p><p>上面的模块可能有些从名字里并不能看出作用是啥，没关系，后续的内容会慢慢涉及。</p><h2 id="Main进程开发"><a href="#Main进程开发" class="headerlink" title="Main进程开发"></a>Main进程开发</h2><p>上面说到了Main进程一个显著的作用就是创建app的窗口。我们来看看这个是怎么实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; app, BrowserWindow &#125; <span class="keyword">from</span> <span class="string">'electron'</span> <span class="comment">// 从electron引入app和BrowserWindow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080`</span> <span class="comment">// 开发模式的话走webpack-dev-server的url</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 创建窗口</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initial window options</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    height: <span class="number">563</span>,</span><br><span class="line">    useContentSize: <span class="literal">true</span>,</span><br><span class="line">    width: <span class="number">1000</span></span><br><span class="line">  &#125;) <span class="comment">// 创建一个窗口</span></span><br><span class="line"></span><br><span class="line">  mainWindow.loadURL(winURL) <span class="comment">// 加载窗口的URL -&gt; 来自renderer进程的页面</span></span><br><span class="line"></span><br><span class="line">  mainWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow) <span class="comment">// app准备好的时候创建窗口</span></span><br></pre></td></tr></table></figure><p>暂且先不管渲染进程里的页面长什么样，在app准备好的时候打开一个窗口只需要调用一个创建<code>BrowserWindow</code>的方法即可。</p><p>main进程里的开发有点当年写<code>jQuery</code>的样子，比较多的是事件驱动型的写法。</p><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>首先需要注意的是<a href="https://electronjs.org/docs/api/app" target="_blank" rel="noopener">app</a>的模块。这个模块是electron应用的骨架。它掌管着整个应用的生命周期钩子，以及很多其他事件钩子。</p><p>app的常用生命周期钩子如下：</p><ul><li><code>will-finish-launching</code> 在应用完成基本启动进程之后触发</li><li><code>ready</code> 当electron完成初始化后触发</li><li><code>window-all-closed</code> 所有窗口都关闭的时候触发，在windows和linux里，所有窗口都退出的时候<strong>通常</strong>是应用退出的时候</li><li><code>before-quit</code> 退出应用之前的时候触发</li><li><code>will-quit</code> 即将退出应用的时候触发</li><li><code>quit</code> 应用退出的时候触发</li></ul><p>而我们通常会在<code>ready</code>的时候执行创建应用窗口、创建应用菜单、创建应用快捷键等初始化操作。而在<code>will-quit</code>或者<code>quit</code>的时候执行一些清空操作，比如解绑应用快捷键。</p><p>特别的，在非<code>macOS</code>的系统下，通常一个应用的所有窗口都退出的时候，也是这个应用退出之时。所以可以配合<code>window-all-closed</code>这个钩子来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123; <span class="comment">// 当操作系统不是darwin（macOS）的话</span></span><br><span class="line">    app.quit() <span class="comment">// 退出应用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>除了上面说的生命周期钩子之外，还有一些常用的事件钩子：</p><ul><li><code>active</code>（仅macOS）当应用处于激活状态时</li><li><code>browser-window-created</code> 当一个BrowserWindow被创建的时候</li><li><code>browser-window-focus</code> 当一个BrowserWindow处于激活状态的时候</li></ul><p>这些钩子需要配合一些具体场景来做出具体的操作。比如当一个BrowserWindow处于激活状态的时候修改窗口的title值。</p><p>当然，app这个模块除了上述的一些事件钩子之外，还有一些很常用的方法：</p><ul><li><code>app.quit()</code> 用于退出应用</li><li><code>app.getPath(name)</code> 用于获取一些系统目录，对于存放应用的配置文件等很有用</li><li><code>app.focus()</code> 用于激活应用，不同系统激活逻辑<a href="https://electronjs.org/docs/api/app#appfocus" target="_blank" rel="noopener">不一样</a></li></ul><p>这些事件和方法都是怎么知道的呢？当然是<a href="https://electronjs.org/docs/" target="_blank" rel="noopener">官方文档</a>了。不过并不需要一开始就通读一遍官方的api文档。官方的api文档更多的作用是用来查阅，当你要开发到某个功能的时候再去查它能否有对应的api、怎么使用。</p><h3 id="BrowserWindow"><a href="#BrowserWindow" class="headerlink" title="BrowserWindow"></a>BrowserWindow</h3><p>BrowserWindow模块用于创建最常见的应用窗口。对于不同系统，创建的窗口的默认样式也不太一样。下面来看看macOS和windows的窗口在外观上的区别：</p><p>mac版的</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncs5yv0qdj21jk0wi44h" alt></p><p>windows版的</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdibuabmj20rq0h2whl" alt></p><p>可以看到二者在窗口顶部的操作区（最小化、最大化、关闭）和标题的位置以及菜单的位置还是有明显的不同的。它们跟系统原生的窗口是一致的。不过如果你想要美化一下也是没问题的。比如：</p><p>mac版的PicGo</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic" alt="picgo-mac"></p><p>和windows的PicGo</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdb9mj1uj20m80ci3yz" alt="picgo-windows"></p><p>其中mac版用了系统的操作区，而windows则没有用系统的操作区，而是用图标模拟的。不过同样的地方是都未使用系统默认的<code>titlebar</code>。这个之后会结合<code>renderer</code>进程来说。</p><p>让我们来看看创建一个BrowserWindow的常用配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span> = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    height: <span class="number">900</span>, <span class="comment">// 高</span></span><br><span class="line">    width: <span class="number">400</span>, <span class="comment">// 宽</span></span><br><span class="line">    show: <span class="literal">false</span>, <span class="comment">// 创建后是否显示</span></span><br><span class="line">    frame: <span class="literal">false</span>, <span class="comment">// 是否创建frameless窗口</span></span><br><span class="line">    fullscreenable: <span class="literal">false</span>, <span class="comment">// 是否允许全屏</span></span><br><span class="line">    center: <span class="literal">true</span>, <span class="comment">// 是否出现在屏幕居中的位置</span></span><br><span class="line">    backgroundColor: <span class="string">'#fff'</span> <span class="comment">// 背景色，用于transparent和frameless窗口</span></span><br><span class="line">    titleBarStyle: <span class="string">'xxx'</span> <span class="comment">// 标题栏的样式，有hidden、hiddenInset、customButtonsOnHover等</span></span><br><span class="line">    resizable: <span class="literal">false</span>, <span class="comment">// 是否允许拉伸大小</span></span><br><span class="line">    transparent: <span class="literal">true</span>, <span class="comment">// 是否是透明窗口（仅macOS）</span></span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>, <span class="comment">// 窗口模糊的样式（仅macOS）</span></span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span> <span class="comment">// 当页面被置于非激活窗口的时候是否停止动画和计时器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 以及其他可选配置</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.loadURL(url)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.on(<span class="string">'closed'</span>, () =&gt; &#123; <span class="built_in">window</span> = <span class="literal">null</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口的长宽自然不必说，需要指定。其中需要注意的几个比较重要的就是，<code>frame</code>这个选项，默认是<code>true</code>。如果选择了<code>false</code>则会创建一个<code>frameless</code><a href="https://electronjs.org/docs/api/frameless-window" target="_blank" rel="noopener">窗口</a>，创建一个没有顶部工具栏、没有border的窗口。这个也是我们在windows系统下自定义顶部栏的基础。</p><p>像上述PicGo的主窗口的配置，就是通过如下的配置实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSettingWindow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    height: <span class="number">450</span>,</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    show: <span class="literal">false</span>,</span><br><span class="line">    frame: <span class="literal">true</span>,</span><br><span class="line">    center: <span class="literal">true</span>,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    resizable: <span class="literal">false</span>,</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>,</span><br><span class="line">    transparent: <span class="literal">true</span>,</span><br><span class="line">    titleBarStyle: <span class="string">'hidden'</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123; <span class="comment">// 针对windows平台做出不同的配置</span></span><br><span class="line">    options.show = <span class="literal">true</span> <span class="comment">// 创建即展示</span></span><br><span class="line">    options.frame = <span class="literal">false</span> <span class="comment">// 创建一个frameless窗口</span></span><br><span class="line">    options.backgroundColor = <span class="string">'#3f3c37'</span> <span class="comment">// 背景色</span></span><br><span class="line">  &#125;</span><br><span class="line">  settingWindow = <span class="keyword">new</span> BrowserWindow(options)</span><br><span class="line"></span><br><span class="line">  settingWindow.loadURL(settingWinURL)</span><br><span class="line"></span><br><span class="line">  settingWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    settingWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟<code>app</code>模块一样，<code>BrowserWindow</code>也有很多常用的事件钩子：</p><ul><li><code>closed</code> 当窗口被关闭的时候</li><li><code>focus</code> 当窗口被激活的时候</li><li><code>show</code> 当窗口展示的时候</li><li><code>hide</code> 当窗口被隐藏的时候</li><li><code>maxmize</code> 当窗口最大化时</li><li><code>minimize</code> 当窗口最小化时</li><li><code>...</code></li></ul><p>当然，也依然有很多实用的方法：</p><ul><li><code>BrowserWindow.getFocusedWindow()</code> [静态方法]获取激活的窗口</li><li><code>win.close()</code> [实例方法，下同]关闭窗口</li><li><code>win.focus()</code> 激活窗口</li><li><code>win.show()</code> 显示窗口</li><li><code>win.hide()</code> 隐藏窗口</li><li><code>win.maximize()</code> 最大化窗口</li><li><code>win.minimize()</code> 最小化窗口</li><li><code>win.restore()</code> 从最小化窗口恢复</li><li><code>...</code></li></ul><p>针对不同的业务逻辑你需要对窗口进行不一样的操作。这个需要跟你的项目需求相匹配。比如上述说到的，windows的顶部的操作区（放大、缩小、关闭按钮）就可以通过icon模拟+实例方法来实现。</p><h3 id="Tray"><a href="#Tray" class="headerlink" title="Tray"></a>Tray</h3><p>一开始看这个名字你可能并不知道这个是个什么东西。可以把它理解为不同系统的任务栏里的图标组件吧。</p><p>比如在macOS里，<code>Tray</code>配合上图标之后就是顶部栏里的应用图标了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnijxxj5gkj215i01at9b" alt></p><p>比如在windows里，<code>Tray</code>配合上图标之后就是windows右下角的应用图标了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnijzo4hgbj20gl016a9z" alt></p><p>需要注意的是，windows和macOS里，图标的大小都是<code>16*16</code>px。macOS下顶部栏的图标通常都是走<code>黑白</code>路线，所以可以为两种系统分别准备不同的图标。<code>PicGo</code>里<code>Tray</code>的生成代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTray</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menubarPic = process.platform === <span class="string">'darwin'</span> ? <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span></span><br><span class="line">  tray = <span class="keyword">new</span> Tray(menubarPic) <span class="comment">// 指定图片的路径</span></span><br><span class="line">  <span class="comment">// ... 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上述代码里有一个<code>${__static}</code>的变量。该变量是<code>electron-vue</code>为我们暴露出来的项目根目录下的<code>static</code>文件夹的路径。通过这个路径，在开发和生产阶段都能很好的定位你的静态资源所在的目录。是个很方便的变量。</p><p>当然<code>Tray</code>并不只是一个图标而无其他作用了。Tray支持很多有用的事件。其中最关键的两个是<code>click</code>和<code>right-click</code>。分别对应鼠标左键点击和鼠标右键点击事件。</p><h4 id="鼠标左键点击事件"><a href="#鼠标左键点击事件" class="headerlink" title="鼠标左键点击事件"></a>鼠标左键点击事件</h4><ul><li>在macOS系统下，鼠标左键点击Tray的icon可能会出现配置菜单，也有可能会出现应用窗口。</li><li>在windows下，鼠标左键点击Tray的icon通常会出现应用的窗口。</li></ul><h4 id="鼠标右键点击事件"><a href="#鼠标右键点击事件" class="headerlink" title="鼠标右键点击事件"></a>鼠标右键点击事件</h4><ul><li>在macOS系统下，鼠标右键点击Tray的icon通常会出现配置菜单。</li><li>在windows系统下，同上。</li></ul><p>所以需要我们去适配不同操作系统下用户的操作习惯。</p><p>对应于PicGo而言，在macOS系统下左键点击会出现一个menubar的小窗口，右键点击会出现配置菜单。而在windows下，左键点击会直接出现主窗口，（因为在windows下无小窗口的必要），右键点击会出现配置菜单。它们在PicGo里的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTray</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menubarPic = process.platform === <span class="string">'darwin'</span> ? <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span></span><br><span class="line">  tray = <span class="keyword">new</span> Tray(menubarPic)</span><br><span class="line">  <span class="keyword">const</span> contextMenu = <span class="comment">// ...菜单</span></span><br><span class="line">  tray.on(<span class="string">'right-click'</span>, () =&gt; &#123; <span class="comment">// 右键点击</span></span><br><span class="line">    <span class="built_in">window</span>.hide() <span class="comment">// 隐藏小窗口</span></span><br><span class="line">    tray.popUpContextMenu(contextMenu) <span class="comment">// 打开菜单</span></span><br><span class="line">  &#125;)</span><br><span class="line">  tray.on(<span class="string">'click'</span>, () =&gt; &#123; <span class="comment">// 左键点击</span></span><br><span class="line">    <span class="keyword">if</span> (process.platform === <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果是macOS</span></span><br><span class="line">      toggleWindow() <span class="comment">// 打开或关闭小窗口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是windows</span></span><br><span class="line">      <span class="built_in">window</span>.hide() <span class="comment">// 隐藏小窗口</span></span><br><span class="line">      <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123; <span class="comment">// 如果主窗口不存在就创建一个</span></span><br><span class="line">        createSettingWindow()</span><br><span class="line">        settingWindow.show()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果主窗口在，就显示并激活</span></span><br><span class="line">        settingWindow.show()</span><br><span class="line">        settingWindow.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于macOS而言，Tray还有一个很棒的特性——可以拖拽文件到Tray的icon上，会触发如下事件：</p><ul><li><code>drop</code> 当任何东西拖拽到icon上时</li><li><code>drop-files</code> 当文件被拖拽到icon上时</li><li><code>drop-text</code> 当文本被拖拽到icon上时</li><li><code>drop-enter</code> 当刚拖拽到icon上时</li><li><code>drop-leave</code> 当拖拽事件离开icon时</li><li><code>drop-end</code> 当拖拽事件结束时</li></ul><p>就像PicGo实现的拖拽图片到Tray的icon上时实现图片上传的功能，就是用到了上述的一些事件：</p><p><img src="https://user-images.githubusercontent.com/12621342/34242310-b5056510-e655-11e7-8568-60ffd4f71910.gif" alt></p><p>尤其注意到在拖拽上的时候和拖拽结束后的时候icon是不一样的。在PicGo里是这样实现的，很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'drag-enter'</span>, () =&gt; &#123;</span><br><span class="line">  tray.setImage(<span class="string">`<span class="subst">$&#123;__static&#125;</span>/upload.png`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tray.on(<span class="string">'drag-end'</span>, () =&gt; &#123;</span><br><span class="line">  tray.setImage(<span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而<code>Tray</code>另一个重要的作用就是开启菜单项。这个将结合下一节<code>Menu</code>一起说明。</p><h3 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h3><p>electron威力强大的Menu组件，既能够生成系统菜单项，也能实现绑定应用常用快捷键的功能。</p><p>先来看看什么是系统菜单项：</p><blockquote><p>macOS</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnisjmm1f9j213m074wln" alt></p><blockquote><p>windows</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnisory5p4j215c0pen3z" alt></p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnislgodz9j204k047mx8" alt></p><p>主要分两种。</p><ul><li>第一种是app的菜单。对于macOS来说就是顶部栏左侧区域的菜单项。对于windows而言就是一个窗口的标题栏下方的菜单区。</li><li>第二种是类似于右键菜单的菜单。</li></ul><p>第一种菜单可以通过<code>Menu.setApplicationMenu()</code>来实现。</p><p>第二种菜单可以通过两个步骤来展示：</p><p><strong>1.</strong> 创建菜单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([...])</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 展示菜单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'right-click'</span>, () =&gt; &#123; <span class="comment">// 右键点击tray的时候</span></span><br><span class="line">  tray.popUpContextMenu(contextMenu) <span class="comment">// 弹出菜单</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们只介绍了<code>Menu</code>本身。其实组成<code>Menu</code>的是一个一个的<code>MenuItem</code>。它们有很多类型：</p><ol><li>normal</li><li>separator</li><li>submenu</li><li>checkbox</li><li>radio</li></ol><p>以及很多角色：</p><ol><li>quit</li><li>copy</li><li>redo</li><li>undo</li><li>minimize</li><li>close</li><li>reload</li><li>…</li></ol><p>通常来说，配置的菜单项基本从类型里来组合。比如PicGo的菜单项：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnivun40bij20fg082wgo" alt></p><p>这里面就有normal、submenu、checkbox和radio四种类型。其中默认是normal。</p><p>角色的话通常对应的是一些常见的行为。比如<code>quit</code>是退出app，比如<code>minimize</code>是最小化，比如<code>copy</code>是复制。不过需要注意的是，如果你没有在创建app菜单里指定这些操作的快捷键的话，那么一些常见的快捷操作就无法在你的app里使用了。比如<code>ctrl+c</code>或者<code>command+c</code>复制这个操作，如果你没有通过<code>Menu.setApplicationMenu()</code>来设定这个快捷键的话，那么在你的electron应用里就无法执行复制的操作了。PicGo在早期版本里也犯了这个<a href>错误</a>。当时的问题是我在开发模式下是没有问题的，但是在生产模式下就无法进行复制粘贴操作。后来查了一下原因，发现原来在开发模式下，electron会置入默认的一些快捷操作菜单，如图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnjcaoo0btj20pg0fcah1" alt></p><p>所以在生产模式如果我没有置入这些快捷键的话，使用者就无法使用了。<strong>这个是大坑</strong>。</p><p>说了这么多，来看看生成app的菜单的代码长啥样：</p><blockquote><p>注意，如果在开发模式下直接只使用如下快捷键的话，一些调试快捷键比如<code>F12</code>或者<code>command+shift+i</code>打开控制台的操作就无法使用了。所以在开发模式下不需要创建这些快捷键菜单。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createMenu = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> template = [&#123;</span><br><span class="line">      label: <span class="string">'Edit'</span>,</span><br><span class="line">      submenu: [</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Undo'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+Z'</span>, <span class="attr">selector</span>: <span class="string">'undo:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Redo'</span>, <span class="attr">accelerator</span>: <span class="string">'Shift+CmdOrCtrl+Z'</span>, <span class="attr">selector</span>: <span class="string">'redo:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">'separator'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Cut'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+X'</span>, <span class="attr">selector</span>: <span class="string">'cut:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Copy'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+C'</span>, <span class="attr">selector</span>: <span class="string">'copy:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Paste'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+V'</span>, <span class="attr">selector</span>: <span class="string">'paste:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Select All'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+A'</span>, <span class="attr">selector</span>: <span class="string">'selectAll:'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          label: <span class="string">'Quit'</span>,</span><br><span class="line">          accelerator: <span class="string">'CmdOrCtrl+Q'</span>,</span><br><span class="line">          click () &#123;</span><br><span class="line">            app.quit()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">    menu = Menu.buildFromTemplate(template)</span><br><span class="line">    Menu.setApplicationMenu(menu)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>accelerator</code>指定你想要的快捷键。诸如<code>Shift</code>、<code>Ctrl</code>、<code>Cmd</code>等键位缩写。如果是组合键，就加上<code>+</code>。尤其注意到，因为macOS和windows键位的差异，所以有一个很好用的键位缩写<code>CmdOrCtrl</code>，即如果是在macOS上就是<code>Cmd</code>，在windows上就是<code>Ctrl</code>。</p><p>然后再来看看Tray的“右键”菜单的生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'关于'</span>,</span><br><span class="line">     click () &#123;</span><br><span class="line">       dialog.showMessageBox(&#123;</span><br><span class="line">         title: <span class="string">'PicGo'</span>,</span><br><span class="line">         message: <span class="string">'PicGo'</span>,</span><br><span class="line">         detail: <span class="string">`Version: <span class="subst">$&#123;pkg.version&#125;</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'打开详细窗口'</span>,</span><br><span class="line">     click () &#123;</span><br><span class="line">       <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123;</span><br><span class="line">         createSettingWindow()</span><br><span class="line">         settingWindow.show()</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         settingWindow.show()</span><br><span class="line">         settingWindow.focus()</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'选择默认图床'</span>,</span><br><span class="line">     type: <span class="string">'submenu'</span>,</span><br><span class="line">     submenu: [</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'微博图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'weibo'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'weibo'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'七牛图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'qiniu'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'qiniu'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'腾讯云COS'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'tcyun'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'tcyun'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'又拍云图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'upyun'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'upyun'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'打开更新助手'</span>,</span><br><span class="line">     type: <span class="string">'checkbox'</span>,</span><br><span class="line">     checked: db.get(<span class="string">'picBed.showUpdateTip'</span>).value(),</span><br><span class="line">     click () &#123;</span><br><span class="line">       <span class="keyword">const</span> value = db.read().get(<span class="string">'picBed.showUpdateTip'</span>).value()</span><br><span class="line">       db.read().set(<span class="string">'picBed.showUpdateTip'</span>, !value).write()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     role: <span class="string">'quit'</span>,</span><br><span class="line">     label: <span class="string">'退出'</span></span><br><span class="line">   &#125;</span><br><span class="line"> ])</span><br><span class="line"></span><br><span class="line"> tray.on(<span class="string">'right-click'</span>, () =&gt; &#123;</span><br><span class="line">   tray.popUpContextMenu(contextMenu)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>注意，菜单项的点击事件可以直接通过<code>click</code>属性来指定。上面我们是先通过了<code>Menu.buildFromTemplate()</code>这个方法创建了菜单，然后再在右键点击<code>Tray</code>图标的时候将其弹（PopUp)出来。</p><p>当然也有其他构建菜单的方法。可以通过Menu实例的<code>append</code>方法来加入<code>Menu Item</code>。如下例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> menu = <span class="keyword">new</span> Menu()</span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">label</span>: <span class="string">'Cut'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+X'</span> &#125;))</span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">type</span>: <span class="string">'separator'</span> &#125;)) <span class="comment">// 分割线</span></span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">label</span>: <span class="string">'Helper'</span>, <span class="attr">type</span>: <span class="string">'checkbox'</span>, <span class="attr">checked</span>: <span class="literal">true</span> &#125;))</span><br></pre></td></tr></table></figure><p>基本上有了上述的几个基本模块，我们的一个应用的骨架是基本搭建好了，拥有窗口、任务栏应用图标和菜单项。其他的Main进程的模块，并不是必须的，当会用到的时候将在之后的文章里逐步提及。下一节我们将来看renderer进程的开发。</p><h2 id="Renderer进程开发"><a href="#Renderer进程开发" class="headerlink" title="Renderer进程开发"></a>Renderer进程开发</h2><p>对于<code>electron-vue</code>而言，renderer进程其实大部分就是在写我们平时常写的前端页面罢了。不过相对于平时在浏览器里写的页面，在electron里写页面的时候你还能用到不少非浏览器端的模块，比如<code>fs</code>，比如electron通过<code>remote</code>模块暴露给renderer进程的模块。接下去我们来看看renderer进程有哪些需要注意的地方。</p><h3 id="请使用Hash模式"><a href="#请使用Hash模式" class="headerlink" title="请使用Hash模式"></a>请使用Hash模式</h3><p>往常我们在写Vue的时候都比较喜欢开启路由的<code>history</code>模式，因为这样在浏览器的地址栏上看起来比较好看——没有hash的<code>#</code>号，就如同请求后端的url一般。然而需要注意的是，<code>history</code>模式需要后端服务器的支持。</p><p>可能很多朋友平时开发的时候没有感觉，那是因为vue-cli里在开发模式下启动的<code>webpack-dev-server</code>帮你实现了服务端的<code>history-fallback</code>的特性。所以在实际部署的时候，至少都需要在你的web服务器程序诸如<code>nginx</code>、<code>apache</code>等配置相关的规则，让前端路由返回给<code>vue-router</code>去处理。</p><p>而electron里也是如此。在开发模式下，由于使用的是<code>webpack-dev-server</code>开启的服务器，所以<code>BrowserWindow</code>加载的是来自于类似<code></code><a href="http://localhost:9080`这样的地址的页面。而在生产模式下，却是使用的`file://`的协议，比如`file://${__dirname}/index.html`来指定窗口加载的页面。" target="_blank" rel="noopener">http://localhost:9080`这样的地址的页面。而在生产模式下，却是使用的`file://`的协议，比如`file://${__dirname}/index.html`来指定窗口加载的页面。</a></p><p>因此，从上面的表述你也能明白了。假如我有一个子路由地址为<code>child</code>。如果不启用Hash模式，在开发模式下没啥问题，<code>http://localhost:9080/child</code>，但是在生产模式下，<code>file://${__dirname}/index.html/child</code>却是无法匹配的一条路径。因此在electron下，<code>vue-router</code>请不要使用<code>history</code>模式，而使用默认的<code>hash</code>模式。</p><p>那么上面的问题就迎刃而解，变为<code>file://${__dirname}/index.html#child</code>即可。</p><p>PicGo里加载的页面路由规则如下，从中你也能看出我使用的是<code>hash</code>模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> winURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br><span class="line"><span class="keyword">const</span> settingWinURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080/#setting/upload`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html#setting/upload`</span></span><br></pre></td></tr></table></figure><h3 id="实现自己的titlebar"><a href="#实现自己的titlebar" class="headerlink" title="实现自己的titlebar"></a>实现自己的titlebar</h3><p>在上面讲<code>BrowserWindow</code>的时候，我说到有时为了应用的美观，并不想让我们的应用窗口采用系统默认的<code>titlebar</code>，而想用自己写的来实现。这样的话就在创建你的<code>BrowserWindow</code>的配置里加上一句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titleBarStyle: <span class="string">'hidden'</span></span><br></pre></td></tr></table></figure><p>这样就行了。然后你就可以自行在renderer进程的页面里模拟一个顶部的<code>titlebar</code>了，比如上面提到的<code>PicGo</code>的<code>titlebar</code>的样子。实际上代码也很简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fake-title-bar"</span>&gt;</span></span><br><span class="line">  PicGo - &#123;&#123; version &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"handle-bar"</span> <span class="attr">v-if</span>=<span class="string">"os === 'win32'"</span>&gt;</span> <span class="comment">&lt;!-- 如果是windows系统 就加上模拟的操作按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-minus"</span> @<span class="attr">click</span>=<span class="string">"minimizeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-close"</span> @<span class="attr">click</span>=<span class="string">"closeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后把这个titlebar的position置顶即可。</p><p>不过在平时的使用中，我们要注意，一般我们鼠标按住titlebar的时候是可以拖动窗口的。但是如果我们在不加可拖拽的属性之前，我们自己写的titlebar是不具备这样的特性的。要加上这个特性也很简单：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fake-title-bar</span> &#123;</span><br><span class="line">  -webkit-app-region drag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需一条CSS，即可让你的titlebar可以拖拽。</p><p>不过在windows下，操作区的按钮（缩小、放大、关闭）长按应该是不能拖拽的，所以还需要：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.handle-bar</span> &#123;</span><br><span class="line">  -webkit-app-region no-drag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成<code>no-drag</code>，这样就实现了我们自己生成应用的titlebar了。</p><h3 id="drag-amp-drop的避免"><a href="#drag-amp-drop的避免" class="headerlink" title="drag&amp;drop的避免"></a>drag&amp;drop的避免</h3><p>通常我们用Chrome的时候，有个特性是比如你往Chrome里拖入一个pdf，它就会自动用内置的pdf阅读器打开。你往Chrome里拖入一张图片，它就会打开这张图片。由于我们的electron应用的<code>BrowserWindow</code>其实内部也是一个浏览器，所以这样的特性依然存在。而这也是很多人没有注意的地方。也就是当你开发完一个electron应用之后，往里拖入一张图片，一个pdf等等，如果不是一个可拖拽区域（比如PicGo的上传区），那么它就不应该打开这张图、这个pdf，而是将其排除在外。</p><p>所以我们将在全局监听<code>drag</code>和<code>drop</code>事件，当用户拖入一个文件但是又不是拖入可拖拽区域的时候，应该将其屏蔽掉。因为所有的页面都应该要有这样的特性，所以我写了一个vue的<code>mixin</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.disableDragEvent()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    disableDragEvent () &#123;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'dragenter'</span>, <span class="keyword">this</span>.disableDrag, <span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'dragover'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'drop'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">    &#125;,</span><br><span class="line">    disableDrag (e) &#123;</span><br><span class="line">      <span class="keyword">const</span> dropzone = <span class="built_in">document</span>.getElementById(<span class="string">'upload-area'</span>) <span class="comment">// 这个是可拖拽的上传区</span></span><br><span class="line">      <span class="keyword">if</span> (dropzone === <span class="literal">null</span> || !dropzone.contains(e.target)) &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        e.dataTransfer.effectAllowed = <span class="string">'none'</span></span><br><span class="line">        e.dataTransfer.dropEffect = <span class="string">'none'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'dragenter'</span>, <span class="keyword">this</span>.disableDrag, <span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'dragover'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'drop'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在全局引入这个mixin即可。</p><h3 id="remote模块的使用"><a href="#remote模块的使用" class="headerlink" title="remote模块的使用"></a>remote模块的使用</h3><p>remote模块是electron为了让一些原本在Main进程里运行的模块也能在renderer进程里运行而创建的。以下说几个我们会用到的。</p><p>在<code>electron-vue</code>里内置了<code>vue-electron</code>这个模块，可以在vue里很方便的使用诸如<code>this.$electron.remote.xxx</code>来使用remote的模块。</p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p><code>shell</code>模块的官方说明是：<code>Manage files and URLs using their default applications.</code>也就是使用文件或者URL的默认应用。通常我们可以用其让默认图片应用打开一张图片、让默认浏览器打开一个url。</p><p>如果我们想在renderer进程里点击一个按钮然后在默认浏览器里打开一个url的话就可以这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"openURL"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      openURL () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$electron.remote.shell.openExternal(<span class="string">'https://github.com/Molunerfinn/PicGo'</span>)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是不是很方便？</p><p>更多详细的shell的用法可以参考<a href="https://electronjs.org/docs/api/shell" target="_blank" rel="noopener">文档</a>。</p><h4 id="dialog"><a href="#dialog" class="headerlink" title="dialog"></a>dialog</h4><p>有的时候我们会有打开原生的对话框的需求。比如<code>PicGo</code>的版本信息：</p><blockquote><p>macOS</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnje5uvnlrj20nc08kq3d" alt></p><blockquote><p>windows</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnje4njzafj20a60543yd" alt></p><p>这个时候就可以通过<code>dialog</code>这个模块来实现了。逻辑跟上面一样也是点击一个按钮打开一个dialog：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openDialog () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$electron.remote.dialog.showMessageBox(&#123;</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    message: <span class="string">'PicGo'</span>,</span><br><span class="line">    detail: <span class="string">`Version: <span class="subst">$&#123;pkg.version&#125;</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细的dialog的用法可以参考<a href="https://electronjs.org/docs/api/dialog" target="_blank" rel="noopener">文档</a>。</p><h4 id="Menu和BrowserWindow的应用"><a href="#Menu和BrowserWindow的应用" class="headerlink" title="Menu和BrowserWindow的应用"></a>Menu和BrowserWindow的应用</h4><p>使用<code>Menu</code>可能很多人能够理解。但是为什么要使用<code>BrowserWindow</code>呢？因为需要定位你打开<code>Menu</code>的窗口。</p><p>在PicGo里，有一个点击按钮打开Menu的操作，大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildMenu () &#123;</span><br><span class="line">    <span class="keyword">const</span> template = [...]</span><br><span class="line">    <span class="keyword">this</span>.menu = Menu.buildFromTemplate(template)</span><br><span class="line">  &#125;,</span><br><span class="line">  openDialog () &#123;</span><br><span class="line">    <span class="keyword">this</span>.menu.popup(remote.getCurrentWindow) <span class="comment">// 获取当前打开Menu的窗口</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>menu.popup</code>就需要你指定一下打开这个menu的窗口。它将自动定位你点击的位置而弹出。</p><h3 id="main进程和renderer进程的通信"><a href="#main进程和renderer进程的通信" class="headerlink" title="main进程和renderer进程的通信"></a>main进程和renderer进程的通信</h3><p>在Vue里，如果是非父子组件通信，很常用的是通过<code>Bus Event</code>来实现的。而electron里的不同进程间的通信其实也很类似，是通过<code>ipcMain</code>和<code>ipcRenderer</code>来实现的。其中<code>ipcMain</code>是在<code>main</code>进程里使用的，而<code>ipcRenderer</code>是在<code>renderer</code>进程里使用的。</p><h4 id="ipcMain和ipcRenderer"><a href="#ipcMain和ipcRenderer" class="headerlink" title="ipcMain和ipcRenderer"></a>ipcMain和ipcRenderer</h4><p>官网的例子其实很简洁明了了，我放出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main process.</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcMain&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line">ipcMain.on(<span class="string">'asynchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg)  <span class="comment">// prints "ping"</span></span><br><span class="line">  event.sender.send(<span class="string">'asynchronous-reply'</span>, <span class="string">'pong'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ipcMain.on(<span class="string">'synchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg)  <span class="comment">// prints "ping"</span></span><br><span class="line">  event.returnValue = <span class="string">'pong'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In renderer process (web page).</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ipcRenderer.sendSync(<span class="string">'synchronous-message'</span>, <span class="string">'ping'</span>)) <span class="comment">// prints "pong"</span></span><br><span class="line"></span><br><span class="line">ipcRenderer.on(<span class="string">'asynchronous-reply'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg) <span class="comment">// prints "pong"</span></span><br><span class="line">&#125;)</span><br><span class="line">ipcRenderer.send(<span class="string">'asynchronous-message'</span>, <span class="string">'ping'</span>)</span><br></pre></td></tr></table></figure><p>其中<code>ipcMain</code>只有监听来自<code>ipcRenderer</code>的某个事件后才能返回给<code>ipcRenderer</code>值。而<code>ipcRenderer</code>既可以收，也可以发。</p><p>那么问题就来了，如何让<code>ipcMain</code>主动发送消息呢？或者说让main进程主动发送消息给<code>ipcRenderer</code>。</p><p>首先要明确的是，<code>ipcMain</code>无法主动发消息给<code>ipcRenderer</code>。因为ipcMain只有<code>.on()</code>方法没有<code>.send()</code>的方法。所以只能用其他方法来实现。有办法么？有的，用<code>webContents</code>。</p><h4 id="webContents"><a href="#webContents" class="headerlink" title="webContents"></a>webContents</h4><p><code>webContents</code>其实是<code>BrowserWindow</code>实例的一个属性。也就是如果我们需要在<code>main</code>进程里给某个窗口某个页面发送消息，则必须通过<code>win.webContents.send()</code>方法来发送。</p><p>代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main process</span></span><br><span class="line"><span class="keyword">let</span> win = <span class="keyword">new</span> BrowserWindow(&#123;...&#125;)</span><br><span class="line">win.webContents.send(<span class="string">'img-files'</span>, imgs)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In renderer process</span></span><br><span class="line">ipcRenderer.on(<span class="string">'img-files'</span>, (event, files) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(files)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以必须指定要发送的窗口，才能将信息准确送达。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细地讲述了electron里<code>Main</code>进程和<code>Renderer</code>进程的基础知识和开发相关。很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。内容相比第一篇多了不少，希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到。希望本文能够给你带来帮助，这是我最开心的地方。如果喜欢，欢迎关注我的博客以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-5/&quot;&gt;通过CI发布以及更新的方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-6/&quot;&gt;开发插件系统——CLI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-7/&quot;&gt;开发插件系统——GUI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;想到再写…&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;&lt;p&gt;如果之前的文章没阅读的朋友可以先从之前的文章跟着看。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron-vue开发实战0——Electron-vue入门</title>
    <link href="https://molunerfinn.com/electron-vue-1/"/>
    <id>https://molunerfinn.com/electron-vue-1/</id>
    <published>2018-01-11T17:30:00.000Z</published>
    <updated>2019-03-17T14:42:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><a id="more"></a><h2 id="Electron简要介绍"><a href="#Electron简要介绍" class="headerlink" title="Electron简要介绍"></a>Electron简要介绍</h2><p>一开始学习electron的时候，我被官网文档密密麻麻的概念所镇住了：</p><p><img src="https://ws1.sinaimg.cn/mw690/8700af19ly1fncsj44xlhj21xy3e8x1g" alt></p><p>概念太多，没有办法一下子接受。所以我自己学习完electron开发后，做了一张图。来看看图理解一下什么是<code>electron</code>，以及它包括了啥：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncq342rk8j20cs0d63zd" alt></p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>electron由Node.js+Chromium+Native APIs构成。你可以理解成，它是一个得到了Node.js和基于不同平台的Native APIs加强的Chromium浏览器，可以用来开发跨平台的桌面级应用。</p><p>它的开发主要涉及到两个进程的协作——Main（主）进程和Renderer（渲染）进程。简单的理解两个进程的作用：</p><ol><li>Main进程主要通过Node.js、Chromium和Native APIs来实现一些系统以及底层的操作，比如创建系统级别的菜单，操作剪贴板，创建APP的窗口等。</li><li>Renderer进程主要通过Chromium来实现APP的图形界面——就是平时我们熟悉的前端开发的部分，不过得到了electron给予的加强，一些Node的模块（比如fs）和一些在Main进程里能用的东西（比如Clipboard）也能在Render进程里使用。</li><li>Main进程和Renderer进程通过<code>ipcMain</code>和<code>ipcRenderer</code>来进行通信。通过事件监听和事件派发来实现两个进程通信，从而实现Main或者Renderer进程里不能实现的某些功能。</li></ol><h3 id="进一步介绍"><a href="#进一步介绍" class="headerlink" title="进一步介绍"></a>进一步介绍</h3><p>说完了electron的组成和需要我们开发的部分，来说说它的优缺点。</p><p>优点：</p><ol><li>从上述介绍可以发现，除了不同平台Native APIs不同以外，Node.js和Chromium都是跨平台的工具，这也为electron生来就能做跨平台的应用开发打下基础。</li><li>开发图形界面前所未有的容易——比起C#\QT\MFC等传统图形界面开发技术，通过前端的图形化界面开发明显更加容易和方便。得益于Chromium，这种开发模式得以实现。</li><li>成熟的社区、活跃的核心团队，大部分electron相关的问题你可以在社区、github issues、Stack Overflow里得到答案。开发的障碍进一步降低。</li></ol><p>缺点：</p><ol><li>应用体积过大。由于内部包装了Chromium和Node.js，使得打包体积（使用<code>electron-builder</code>）在mac上至少是45M+起步，在windows上稍微好一点，不过也要35M+起步。不过相比早期打包体积100M+起步来说，已经好了不少。不过解压后安装依然是100M+起步。</li><li>受限于Node.js和Native APIs的一些支持度的问题，它依然有所局限。一些功能依然无法实现。比如无法获取在系统文件夹里选中的文件，而必须调用web的File或者node的fs接口才可以访问系统文件。</li><li>应用性能依旧是个问题。所以做轻量级应用没问题，重量级应用尤其是CPU密集型应用的话很是问题。</li></ol><h2 id="electron-vue的简要介绍"><a href="#electron-vue的简要介绍" class="headerlink" title="electron-vue的简要介绍"></a>electron-vue的简要介绍</h2><p>由于我自己是Vue的技术栈，所以就想在electron里使用vue。而vue只是在renderer进程里使用的框架，不涉及到main进程。如下图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncpxesazgj20dy08kwf1" alt></p><blockquote><p>因此react、angluar以及其他的前端开发框架同样适用。</p></blockquote><p>不过想要做到把vue和electron结合起来并不是一件特别容易的事。为了方便开发，我使用的是<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>，这个是开发者<a href="https://github.com/SimulatedGREG" target="_blank" rel="noopener">SimulatedGREG</a>参考vue-cli的webpack模板骨架搭建的electron和vue结合的开发脚手架。由于我对于<code>vue-cli</code>非常熟悉，所以上手<code>electron-vue</code>非常容易。相比很多其他的教程或者其他electron+前端开发框架的组装方案，<code>electron-vue</code>给我感觉最好的是如下：</p><ol><li>只有一个<code>package.json</code>。而大部分其他的项目结构依然在使用两个<code>package.json</code>来应对main进程和renderer进程的依赖库。</li><li>内建完整的vue全家桶，省去再次配置vue-router和vuex的一些初期操作。</li><li>内建完整的webpack开发、生产等配置，开发环境舒适。</li><li>内建完整的开发、构建等<code>npm scripts</code>，使用非常方便。</li><li>内建完整的Travis-ci、Appveyor配置脚本，只需少数修改就能做到利用CI自动构建的应用发布。</li><li>完善的文档，清晰的项目结构。</li></ol><p>大体的项目结构如下，根据选择的不同设置结构会有所不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">my-project</span><br><span class="line">├─ .electron-vue</span><br><span class="line">│  └─ &lt;build/development&gt;.js files</span><br><span class="line">├─ build</span><br><span class="line">│  └─ icons/</span><br><span class="line">├─ dist</span><br><span class="line">│  ├─ electron/</span><br><span class="line">│  └─ web/</span><br><span class="line">├─ node_modules/</span><br><span class="line">├─ src</span><br><span class="line">│  ├─ main <span class="comment"># 主进程</span></span><br><span class="line">│  │  ├─ index.dev.js</span><br><span class="line">│  │  └─ index.js</span><br><span class="line">│  ├─ renderer <span class="comment"># 渲染进程</span></span><br><span class="line">│  │  ├─ components/</span><br><span class="line">│  │  ├─ router/</span><br><span class="line">│  │  ├─ store/</span><br><span class="line">│  │  ├─ App.vue</span><br><span class="line">│  │  └─ main.js</span><br><span class="line">│  └─ index.ejs</span><br><span class="line">├─ static/</span><br><span class="line">├─ <span class="built_in">test</span></span><br><span class="line">│  ├─ e2e</span><br><span class="line">│  │  ├─ specs/</span><br><span class="line">│  │  ├─ index.js</span><br><span class="line">│  │  └─ utils.js</span><br><span class="line">│  ├─ unit</span><br><span class="line">│  │  ├─ specs/</span><br><span class="line">│  │  ├─ index.js</span><br><span class="line">│  │  └─ karma.config.js</span><br><span class="line">│  └─ .eslintrc</span><br><span class="line">├─ .babelrc</span><br><span class="line">├─ .eslintignore</span><br><span class="line">├─ .eslintrc.js</span><br><span class="line">├─ .gitignore</span><br><span class="line">├─ package.json</span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure><p>可以看到我们主要关注的两个文件夹：<code>src/main</code>和<code>src/renderer</code>分别对应的是main进程和renderer进程。我们的开发大体上也是围绕这两个文件夹展开。</p><h2 id="electron-vue安装"><a href="#electron-vue安装" class="headerlink" title="electron-vue安装"></a>electron-vue安装</h2><p>参考<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>官方的文档给出的说明，搭建electron-vue的脚手架非常方便，使用vue-cli来安装它的模板即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你没有vue-cli的话需要全局安装</span></span><br><span class="line">npm install -g vue-cli</span><br><span class="line"><span class="comment"># 然后使用vue-cli来安装electron-vue的模板</span></span><br><span class="line">vue init simulatedgreg/electron-vue my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> my-project</span><br><span class="line">yarn <span class="comment"># or npm install</span></span><br><span class="line"><span class="comment"># 进入开发模式</span></span><br><span class="line">yarn run dev <span class="comment"># or npm run dev</span></span><br></pre></td></tr></table></figure><p>如果你是windows用户，在安装期间遇到了关于<code>node-gyp</code>、C++库等方面的问题的话，请参考官方文档给出的<a href="https://simulatedgreg.gitbooks.io/electron-vue/content/en/getting_started.html#a-note-for-windows-users" target="_blank" rel="noopener">解决办法</a>。</p><p>如果上述都没有问题，那么你将会看到如下界面：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncs5yv0qdj21jk0wi44h" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为开篇，内容不多。不过把东西说清楚是必须的。对于electron开发其实是有两种声音的：</p><ol><li>很简单，不过就是web开发换了个壳</li><li>很难，需要了解很多原生的概念，不知道要怎么入手</li></ol><p>其实从本文介绍完，你应该要有一个粗略的认识。electron的开发其实包括了两个部分，一个是main进程的相关开发，一个是renderer进程的相关开发。对于renderer进程的开发对于大多数前端开发人员来说不难。main进程的相关开发，如果你想要把electron的main进程的所以特性都学一遍、都用一遍，确实是需要不少时间的。不过如果是从需求出发，从工程本身的需要出发，那么只需要用到的时候再去学习即可。不过要对Node.js能做到的事有个概念——它并不是万能的。</p><p>下一篇文章将会正式开启electron的开发，如果你对此有兴趣不妨关注我的博客的进展。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间，我用&lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;electron-vue&lt;/a&gt;开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——&lt;a href=&quot;https://github.com/Molunerfinn/PicGo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PicGo&lt;/a&gt;，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。&lt;/p&gt;&lt;p&gt;预计将会从几篇系列文章或方面来展开：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-1/&quot;&gt;electron-vue入门&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-2/&quot;&gt;Main进程和Renderer进程的简单开发&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-3/&quot;&gt;引入基于Lodash的JSON database——lowdb&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-4/&quot;&gt;跨平台的一些兼容措施&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-5/&quot;&gt;通过CI发布以及更新的方式&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-6/&quot;&gt;开发插件系统——CLI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://molunerfinn.com/electron-vue-7/&quot;&gt;开发插件系统——GUI部分&lt;/a&gt;&lt;/li&gt;&lt;li&gt;想到再写…&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;PicGo&lt;/code&gt;是采用&lt;code&gt;electron-vue&lt;/code&gt;开发的，所以如果你会&lt;code&gt;vue&lt;/code&gt;，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如&lt;code&gt;react&lt;/code&gt;、&lt;code&gt;angular&lt;/code&gt;，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://molunerfinn.com/categories/Web/"/>
    
      <category term="开发" scheme="https://molunerfinn.com/categories/Web/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端" scheme="https://molunerfinn.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="https://molunerfinn.com/tags/Vue/"/>
    
      <category term="Electron" scheme="https://molunerfinn.com/tags/Electron/"/>
    
      <category term="Electron-vue" scheme="https://molunerfinn.com/tags/Electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>2017小结</title>
    <link href="https://molunerfinn.com/2017-summary/"/>
    <id>https://molunerfinn.com/2017-summary/</id>
    <published>2017-12-27T21:01:00.000Z</published>
    <updated>2019-03-17T14:42:12.470Z</updated>
    
    <content type="html"><![CDATA[<p>年末了，赶着刚考完两门考试，在最后4门考试来临之前抽空写一下今年的小结。</p><a id="more"></a><p>今年格外忙。忙完本科毕设，又马上投入了研究生实验室的搬砖生涯。跟去年一样，列个今年的学习成果清单：</p><h1 id="过去的一年"><a href="#过去的一年" class="headerlink" title="过去的一年"></a>过去的一年</h1><h2 id="技术成果"><a href="#技术成果" class="headerlink" title="技术成果"></a>技术成果</h2><p><strong>2017.03~2017.05.07</strong> 开坑学习Three.js，完成了一个简单的<a href="https://github.com/Molunerfinn/Gear-system" target="_blank" rel="noopener">机械装置展示平台</a>（我的本科毕设）【Three.js+dat.gui】</p><p><strong>2017.05.23~2017.07.15</strong> 基于vue2+koa2重构了<a href="https://fj.teamsz.xyz/" target="_blank" rel="noopener">福建北邮人服务系统</a>，这是我自己的项目。开始引入eslint（以前嫌麻烦233），以后的项目也一并引入。期间在手写一些常用Vue组件的时候学习了不少东西，写了一篇<a href="https://molunerfinn.com/vue-components/">Vue组件的三种调用方式</a>【Vue2+Koa2】</p><p><strong>2017.05.26</strong> 为了上面那个项目简单做了一个基于<code>stylus</code>的栅格系统css——<a href="https://github.com/Molunerfinn/Melody.css" target="_blank" rel="noopener">Melody.css</a>，用来快速做响应式开发。【stylus】</p><p><strong>2017.06.07</strong> 协助解决实验室Vue项目里webpack的Hot Reload速度太慢的问题，做了个webpack的开发模式的插件<a href="https://github.com/Molunerfinn/webpack-dev-compile-optimize" target="_blank" rel="noopener">webpack-dev-compile-optimize</a>提升热重载速度（只在自己内部项目测试过），同期总结了一篇基于<a href="https://molunerfinn.com/Webpack-Optimize/">vue-cli项目的webpack构建优化文章</a>。【webpack】</p><p><strong>2017.07.07</strong> 博客开启持久化构建，依赖于github-page，不过加上了https以及进入了HSTS列表。第一次接触了<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis-CI</a>，发表了一篇<a href="https://molunerfinn.com/hexo-travisci-https/">经验文</a>。【Travis-CI】</p><p><strong>2017.08.09</strong> 开坑<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>，写一个送给妹子的hexo主题，效果见<a href="https://molunerfinn.com">我博客</a>即是。【hexo hexo-theme】</p><p><strong>2017.10.09</strong> 写每周电影推荐的时候因为嫌弃获取电影信息步骤繁杂，于是改造了一下早期写的node小爬虫<a href="https://github.com/Molunerfinn/dbmovie-spider" target="_blank" rel="noopener">dbmovie-spider</a>支持读取命令行信息了。【node】</p><p><strong>2017.10.28</strong> 开始<a href="https://github.com/Molunerfinn/FE-Learning" target="_blank" rel="noopener">练习算法</a>，并借机学习TypeScript和前端测试（采用了Jest）。 不过后来一直有其他事压着，没有持续，等考完试要继续。【TypeScript Jest】</p><p><strong>2017.11.02</strong> 开坑<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>项目的前端测试。同期写了一篇<a href="https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/">Jest 全栈测试的经验</a>博客。【Jest】</p><p><strong>2017.11.18</strong> 开坑<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，学习electron的基本开发流程，边写边学。最终完成了一个我现在写博客贴图片时很方便的工具。并于12月中发布正式版，还上了少数派首页推荐。【electron】</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fmvr6uah8rj21z20vk7wh" alt></p><blockquote><p>PS，在掘金也发了一遍<a href="https://juejin.im/post/5a30e4755188256e7a06cc3e" target="_blank" rel="noopener">推荐</a>不过没有被推荐到首页T T</p></blockquote><p>之后应该会发几篇electron开发的文章。</p><p><strong>2017.11.30</strong> 抽空把vue-koa-demo的<a href="https://github.com/Molunerfinn/vue-koa-demo/tree/ssr" target="_blank" rel="noopener">ssr</a>版本做了一下。踩了一些ssr的坑。</p><p>对比去年给自己立的目标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**算法**</span><br><span class="line"></span><br><span class="line">**数据结构**</span><br><span class="line"></span><br><span class="line">**Three.js -&gt; 浏览器3D建模**</span><br><span class="line"></span><br><span class="line">**回归JS语言基础**</span><br><span class="line"></span><br><span class="line">**学会玩Webpack2**</span><br><span class="line"></span><br><span class="line">**持续的项目开源**</span><br><span class="line"></span><br><span class="line">**Python简单入门**</span><br></pre></td></tr></table></figure><p>感觉除了Python没怎么学之外(尴尬)，其他的目标大致都有所建树，算是完成地还不错吧！</p><h2 id="期望、目标"><a href="#期望、目标" class="headerlink" title="期望、目标"></a>期望、目标</h2><p>依然要写下2018年需要学习的东西：</p><ul><li>算法、数据结构</li><li>Parcel</li><li>TypeScript</li><li>Puppeteer自动化测试</li><li>PWA</li><li>给开源库提PR</li><li>github robot</li><li>如果可以，学习一下react</li></ul><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>这一年来的前端的学习之路，收获还是不少的。比起去年来说，我自己觉得收获最大的就是在开源社区跟开发者、使用者的交流更多了。因为自己也有开源项目，所以很多时候一些情况也是第一次见：比如第一次遇到PR（开心不已），第一次给开源库提issue，第一次跟开发者讨论项目细节等等。今年还没有给开源库提过PR，所以明年的目标是来一个吧~</p><p>今年也是前端框架、库井喷的一年。各种新的技术涌现、较新的技术逐渐走向成熟、成熟的项目走向稳定。这种感觉似乎从我两年半前学习前端的时候就有了，不过今年真的特别强烈。也因此才有那篇流传甚广的《2017年学JavaScript是怎样的一种体验》。前端要学的东西太多了啊。不过我觉得虽然看似多，作为前端工程师，还是要有自己的大体学习路线。</p><p>我认为如今前端工程师应当分成两类，</p><ol><li>结合Node的偏向全栈的前端，他们更注重网站的访问优化、性能提升、毫秒级别的用户体验。</li><li>结合CSS\JS的偏向用户端特效的“纯”前端工程师。这部分的前端工程师通常来说必须要有自己的设计认知。</li></ol><p>很多优秀的前端工程师都是设计师出身。比如TJ，比如尤雨溪。但是却不是很常听说优秀的设计师是前端工程师出身。这就是因为现在很多学前端的人还是在认为自己能够写个页面、套个模板，厉害点的还原个页面就行了。殊不知，你要学习的不仅仅是前端配套的HTML\CSS\JS，你还需要知道结合了Nodejs后带来的一系列现代开发工具和工程化的流程。不再是只会用个bootstrap+jquery做个页面就完事的年代了。刀耕火种的年代已经过去，可是还是有人在抓着旧石器不放。</p><p>不过还是需要强调一下，基础真的很重要。我身边遇到太多半路“出家”，自愿也好，被迫也罢来学前端的同学，他们很多都是草草几天看完HTML\CSS\JS基础，然后就直接用上Vue、React来写项目了。连npm都不知道是什么东西的他们，很多时候写起前端来非常痛苦。前端不再是以前那样认为的是一门可以速成的技术了啊，现在而言，至少入门门槛高了不少。</p><p>前端圈还是太浮躁了点。还是沉下心来，好好钻研自己喜欢的技术吧。</p><p>另外，由于最近出现的诸如PWA、Electron、RN、微信小程序等由前端主导的新技术，很多人就说了“啊iOS开发要完啦”、“啊安卓开发要完啦”、“要转行前端啦”等，我觉得其实还没有必要恐慌到那个程度。诚然如今前端能做的事不少，但是局限性还是很强。PWA由于依赖高版本Chrome在一般安卓机器上体验依然不怎么样，想做出像原生一样的效果还是受限于机能，iOS就更别说了，虽然safari开始支持service worker，但支持PWA还有待时日；Electron虽然能开发跨端应用，不过还有很多的局限，比如应用体积实在大，比如无法获取外部当前鼠标选中的文件等等。所以对于新技术应该理性看待，自己亲手实践一下，而不应盲目从众。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p><strong>今年的技术栈成长：</strong></p><ul><li>更加深入Vue的开发</li><li>开始学习Three.js</li><li>开始用上ESLint</li><li>开始学习TypeScript</li><li>开始使用前端测试（Jest）</li><li>开始学习Electron</li><li>开始练习算法</li><li>对前端工程化+自动化有更多的实践和体会</li><li>持续维护三个开源项目：<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>、<a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a>、<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a></li><li>学习持续集成</li></ul><p>希望我的2018年能够继续有所收获！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年末了，赶着刚考完两门考试，在最后4门考试来临之前抽空写一下今年的小结。&lt;/p&gt;
    
    </summary>
    
      <category term="日志" scheme="https://molunerfinn.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="随笔" scheme="https://molunerfinn.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
