<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Electron-vue开发实战1——Main进程和Renderer进程的简单开发"><meta name="keywords" content="前端,Vue,Electron,Electron-vue"><meta name="author" content="Molunerfinn"><meta name="copyright" content="Molunerfinn"><title>Electron-vue开发实战1——Main进程和Renderer进程的简单开发 | MARKSZのBlog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2358465699478507",enable_page_level_ads:"true"})</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?19a7ebdbb87f2403773c7ab0cae16d21";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-105869658-1","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"BGLU1ICJFH",apiKey:"85948beeaf121424b806828adc21c8b5",indexName:"mofinn",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#说明"><span class="toc-number">2.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Main进程和Renderer进程的基本认识"><span class="toc-number">3.</span> <span class="toc-text">Main进程和Renderer进程的基本认识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Main进程开发"><span class="toc-number">4.</span> <span class="toc-text">Main进程开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#app"><span class="toc-number">4.1.</span> <span class="toc-text">app</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BrowserWindow"><span class="toc-number">4.2.</span> <span class="toc-text">BrowserWindow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tray"><span class="toc-number">4.3.</span> <span class="toc-text">Tray</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#鼠标左键点击事件"><span class="toc-number">4.3.1.</span> <span class="toc-text">鼠标左键点击事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#鼠标右键点击事件"><span class="toc-number">4.3.2.</span> <span class="toc-text">鼠标右键点击事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Menu"><span class="toc-number">4.4.</span> <span class="toc-text">Menu</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Renderer进程开发"><span class="toc-number">5.</span> <span class="toc-text">Renderer进程开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#请使用Hash模式"><span class="toc-number">5.1.</span> <span class="toc-text">请使用Hash模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现自己的titlebar"><span class="toc-number">5.2.</span> <span class="toc-text">实现自己的titlebar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drag-amp-drop的避免"><span class="toc-number">5.3.</span> <span class="toc-text">drag&amp;drop的避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remote模块的使用"><span class="toc-number">5.4.</span> <span class="toc-text">remote模块的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shell"><span class="toc-number">5.4.1.</span> <span class="toc-text">shell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dialog"><span class="toc-number">5.4.2.</span> <span class="toc-text">dialog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Menu和BrowserWindow的应用"><span class="toc-number">5.4.3.</span> <span class="toc-text">Menu和BrowserWindow的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main进程和renderer进程的通信"><span class="toc-number">5.5.</span> <span class="toc-text">main进程和renderer进程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ipcMain和ipcRenderer"><span class="toc-number">5.5.1.</span> <span class="toc-text">ipcMain和ipcRenderer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webContents"><span class="toc-number">5.5.2.</span> <span class="toc-text">webContents</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ws1.sinaimg.cn/large/8700af19ly1fm4iuz15lsj20ix0iw0u8"></div><div class="author-info__name text-center">Molunerfinn</div><div class="author-info__description text-center">For MElody</div><div class="follow-button"><a href="https://github.com/Molunerfinn">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">23</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com">Molunerfinn</a><a class="author-info-links__name text-center" href="https://elody-07.github.io">Elody</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">MARKSZのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Electron-vue开发实战1——Main进程和Renderer进程的简单开发</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/">Web</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/开发/">开发</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">6.8k</span><span class="post-meta__separator">|</span><span>Reading time: 24 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我用<a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>开发了一款跨平台（目前支持Mac和Windows）的免费开源的图床上传应用——<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，在开发过程中踩了不少的坑，不仅来自应用的业务逻辑本身，也来自electron本身。在开发这个应用过程中，我学了不少的东西。因为我也是从0开始学习electron，所以很多经历应该也能给初学、想学electron开发的同学们一些启发和指示。故而写一份Electron的开发实战经历，用最贴近实际工程项目开发的角度来阐述。希望能帮助到大家。</p><p>预计将会从几篇系列文章或方面来展开：</p><ol><li><a href="https://molunerfinn.com/electron-vue-1/">electron-vue入门</a></li><li><a href="https://molunerfinn.com/electron-vue-2/">Main进程和Renderer进程的简单开发</a></li><li><a href="https://molunerfinn.com/electron-vue-3/">引入基于Lodash的JSON database——lowdb</a></li><li><a href="https://molunerfinn.com/electron-vue-4/">跨平台的一些兼容措施</a></li><li><a href="https://molunerfinn.com/electron-vue-5/">通过CI发布以及更新的方式</a></li><li><a href="https://molunerfinn.com/electron-vue-6/">开发插件系统——CLI部分</a></li><li><a href="https://molunerfinn.com/electron-vue-7/">开发插件系统——GUI部分</a></li><li>想到再写…</li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>PicGo</code>是采用<code>electron-vue</code>开发的，所以如果你会<code>vue</code>，那么跟着一起来学习将会比较快。如果你的技术栈是其他的诸如<code>react</code>、<code>angular</code>，那么纯按照本教程虽然在render端（可以理解为页面）的构建可能学习到的东西不多，不过在main端（electron的主进程）应该还是能学习到相应的知识的。</p><p>如果之前的文章没阅读的朋友可以先从之前的文章跟着看。</p><a id="more"></a><h2 id="Main进程和Renderer进程的基本认识"><a href="#Main进程和Renderer进程的基本认识" class="headerlink" title="Main进程和Renderer进程的基本认识"></a>Main进程和Renderer进程的基本认识</h2><p>从上一篇文章结尾部分我们运行成功的一个electron-vue的<a href="https://molunerfinn.com/electron-vue-1/#electron-vue%E5%AE%89%E8%A3%85">DEMO</a>来直观看看这两个进程的粗浅认识：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnh28jgs8nj20ms098wge" alt></p><p>可以看到Main进程管理的是这个app窗口（<a href="https://electronjs.org/docs/api/browser-window" target="_blank" rel="noopener">BrowserWindow</a>），而Renderer进程负责的就是我们熟悉的页面UI渲染。不过实际上，它们远远不仅如此。下面一张图能够把它们所支持、管理的electron或者原生的模块大致列出来：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhcn82n7sj21wu1fmn6v" alt="main &amp; renderer process tree"></p><blockquote><p>图中列出来的大部分模块都是我们会在开发过程中用到的。</p></blockquote><p>它们有各自的模块，也有共有的模块比如<code>clipboard</code>等。还有一部分是Main进程里的模块，不过可以通过<code>remote</code>模块，让renderer进程也能使用。比如<code>Menu</code>比如<code>shell</code>等。</p><p>了解一下哪些模块在哪些进程里，哪些模块可以通过<code>remote</code>模块让renderer进程也能使用是有必要的，这样我们后续开发的时候才能正确的使用。</p><p>上面的模块可能有些从名字里并不能看出作用是啥，没关系，后续的内容会慢慢涉及。</p><h2 id="Main进程开发"><a href="#Main进程开发" class="headerlink" title="Main进程开发"></a>Main进程开发</h2><p>上面说到了Main进程一个显著的作用就是创建app的窗口。我们来看看这个是怎么实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; app, BrowserWindow &#125; <span class="keyword">from</span> <span class="string">'electron'</span> <span class="comment">// 从electron引入app和BrowserWindow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> winURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080`</span> <span class="comment">// 开发模式的话走webpack-dev-server的url</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 创建窗口</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initial window options</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    height: <span class="number">563</span>,</span><br><span class="line">    useContentSize: <span class="literal">true</span>,</span><br><span class="line">    width: <span class="number">1000</span></span><br><span class="line">  &#125;) <span class="comment">// 创建一个窗口</span></span><br><span class="line"></span><br><span class="line">  mainWindow.loadURL(winURL) <span class="comment">// 加载窗口的URL -&gt; 来自renderer进程的页面</span></span><br><span class="line"></span><br><span class="line">  mainWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    mainWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow) <span class="comment">// app准备好的时候创建窗口</span></span><br></pre></td></tr></table></figure><p>暂且先不管渲染进程里的页面长什么样，在app准备好的时候打开一个窗口只需要调用一个创建<code>BrowserWindow</code>的方法即可。</p><p>main进程里的开发有点当年写<code>jQuery</code>的样子，比较多的是事件驱动型的写法。</p><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>首先需要注意的是<a href="https://electronjs.org/docs/api/app" target="_blank" rel="noopener">app</a>的模块。这个模块是electron应用的骨架。它掌管着整个应用的生命周期钩子，以及很多其他事件钩子。</p><p>app的常用生命周期钩子如下：</p><ul><li><code>will-finish-launching</code> 在应用完成基本启动进程之后触发</li><li><code>ready</code> 当electron完成初始化后触发</li><li><code>window-all-closed</code> 所有窗口都关闭的时候触发，在windows和linux里，所有窗口都退出的时候<strong>通常</strong>是应用退出的时候</li><li><code>before-quit</code> 退出应用之前的时候触发</li><li><code>will-quit</code> 即将退出应用的时候触发</li><li><code>quit</code> 应用退出的时候触发</li></ul><p>而我们通常会在<code>ready</code>的时候执行创建应用窗口、创建应用菜单、创建应用快捷键等初始化操作。而在<code>will-quit</code>或者<code>quit</code>的时候执行一些清空操作，比如解绑应用快捷键。</p><p>特别的，在非<code>macOS</code>的系统下，通常一个应用的所有窗口都退出的时候，也是这个应用退出之时。所以可以配合<code>window-all-closed</code>这个钩子来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123; <span class="comment">// 当操作系统不是darwin（macOS）的话</span></span><br><span class="line">    app.quit() <span class="comment">// 退出应用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>除了上面说的生命周期钩子之外，还有一些常用的事件钩子：</p><ul><li><code>active</code>（仅macOS）当应用处于激活状态时</li><li><code>browser-window-created</code> 当一个BrowserWindow被创建的时候</li><li><code>browser-window-focus</code> 当一个BrowserWindow处于激活状态的时候</li></ul><p>这些钩子需要配合一些具体场景来做出具体的操作。比如当一个BrowserWindow处于激活状态的时候修改窗口的title值。</p><p>当然，app这个模块除了上述的一些事件钩子之外，还有一些很常用的方法：</p><ul><li><code>app.quit()</code> 用于退出应用</li><li><code>app.getPath(name)</code> 用于获取一些系统目录，对于存放应用的配置文件等很有用</li><li><code>app.focus()</code> 用于激活应用，不同系统激活逻辑<a href="https://electronjs.org/docs/api/app#appfocus" target="_blank" rel="noopener">不一样</a></li></ul><p>这些事件和方法都是怎么知道的呢？当然是<a href="https://electronjs.org/docs/" target="_blank" rel="noopener">官方文档</a>了。不过并不需要一开始就通读一遍官方的api文档。官方的api文档更多的作用是用来查阅，当你要开发到某个功能的时候再去查它能否有对应的api、怎么使用。</p><h3 id="BrowserWindow"><a href="#BrowserWindow" class="headerlink" title="BrowserWindow"></a>BrowserWindow</h3><p>BrowserWindow模块用于创建最常见的应用窗口。对于不同系统，创建的窗口的默认样式也不太一样。下面来看看macOS和windows的窗口在外观上的区别：</p><p>mac版的</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fncs5yv0qdj21jk0wi44h" alt></p><p>windows版的</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdibuabmj20rq0h2whl" alt></p><p>可以看到二者在窗口顶部的操作区（最小化、最大化、关闭）和标题的位置以及菜单的位置还是有明显的不同的。它们跟系统原生的窗口是一致的。不过如果你想要美化一下也是没问题的。比如：</p><p>mac版的PicGo</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdaimi40j218g0p0dic" alt="picgo-mac"></p><p>和windows的PicGo</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnhdb9mj1uj20m80ci3yz" alt="picgo-windows"></p><p>其中mac版用了系统的操作区，而windows则没有用系统的操作区，而是用图标模拟的。不过同样的地方是都未使用系统默认的<code>titlebar</code>。这个之后会结合<code>renderer</code>进程来说。</p><p>让我们来看看创建一个BrowserWindow的常用配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span> = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    height: <span class="number">900</span>, <span class="comment">// 高</span></span><br><span class="line">    width: <span class="number">400</span>, <span class="comment">// 宽</span></span><br><span class="line">    show: <span class="literal">false</span>, <span class="comment">// 创建后是否显示</span></span><br><span class="line">    frame: <span class="literal">false</span>, <span class="comment">// 是否创建frameless窗口</span></span><br><span class="line">    fullscreenable: <span class="literal">false</span>, <span class="comment">// 是否允许全屏</span></span><br><span class="line">    center: <span class="literal">true</span>, <span class="comment">// 是否出现在屏幕居中的位置</span></span><br><span class="line">    backgroundColor: <span class="string">'#fff'</span> <span class="comment">// 背景色，用于transparent和frameless窗口</span></span><br><span class="line">    titleBarStyle: <span class="string">'xxx'</span> <span class="comment">// 标题栏的样式，有hidden、hiddenInset、customButtonsOnHover等</span></span><br><span class="line">    resizable: <span class="literal">false</span>, <span class="comment">// 是否允许拉伸大小</span></span><br><span class="line">    transparent: <span class="literal">true</span>, <span class="comment">// 是否是透明窗口（仅macOS）</span></span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>, <span class="comment">// 窗口模糊的样式（仅macOS）</span></span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span> <span class="comment">// 当页面被置于非激活窗口的时候是否停止动画和计时器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 以及其他可选配置</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.loadURL(url)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.on(<span class="string">'closed'</span>, () =&gt; &#123; <span class="built_in">window</span> = <span class="literal">null</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口的长宽自然不必说，需要指定。其中需要注意的几个比较重要的就是，<code>frame</code>这个选项，默认是<code>true</code>。如果选择了<code>false</code>则会创建一个<code>frameless</code><a href="https://electronjs.org/docs/api/frameless-window" target="_blank" rel="noopener">窗口</a>，创建一个没有顶部工具栏、没有border的窗口。这个也是我们在windows系统下自定义顶部栏的基础。</p><p>像上述PicGo的主窗口的配置，就是通过如下的配置实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSettingWindow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    height: <span class="number">450</span>,</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    show: <span class="literal">false</span>,</span><br><span class="line">    frame: <span class="literal">true</span>,</span><br><span class="line">    center: <span class="literal">true</span>,</span><br><span class="line">    fullscreenable: <span class="literal">false</span>,</span><br><span class="line">    resizable: <span class="literal">false</span>,</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    vibrancy: <span class="string">'ultra-dark'</span>,</span><br><span class="line">    transparent: <span class="literal">true</span>,</span><br><span class="line">    titleBarStyle: <span class="string">'hidden'</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      backgroundThrottling: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123; <span class="comment">// 针对windows平台做出不同的配置</span></span><br><span class="line">    options.show = <span class="literal">true</span> <span class="comment">// 创建即展示</span></span><br><span class="line">    options.frame = <span class="literal">false</span> <span class="comment">// 创建一个frameless窗口</span></span><br><span class="line">    options.backgroundColor = <span class="string">'#3f3c37'</span> <span class="comment">// 背景色</span></span><br><span class="line">  &#125;</span><br><span class="line">  settingWindow = <span class="keyword">new</span> BrowserWindow(options)</span><br><span class="line"></span><br><span class="line">  settingWindow.loadURL(settingWinURL)</span><br><span class="line"></span><br><span class="line">  settingWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    settingWindow = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟<code>app</code>模块一样，<code>BrowserWindow</code>也有很多常用的事件钩子：</p><ul><li><code>closed</code> 当窗口被关闭的时候</li><li><code>focus</code> 当窗口被激活的时候</li><li><code>show</code> 当窗口展示的时候</li><li><code>hide</code> 当窗口被隐藏的时候</li><li><code>maxmize</code> 当窗口最大化时</li><li><code>minimize</code> 当窗口最小化时</li><li><code>...</code></li></ul><p>当然，也依然有很多实用的方法：</p><ul><li><code>BrowserWindow.getFocusedWindow()</code> [静态方法]获取激活的窗口</li><li><code>win.close()</code> [实例方法，下同]关闭窗口</li><li><code>win.focus()</code> 激活窗口</li><li><code>win.show()</code> 显示窗口</li><li><code>win.hide()</code> 隐藏窗口</li><li><code>win.maximize()</code> 最大化窗口</li><li><code>win.minimize()</code> 最小化窗口</li><li><code>win.restore()</code> 从最小化窗口恢复</li><li><code>...</code></li></ul><p>针对不同的业务逻辑你需要对窗口进行不一样的操作。这个需要跟你的项目需求相匹配。比如上述说到的，windows的顶部的操作区（放大、缩小、关闭按钮）就可以通过icon模拟+实例方法来实现。</p><h3 id="Tray"><a href="#Tray" class="headerlink" title="Tray"></a>Tray</h3><p>一开始看这个名字你可能并不知道这个是个什么东西。可以把它理解为不同系统的任务栏里的图标组件吧。</p><p>比如在macOS里，<code>Tray</code>配合上图标之后就是顶部栏里的应用图标了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnijxxj5gkj215i01at9b" alt></p><p>比如在windows里，<code>Tray</code>配合上图标之后就是windows右下角的应用图标了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnijzo4hgbj20gl016a9z" alt></p><p>需要注意的是，windows和macOS里，图标的大小都是<code>16*16</code>px。macOS下顶部栏的图标通常都是走<code>黑白</code>路线，所以可以为两种系统分别准备不同的图标。<code>PicGo</code>里<code>Tray</code>的生成代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTray</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menubarPic = process.platform === <span class="string">'darwin'</span> ? <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span></span><br><span class="line">  tray = <span class="keyword">new</span> Tray(menubarPic) <span class="comment">// 指定图片的路径</span></span><br><span class="line">  <span class="comment">// ... 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上述代码里有一个<code>${__static}</code>的变量。该变量是<code>electron-vue</code>为我们暴露出来的项目根目录下的<code>static</code>文件夹的路径。通过这个路径，在开发和生产阶段都能很好的定位你的静态资源所在的目录。是个很方便的变量。</p><p>当然<code>Tray</code>并不只是一个图标而无其他作用了。Tray支持很多有用的事件。其中最关键的两个是<code>click</code>和<code>right-click</code>。分别对应鼠标左键点击和鼠标右键点击事件。</p><h4 id="鼠标左键点击事件"><a href="#鼠标左键点击事件" class="headerlink" title="鼠标左键点击事件"></a>鼠标左键点击事件</h4><ul><li>在macOS系统下，鼠标左键点击Tray的icon可能会出现配置菜单，也有可能会出现应用窗口。</li><li>在windows下，鼠标左键点击Tray的icon通常会出现应用的窗口。</li></ul><h4 id="鼠标右键点击事件"><a href="#鼠标右键点击事件" class="headerlink" title="鼠标右键点击事件"></a>鼠标右键点击事件</h4><ul><li>在macOS系统下，鼠标右键点击Tray的icon通常会出现配置菜单。</li><li>在windows系统下，同上。</li></ul><p>所以需要我们去适配不同操作系统下用户的操作习惯。</p><p>对应于PicGo而言，在macOS系统下左键点击会出现一个menubar的小窗口，右键点击会出现配置菜单。而在windows下，左键点击会直接出现主窗口，（因为在windows下无小窗口的必要），右键点击会出现配置菜单。它们在PicGo里的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTray</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menubarPic = process.platform === <span class="string">'darwin'</span> ? <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span> : <span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar-nodarwin.png`</span></span><br><span class="line">  tray = <span class="keyword">new</span> Tray(menubarPic)</span><br><span class="line">  <span class="keyword">const</span> contextMenu = <span class="comment">// ...菜单</span></span><br><span class="line">  tray.on(<span class="string">'right-click'</span>, () =&gt; &#123; <span class="comment">// 右键点击</span></span><br><span class="line">    <span class="built_in">window</span>.hide() <span class="comment">// 隐藏小窗口</span></span><br><span class="line">    tray.popUpContextMenu(contextMenu) <span class="comment">// 打开菜单</span></span><br><span class="line">  &#125;)</span><br><span class="line">  tray.on(<span class="string">'click'</span>, () =&gt; &#123; <span class="comment">// 左键点击</span></span><br><span class="line">    <span class="keyword">if</span> (process.platform === <span class="string">'darwin'</span>) &#123; <span class="comment">// 如果是macOS</span></span><br><span class="line">      toggleWindow() <span class="comment">// 打开或关闭小窗口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是windows</span></span><br><span class="line">      <span class="built_in">window</span>.hide() <span class="comment">// 隐藏小窗口</span></span><br><span class="line">      <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123; <span class="comment">// 如果主窗口不存在就创建一个</span></span><br><span class="line">        createSettingWindow()</span><br><span class="line">        settingWindow.show()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果主窗口在，就显示并激活</span></span><br><span class="line">        settingWindow.show()</span><br><span class="line">        settingWindow.focus()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于macOS而言，Tray还有一个很棒的特性——可以拖拽文件到Tray的icon上，会触发如下事件：</p><ul><li><code>drop</code> 当任何东西拖拽到icon上时</li><li><code>drop-files</code> 当文件被拖拽到icon上时</li><li><code>drop-text</code> 当文本被拖拽到icon上时</li><li><code>drop-enter</code> 当刚拖拽到icon上时</li><li><code>drop-leave</code> 当拖拽事件离开icon时</li><li><code>drop-end</code> 当拖拽事件结束时</li></ul><p>就像PicGo实现的拖拽图片到Tray的icon上时实现图片上传的功能，就是用到了上述的一些事件：</p><p><img src="https://user-images.githubusercontent.com/12621342/34242310-b5056510-e655-11e7-8568-60ffd4f71910.gif" alt></p><p>尤其注意到在拖拽上的时候和拖拽结束后的时候icon是不一样的。在PicGo里是这样实现的，很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'drag-enter'</span>, () =&gt; &#123;</span><br><span class="line">  tray.setImage(<span class="string">`<span class="subst">$&#123;__static&#125;</span>/upload.png`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tray.on(<span class="string">'drag-end'</span>, () =&gt; &#123;</span><br><span class="line">  tray.setImage(<span class="string">`<span class="subst">$&#123;__static&#125;</span>/menubar.png`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而<code>Tray</code>另一个重要的作用就是开启菜单项。这个将结合下一节<code>Menu</code>一起说明。</p><h3 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h3><p>electron威力强大的Menu组件，既能够生成系统菜单项，也能实现绑定应用常用快捷键的功能。</p><p>先来看看什么是系统菜单项：</p><blockquote><p>macOS</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnisjmm1f9j213m074wln" alt></p><blockquote><p>windows</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnisory5p4j215c0pen3z" alt></p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnislgodz9j204k047mx8" alt></p><p>主要分两种。</p><ul><li>第一种是app的菜单。对于macOS来说就是顶部栏左侧区域的菜单项。对于windows而言就是一个窗口的标题栏下方的菜单区。</li><li>第二种是类似于右键菜单的菜单。</li></ul><p>第一种菜单可以通过<code>Menu.setApplicationMenu()</code>来实现。</p><p>第二种菜单可以通过两个步骤来展示：</p><p><strong>1.</strong> 创建菜单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([...])</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 展示菜单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tray.on(<span class="string">'right-click'</span>, () =&gt; &#123; <span class="comment">// 右键点击tray的时候</span></span><br><span class="line">  tray.popUpContextMenu(contextMenu) <span class="comment">// 弹出菜单</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里我们只介绍了<code>Menu</code>本身。其实组成<code>Menu</code>的是一个一个的<code>MenuItem</code>。它们有很多类型：</p><ol><li>normal</li><li>separator</li><li>submenu</li><li>checkbox</li><li>radio</li></ol><p>以及很多角色：</p><ol><li>quit</li><li>copy</li><li>redo</li><li>undo</li><li>minimize</li><li>close</li><li>reload</li><li>…</li></ol><p>通常来说，配置的菜单项基本从类型里来组合。比如PicGo的菜单项：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnivun40bij20fg082wgo" alt></p><p>这里面就有normal、submenu、checkbox和radio四种类型。其中默认是normal。</p><p>角色的话通常对应的是一些常见的行为。比如<code>quit</code>是退出app，比如<code>minimize</code>是最小化，比如<code>copy</code>是复制。不过需要注意的是，如果你没有在创建app菜单里指定这些操作的快捷键的话，那么一些常见的快捷操作就无法在你的app里使用了。比如<code>ctrl+c</code>或者<code>command+c</code>复制这个操作，如果你没有通过<code>Menu.setApplicationMenu()</code>来设定这个快捷键的话，那么在你的electron应用里就无法执行复制的操作了。PicGo在早期版本里也犯了这个<a href>错误</a>。当时的问题是我在开发模式下是没有问题的，但是在生产模式下就无法进行复制粘贴操作。后来查了一下原因，发现原来在开发模式下，electron会置入默认的一些快捷操作菜单，如图：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnjcaoo0btj20pg0fcah1" alt></p><p>所以在生产模式如果我没有置入这些快捷键的话，使用者就无法使用了。<strong>这个是大坑</strong>。</p><p>说了这么多，来看看生成app的菜单的代码长啥样：</p><blockquote><p>注意，如果在开发模式下直接只使用如下快捷键的话，一些调试快捷键比如<code>F12</code>或者<code>command+shift+i</code>打开控制台的操作就无法使用了。所以在开发模式下不需要创建这些快捷键菜单。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createMenu = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'development'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> template = [&#123;</span><br><span class="line">      label: <span class="string">'Edit'</span>,</span><br><span class="line">      submenu: [</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Undo'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+Z'</span>, <span class="attr">selector</span>: <span class="string">'undo:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Redo'</span>, <span class="attr">accelerator</span>: <span class="string">'Shift+CmdOrCtrl+Z'</span>, <span class="attr">selector</span>: <span class="string">'redo:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">'separator'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Cut'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+X'</span>, <span class="attr">selector</span>: <span class="string">'cut:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Copy'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+C'</span>, <span class="attr">selector</span>: <span class="string">'copy:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Paste'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+V'</span>, <span class="attr">selector</span>: <span class="string">'paste:'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">label</span>: <span class="string">'Select All'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+A'</span>, <span class="attr">selector</span>: <span class="string">'selectAll:'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          label: <span class="string">'Quit'</span>,</span><br><span class="line">          accelerator: <span class="string">'CmdOrCtrl+Q'</span>,</span><br><span class="line">          click () &#123;</span><br><span class="line">            app.quit()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">    menu = Menu.buildFromTemplate(template)</span><br><span class="line">    Menu.setApplicationMenu(menu)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>accelerator</code>指定你想要的快捷键。诸如<code>Shift</code>、<code>Ctrl</code>、<code>Cmd</code>等键位缩写。如果是组合键，就加上<code>+</code>。尤其注意到，因为macOS和windows键位的差异，所以有一个很好用的键位缩写<code>CmdOrCtrl</code>，即如果是在macOS上就是<code>Cmd</code>，在windows上就是<code>Ctrl</code>。</p><p>然后再来看看Tray的“右键”菜单的生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contextMenu = Menu.buildFromTemplate([</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'关于'</span>,</span><br><span class="line">     click () &#123;</span><br><span class="line">       dialog.showMessageBox(&#123;</span><br><span class="line">         title: <span class="string">'PicGo'</span>,</span><br><span class="line">         message: <span class="string">'PicGo'</span>,</span><br><span class="line">         detail: <span class="string">`Version: <span class="subst">$&#123;pkg.version&#125;</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'打开详细窗口'</span>,</span><br><span class="line">     click () &#123;</span><br><span class="line">       <span class="keyword">if</span> (settingWindow === <span class="literal">null</span>) &#123;</span><br><span class="line">         createSettingWindow()</span><br><span class="line">         settingWindow.show()</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         settingWindow.show()</span><br><span class="line">         settingWindow.focus()</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'选择默认图床'</span>,</span><br><span class="line">     type: <span class="string">'submenu'</span>,</span><br><span class="line">     submenu: [</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'微博图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'weibo'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'weibo'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'七牛图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'qiniu'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'qiniu'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'腾讯云COS'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'tcyun'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'tcyun'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         label: <span class="string">'又拍云图床'</span>,</span><br><span class="line">         type: <span class="string">'radio'</span>,</span><br><span class="line">         checked: db.read().get(<span class="string">'picBed.current'</span>).value() === <span class="string">'upyun'</span>,</span><br><span class="line">         click () &#123;</span><br><span class="line">           db.read().set(<span class="string">'picBed.current'</span>, <span class="string">'upyun'</span>)</span><br><span class="line">             .write()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     label: <span class="string">'打开更新助手'</span>,</span><br><span class="line">     type: <span class="string">'checkbox'</span>,</span><br><span class="line">     checked: db.get(<span class="string">'picBed.showUpdateTip'</span>).value(),</span><br><span class="line">     click () &#123;</span><br><span class="line">       <span class="keyword">const</span> value = db.read().get(<span class="string">'picBed.showUpdateTip'</span>).value()</span><br><span class="line">       db.read().set(<span class="string">'picBed.showUpdateTip'</span>, !value).write()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     role: <span class="string">'quit'</span>,</span><br><span class="line">     label: <span class="string">'退出'</span></span><br><span class="line">   &#125;</span><br><span class="line"> ])</span><br><span class="line"></span><br><span class="line"> tray.on(<span class="string">'right-click'</span>, () =&gt; &#123;</span><br><span class="line">   tray.popUpContextMenu(contextMenu)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>注意，菜单项的点击事件可以直接通过<code>click</code>属性来指定。上面我们是先通过了<code>Menu.buildFromTemplate()</code>这个方法创建了菜单，然后再在右键点击<code>Tray</code>图标的时候将其弹（PopUp)出来。</p><p>当然也有其他构建菜单的方法。可以通过Menu实例的<code>append</code>方法来加入<code>Menu Item</code>。如下例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> menu = <span class="keyword">new</span> Menu()</span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">label</span>: <span class="string">'Cut'</span>, <span class="attr">accelerator</span>: <span class="string">'CmdOrCtrl+X'</span> &#125;))</span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">type</span>: <span class="string">'separator'</span> &#125;)) <span class="comment">// 分割线</span></span><br><span class="line">menu.append(<span class="keyword">new</span> MenuItem(&#123; <span class="attr">label</span>: <span class="string">'Helper'</span>, <span class="attr">type</span>: <span class="string">'checkbox'</span>, <span class="attr">checked</span>: <span class="literal">true</span> &#125;))</span><br></pre></td></tr></table></figure><p>基本上有了上述的几个基本模块，我们的一个应用的骨架是基本搭建好了，拥有窗口、任务栏应用图标和菜单项。其他的Main进程的模块，并不是必须的，当会用到的时候将在之后的文章里逐步提及。下一节我们将来看renderer进程的开发。</p><h2 id="Renderer进程开发"><a href="#Renderer进程开发" class="headerlink" title="Renderer进程开发"></a>Renderer进程开发</h2><p>对于<code>electron-vue</code>而言，renderer进程其实大部分就是在写我们平时常写的前端页面罢了。不过相对于平时在浏览器里写的页面，在electron里写页面的时候你还能用到不少非浏览器端的模块，比如<code>fs</code>，比如electron通过<code>remote</code>模块暴露给renderer进程的模块。接下去我们来看看renderer进程有哪些需要注意的地方。</p><h3 id="请使用Hash模式"><a href="#请使用Hash模式" class="headerlink" title="请使用Hash模式"></a>请使用Hash模式</h3><p>往常我们在写Vue的时候都比较喜欢开启路由的<code>history</code>模式，因为这样在浏览器的地址栏上看起来比较好看——没有hash的<code>#</code>号，就如同请求后端的url一般。然而需要注意的是，<code>history</code>模式需要后端服务器的支持。</p><p>可能很多朋友平时开发的时候没有感觉，那是因为vue-cli里在开发模式下启动的<code>webpack-dev-server</code>帮你实现了服务端的<code>history-fallback</code>的特性。所以在实际部署的时候，至少都需要在你的web服务器程序诸如<code>nginx</code>、<code>apache</code>等配置相关的规则，让前端路由返回给<code>vue-router</code>去处理。</p><p>而electron里也是如此。在开发模式下，由于使用的是<code>webpack-dev-server</code>开启的服务器，所以<code>BrowserWindow</code>加载的是来自于类似<code></code><a href="http://localhost:9080`这样的地址的页面。而在生产模式下，却是使用的`file://`的协议，比如`file://${__dirname}/index.html`来指定窗口加载的页面。" target="_blank" rel="noopener">http://localhost:9080`这样的地址的页面。而在生产模式下，却是使用的`file://`的协议，比如`file://${__dirname}/index.html`来指定窗口加载的页面。</a></p><p>因此，从上面的表述你也能明白了。假如我有一个子路由地址为<code>child</code>。如果不启用Hash模式，在开发模式下没啥问题，<code>http://localhost:9080/child</code>，但是在生产模式下，<code>file://${__dirname}/index.html/child</code>却是无法匹配的一条路径。因此在electron下，<code>vue-router</code>请不要使用<code>history</code>模式，而使用默认的<code>hash</code>模式。</p><p>那么上面的问题就迎刃而解，变为<code>file://${__dirname}/index.html#child</code>即可。</p><p>PicGo里加载的页面路由规则如下，从中你也能看出我使用的是<code>hash</code>模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> winURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span></span><br><span class="line"><span class="keyword">const</span> settingWinURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080/#setting/upload`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html#setting/upload`</span></span><br></pre></td></tr></table></figure><h3 id="实现自己的titlebar"><a href="#实现自己的titlebar" class="headerlink" title="实现自己的titlebar"></a>实现自己的titlebar</h3><p>在上面讲<code>BrowserWindow</code>的时候，我说到有时为了应用的美观，并不想让我们的应用窗口采用系统默认的<code>titlebar</code>，而想用自己写的来实现。这样的话就在创建你的<code>BrowserWindow</code>的配置里加上一句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titleBarStyle: <span class="string">'hidden'</span></span><br></pre></td></tr></table></figure><p>这样就行了。然后你就可以自行在renderer进程的页面里模拟一个顶部的<code>titlebar</code>了，比如上面提到的<code>PicGo</code>的<code>titlebar</code>的样子。实际上代码也很简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fake-title-bar"</span>&gt;</span></span><br><span class="line">  PicGo - &#123;&#123; version &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"handle-bar"</span> <span class="attr">v-if</span>=<span class="string">"os === 'win32'"</span>&gt;</span> <span class="comment">&lt;!-- 如果是windows系统 就加上模拟的操作按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-minus"</span> @<span class="attr">click</span>=<span class="string">"minimizeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-close"</span> @<span class="attr">click</span>=<span class="string">"closeWindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后把这个titlebar的position置顶即可。</p><p>不过在平时的使用中，我们要注意，一般我们鼠标按住titlebar的时候是可以拖动窗口的。但是如果我们在不加可拖拽的属性之前，我们自己写的titlebar是不具备这样的特性的。要加上这个特性也很简单：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fake-title-bar</span> &#123;</span><br><span class="line">  -webkit-app-region drag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需一条CSS，即可让你的titlebar可以拖拽。</p><p>不过在windows下，操作区的按钮（缩小、放大、关闭）长按应该是不能拖拽的，所以还需要：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.handle-bar</span> &#123;</span><br><span class="line">  -webkit-app-region no-drag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变成<code>no-drag</code>，这样就实现了我们自己生成应用的titlebar了。</p><h3 id="drag-amp-drop的避免"><a href="#drag-amp-drop的避免" class="headerlink" title="drag&amp;drop的避免"></a>drag&amp;drop的避免</h3><p>通常我们用Chrome的时候，有个特性是比如你往Chrome里拖入一个pdf，它就会自动用内置的pdf阅读器打开。你往Chrome里拖入一张图片，它就会打开这张图片。由于我们的electron应用的<code>BrowserWindow</code>其实内部也是一个浏览器，所以这样的特性依然存在。而这也是很多人没有注意的地方。也就是当你开发完一个electron应用之后，往里拖入一张图片，一个pdf等等，如果不是一个可拖拽区域（比如PicGo的上传区），那么它就不应该打开这张图、这个pdf，而是将其排除在外。</p><p>所以我们将在全局监听<code>drag</code>和<code>drop</code>事件，当用户拖入一个文件但是又不是拖入可拖拽区域的时候，应该将其屏蔽掉。因为所有的页面都应该要有这样的特性，所以我写了一个vue的<code>mixin</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.disableDragEvent()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    disableDragEvent () &#123;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'dragenter'</span>, <span class="keyword">this</span>.disableDrag, <span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'dragover'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'drop'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">    &#125;,</span><br><span class="line">    disableDrag (e) &#123;</span><br><span class="line">      <span class="keyword">const</span> dropzone = <span class="built_in">document</span>.getElementById(<span class="string">'upload-area'</span>) <span class="comment">// 这个是可拖拽的上传区</span></span><br><span class="line">      <span class="keyword">if</span> (dropzone === <span class="literal">null</span> || !dropzone.contains(e.target)) &#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        e.dataTransfer.effectAllowed = <span class="string">'none'</span></span><br><span class="line">        e.dataTransfer.dropEffect = <span class="string">'none'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'dragenter'</span>, <span class="keyword">this</span>.disableDrag, <span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'dragover'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'drop'</span>, <span class="keyword">this</span>.disableDrag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在全局引入这个mixin即可。</p><h3 id="remote模块的使用"><a href="#remote模块的使用" class="headerlink" title="remote模块的使用"></a>remote模块的使用</h3><p>remote模块是electron为了让一些原本在Main进程里运行的模块也能在renderer进程里运行而创建的。以下说几个我们会用到的。</p><p>在<code>electron-vue</code>里内置了<code>vue-electron</code>这个模块，可以在vue里很方便的使用诸如<code>this.$electron.remote.xxx</code>来使用remote的模块。</p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p><code>shell</code>模块的官方说明是：<code>Manage files and URLs using their default applications.</code>也就是使用文件或者URL的默认应用。通常我们可以用其让默认图片应用打开一张图片、让默认浏览器打开一个url。</p><p>如果我们想在renderer进程里点击一个按钮然后在默认浏览器里打开一个url的话就可以这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"openURL"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      openURL () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.$electron.remote.shell.openExternal(<span class="string">'https://github.com/Molunerfinn/PicGo'</span>)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是不是很方便？</p><p>更多详细的shell的用法可以参考<a href="https://electronjs.org/docs/api/shell" target="_blank" rel="noopener">文档</a>。</p><h4 id="dialog"><a href="#dialog" class="headerlink" title="dialog"></a>dialog</h4><p>有的时候我们会有打开原生的对话框的需求。比如<code>PicGo</code>的版本信息：</p><blockquote><p>macOS</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnje5uvnlrj20nc08kq3d" alt></p><blockquote><p>windows</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fnje4njzafj20a60543yd" alt></p><p>这个时候就可以通过<code>dialog</code>这个模块来实现了。逻辑跟上面一样也是点击一个按钮打开一个dialog：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openDialog () &#123;</span><br><span class="line">  <span class="keyword">this</span>.$electron.remote.dialog.showMessageBox(&#123;</span><br><span class="line">    title: <span class="string">'PicGo'</span>,</span><br><span class="line">    message: <span class="string">'PicGo'</span>,</span><br><span class="line">    detail: <span class="string">`Version: <span class="subst">$&#123;pkg.version&#125;</span>\nAuthor: Molunerfinn\nGithub: https://github.com/Molunerfinn/PicGo`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细的dialog的用法可以参考<a href="https://electronjs.org/docs/api/dialog" target="_blank" rel="noopener">文档</a>。</p><h4 id="Menu和BrowserWindow的应用"><a href="#Menu和BrowserWindow的应用" class="headerlink" title="Menu和BrowserWindow的应用"></a>Menu和BrowserWindow的应用</h4><p>使用<code>Menu</code>可能很多人能够理解。但是为什么要使用<code>BrowserWindow</code>呢？因为需要定位你打开<code>Menu</code>的窗口。</p><p>在PicGo里，有一个点击按钮打开Menu的操作，大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildMenu () &#123;</span><br><span class="line">    <span class="keyword">const</span> template = [...]</span><br><span class="line">    <span class="keyword">this</span>.menu = Menu.buildFromTemplate(template)</span><br><span class="line">  &#125;,</span><br><span class="line">  openDialog () &#123;</span><br><span class="line">    <span class="keyword">this</span>.menu.popup(remote.getCurrentWindow) <span class="comment">// 获取当前打开Menu的窗口</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>menu.popup</code>就需要你指定一下打开这个menu的窗口。它将自动定位你点击的位置而弹出。</p><h3 id="main进程和renderer进程的通信"><a href="#main进程和renderer进程的通信" class="headerlink" title="main进程和renderer进程的通信"></a>main进程和renderer进程的通信</h3><p>在Vue里，如果是非父子组件通信，很常用的是通过<code>Bus Event</code>来实现的。而electron里的不同进程间的通信其实也很类似，是通过<code>ipcMain</code>和<code>ipcRenderer</code>来实现的。其中<code>ipcMain</code>是在<code>main</code>进程里使用的，而<code>ipcRenderer</code>是在<code>renderer</code>进程里使用的。</p><h4 id="ipcMain和ipcRenderer"><a href="#ipcMain和ipcRenderer" class="headerlink" title="ipcMain和ipcRenderer"></a>ipcMain和ipcRenderer</h4><p>官网的例子其实很简洁明了了，我放出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main process.</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcMain&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line">ipcMain.on(<span class="string">'asynchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg)  <span class="comment">// prints "ping"</span></span><br><span class="line">  event.sender.send(<span class="string">'asynchronous-reply'</span>, <span class="string">'pong'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ipcMain.on(<span class="string">'synchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg)  <span class="comment">// prints "ping"</span></span><br><span class="line">  event.returnValue = <span class="string">'pong'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In renderer process (web page).</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ipcRenderer.sendSync(<span class="string">'synchronous-message'</span>, <span class="string">'ping'</span>)) <span class="comment">// prints "pong"</span></span><br><span class="line"></span><br><span class="line">ipcRenderer.on(<span class="string">'asynchronous-reply'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg) <span class="comment">// prints "pong"</span></span><br><span class="line">&#125;)</span><br><span class="line">ipcRenderer.send(<span class="string">'asynchronous-message'</span>, <span class="string">'ping'</span>)</span><br></pre></td></tr></table></figure><p>其中<code>ipcMain</code>只有监听来自<code>ipcRenderer</code>的某个事件后才能返回给<code>ipcRenderer</code>值。而<code>ipcRenderer</code>既可以收，也可以发。</p><p>那么问题就来了，如何让<code>ipcMain</code>主动发送消息呢？或者说让main进程主动发送消息给<code>ipcRenderer</code>。</p><p>首先要明确的是，<code>ipcMain</code>无法主动发消息给<code>ipcRenderer</code>。因为ipcMain只有<code>.on()</code>方法没有<code>.send()</code>的方法。所以只能用其他方法来实现。有办法么？有的，用<code>webContents</code>。</p><h4 id="webContents"><a href="#webContents" class="headerlink" title="webContents"></a>webContents</h4><p><code>webContents</code>其实是<code>BrowserWindow</code>实例的一个属性。也就是如果我们需要在<code>main</code>进程里给某个窗口某个页面发送消息，则必须通过<code>win.webContents.send()</code>方法来发送。</p><p>代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In main process</span></span><br><span class="line"><span class="keyword">let</span> win = <span class="keyword">new</span> BrowserWindow(&#123;...&#125;)</span><br><span class="line">win.webContents.send(<span class="string">'img-files'</span>, imgs)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In renderer process</span></span><br><span class="line">ipcRenderer.on(<span class="string">'img-files'</span>, (event, files) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(files)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以必须指定要发送的窗口，才能将信息准确送达。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细地讲述了electron里<code>Main</code>进程和<code>Renderer</code>进程的基础知识和开发相关。很多都是我在开发<code>PicGo</code>的时候碰到的问题、踩的坑。也许文中简单的几句话背后就是我无数次的查阅和调试。内容相比第一篇多了不少，希望这篇文章能够给你的<code>electron-vue</code>开发带来一些启发。文中相关的代码，你都可以在<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>的项目仓库里找到。希望本文能够给你带来帮助，这是我最开心的地方。如果喜欢，欢迎关注我的博客以及本系列文章的后续进展。</p><blockquote><p><strong>注：文中的图片除未特地说明之外均属于我个人作品，需要转载请私信</strong></p></blockquote></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Molunerfinn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://molunerfinn.com/electron-vue-2/">https://molunerfinn.com/electron-vue-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/前端/">前端</a><a class="post-meta__tags" href="/tags/Vue/">Vue</a><a class="post-meta__tags" href="/tags/Electron/">Electron</a><a class="post-meta__tags" href="/tags/Electron-vue/">Electron-vue</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ws1.sinaimg.cn/large/8700af19ly1fjmba1eumhj20jz0jzq4b.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ws1.sinaimg.cn/large/8700af19ly1fjmbbmp7uwj20jm0jmt9a.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5994f8f0fea9a5f4" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/electron-vue-3/"><i class="fa fa-chevron-left"></i><span>Electron-vue开发实战2——引入基于Lodash的JSON数据库lowdb</span></a></div><div class="next-post pull-right"><a href="/electron-vue-1/"><span>Electron-vue开发实战0——Electron-vue入门</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="100%" height="90"></a></div><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"f7b6cca0b0a65f07a027",clientSecret:"84b5ccac558161d1bdaa50fc498619fca9d4c640",repo:"Molunerfinn.github.io",owner:"Molunerfinn",admin:"Molunerfinn",id:md5(decodeURI(location.pathname)),language:"en"});gitalk.render("gitalk-container")</script></div></div><footer class="footer-bg" style="background-image:url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Molunerfinn</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>