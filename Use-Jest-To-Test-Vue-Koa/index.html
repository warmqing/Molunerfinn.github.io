<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="全栈测试实战：用Jest测试Vue+Koa全栈应用"><meta name="keywords" content="前端,Vue,Nodejs"><meta name="author" content="Molunerfinn"><meta name="copyright" content="Molunerfinn"><title>全栈测试实战：用Jest测试Vue+Koa全栈应用 | MARKSZのBlog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2358465699478507",enable_page_level_ads:"true"})</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?19a7ebdbb87f2403773c7ab0cae16d21";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-105869658-1","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:{appId:"BGLU1ICJFH",apiKey:"85948beeaf121424b806828adc21c8b5",indexName:"mofinn",hits:{per_page:10},languages:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}.",hits_stats:"${hits} results found in ${time} ms"}},localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目结构"><span class="toc-number">3.</span> <span class="toc-text">项目结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试用到的一些关键依赖"><span class="toc-number">4.</span> <span class="toc-text">测试用到的一些关键依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搭建Jest测试环境"><span class="toc-number">5.</span> <span class="toc-text">搭建Jest测试环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安装"><span class="toc-number">5.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置"><span class="toc-number">5.2.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Koa后端Api测试"><span class="toc-number">6.</span> <span class="toc-text">Koa后端Api测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#后端api测试覆盖率"><span class="toc-number">6.1.</span> <span class="toc-text">后端api测试覆盖率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#端口占用和环境变量的引入"><span class="toc-number">6.2.</span> <span class="toc-text">端口占用和环境变量的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#跨平台env设置"><span class="toc-number">6.2.1.</span> <span class="toc-text">跨平台env设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#端口分离并保证测试覆盖率"><span class="toc-number">6.2.2.</span> <span class="toc-text">端口分离并保证测试覆盖率</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-安装dotenv"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">1. 安装dotenv</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-在项目根目录下创建-env和-env-test两个文件，分别应用于开发环境和测试环境"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">2. 在项目根目录下创建.env和.env.test两个文件，分别应用于开发环境和测试环境</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-创建一个env-js文件，用于不同环境下采用不同的环境变量。代码如下："><span class="toc-number">6.2.2.3.</span> <span class="toc-text">3. 创建一个env.js文件，用于不同环境下采用不同的环境变量。代码如下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-在app-js开头引入env"><span class="toc-number">6.2.2.4.</span> <span class="toc-text">4. 在app.js开头引入env</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue前端测试"><span class="toc-number">7.</span> <span class="toc-text">Vue前端测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安装vue-test-utils"><span class="toc-number">7.1.</span> <span class="toc-text">安装vue-test-utils</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置vue-test-utils以及jest"><span class="toc-number">7.2.</span> <span class="toc-text">配置vue-test-utils以及jest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前端单元测试的一些说明"><span class="toc-number">7.3.</span> <span class="toc-text">前端单元测试的一些说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Login-vue的测试"><span class="toc-number">7.4.</span> <span class="toc-text">Login.vue的测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查找元素测试"><span class="toc-number">7.4.1.</span> <span class="toc-text">查找元素测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快照测试"><span class="toc-number">7.4.2.</span> <span class="toc-text">快照测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#methods测试"><span class="toc-number">7.4.3.</span> <span class="toc-text">methods测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mock方法测试"><span class="toc-number">7.4.4.</span> <span class="toc-text">mock方法测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建复杂行为测试"><span class="toc-number">7.4.5.</span> <span class="toc-text">创建复杂行为测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Todolist-vue的测试"><span class="toc-number">7.5.</span> <span class="toc-text">Todolist.vue的测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#键盘事件测试以及隐式事件触发"><span class="toc-number">7.5.1.</span> <span class="toc-text">键盘事件测试以及隐式事件触发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wrapper-update-的使用"><span class="toc-number">7.5.2.</span> <span class="toc-text">wrapper.update()的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用VSCode来调试测试"><span class="toc-number">7.6.</span> <span class="toc-text">用VSCode来调试测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">9.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ws1.sinaimg.cn/large/8700af19ly1fm4iuz15lsj20ix0iw0u8"></div><div class="author-info__name text-center">Molunerfinn</div><div class="author-info__description text-center">For MElody</div><div class="follow-button"><a href="https://github.com/Molunerfinn">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">71</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">23</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com">Molunerfinn</a><a class="author-info-links__name text-center" href="https://elody-07.github.io">Elody</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">MARKSZのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">全栈测试实战：用Jest测试Vue+Koa全栈应用</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/">Web</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/开发/">开发</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Web/开发/Nodejs/">Nodejs</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">12.7k</span><span class="post-meta__separator">|</span><span>Reading time: 46 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年一月份的时候我写了一个<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">Vue+Koa的全栈应用</a>，以及相应的<a href="https://molunerfinn.com/Vue+Koa/">配套教程</a>，得到了很多的好评。同时我也在和读者交流的过程中不断认识到不足和缺点，于是也对此进行了不断的更新和完善。本次带来的完善是加入和完整的前后端测试。相信对于很多学习前端的朋友来说，<code>测试</code>这个东西似乎是个熟悉的陌生人。你听过，但是你未必做过。如果你对前端（以及nodejs端）测试很熟悉，那么本文的帮助可能不大，不过我很希望能得到你们提出的宝贵意见！</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>和上一篇<a href="https://molunerfinn.com/Vue+Koa/">全栈开发实战：用Vue2+Koa1开发完整的前后端项目</a>一样，本文从测试新手的角度出发（默认了解Koa并付诸实践，了解Vue并付诸实践，但是并无测试经历），在已有的项目上从0开始构建我们的全栈测试系统。可以了解到测试的意义，<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>测试框架的搭建，前后端测试的异同点，如何写测试用例，如何查看测试结果并提升我们的测试覆盖率，100%测试覆盖率是否是必须，以及在搭建测试环境、以及测试本身过程中遇到的各种疑难杂症。希望可以作为入门前端以及Node端测试的文章吧。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>有了之前的项目结构作为骨架，加入Jest测试框架就很简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── .env  // 环境变量配置文件</span><br><span class="line">├── app.js  // Koa入口文件</span><br><span class="line">├── build // vue-cli 生成，用于webpack监听、构建</span><br><span class="line">│   ├── build.js</span><br><span class="line">│   ├── check-versions.js</span><br><span class="line">│   ├── dev-client.js</span><br><span class="line">│   ├── dev-server.js</span><br><span class="line">│   ├── utils.js</span><br><span class="line">│   ├── webpack.base.conf.js</span><br><span class="line">│   ├── webpack.dev.conf.js</span><br><span class="line">│   └── webpack.prod.conf.js</span><br><span class="line">├── config // vue-cli 生成&amp;自己加的一些配置文件</span><br><span class="line">│   ├── default.conf</span><br><span class="line">│   ├── dev.env.js</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── prod.env.js</span><br><span class="line">├── dist // Vue build 后的文件夹</span><br><span class="line">│   ├── index.html // 入口文件</span><br><span class="line">│   └── static // 静态资源</span><br><span class="line">├── env.js // 环境变量切换相关 &lt;-- 新</span><br><span class="line">├── .env // 开发、上线时的环境变量 &lt;-- 新</span><br><span class="line">├── .env.test // 测试时的环境变量 &lt;-- 新</span><br><span class="line">├── index.html // vue-cli生成，用于容纳Vue组件的主html文件。单页应用就只有一个html</span><br><span class="line">├── package.json // npm的依赖、项目信息文件、Jest的配置项 &lt;-- 新</span><br><span class="line">├── server // Koa后端，用于提供Api</span><br><span class="line">│   ├── config // 配置文件夹</span><br><span class="line">│   ├── controllers // controller-控制器</span><br><span class="line">│   ├── models // model-模型</span><br><span class="line">│   ├── routes // route-路由</span><br><span class="line">│   └── schema // schema-数据库表结构</span><br><span class="line">├── src // vue-cli 生成&amp;自己添加的utils工具类</span><br><span class="line">│   ├── App.vue // 主文件</span><br><span class="line">│   ├── assets // 相关静态资源存放</span><br><span class="line">│   ├── components // 单文件组件</span><br><span class="line">│   ├── main.js // 引入Vue等资源、挂载Vue的入口js</span><br><span class="line">│   └── utils // 工具文件夹-封装的可复用的方法、功能</span><br><span class="line">├── test</span><br><span class="line">│   ├── sever // 服务端测试 &lt;-- 新</span><br><span class="line">│   └── client // 客户端（前端）测试 &lt;-- 新</span><br><span class="line">└── yarn.lock // 用yarn自动生成的lock文件</span><br></pre></td></tr></table></figure><p>可以看到新增的或者说更新的东西只有几个：</p><ol><li>最主要的test文件夹，包含了客户端（前端）和服务端的测试文件</li><li>env.js以及配套的<code>.env</code>、<code>.env.test</code>，是跟测试相关的环境变量</li><li>package.json，更新了一些依赖以及Jest的配置项</li></ol><blockquote><p>主要环境：Vue2，Koa2，Nodejs v8.9.0</p></blockquote><h2 id="测试用到的一些关键依赖"><a href="#测试用到的一些关键依赖" class="headerlink" title="测试用到的一些关键依赖"></a>测试用到的一些关键依赖</h2><p>以下依赖的版本都是本文所写的时候的版本，或者更旧一些</p><ol><li>jest: ^21.2.1</li><li>babel-jest: ^21.2.0</li><li>supertest: ^3.0.0</li><li>dotenv: ^4.0.0</li></ol><p>剩下依赖可以项目<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">demo仓库</a>。</p><h2 id="搭建Jest测试环境"><a href="#搭建Jest测试环境" class="headerlink" title="搭建Jest测试环境"></a>搭建Jest测试环境</h2><p>对于测试来说，我也是个新手。至于为什么选择了<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>，而不是其他框架（例如mocha+chai、jasmine等），我觉得有如下我自己的观点（当然你也可以不采用它）：</p><ol><li>由Facebook开发，保证了更新速度以及框架质量</li><li>它有很多集成的功能（比如断言库、比如测试覆盖率）</li><li>文档完善，配置简单</li><li>支持typescript，我在学习typescript的时候也用了Jest来写测试</li><li>Vue官方的单元测试框架<a href="https://github.com/vuejs/vue-test-utils" target="_blank" rel="noopener">vue-test-utils</a>专门有配合Jest的测试说明</li><li>支持快照功能，对前端单元测试是一大利好</li><li>如果你是React技术栈，Jest天生就适配React</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add jest -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install jest --save-dev</span><br></pre></td></tr></table></figure><p>很简单对吧。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>由于我项目的Koa后端用的是ES modules的写法而不是Nodejs的Commonjs的写法，所以是需要babel的插件来进行转译的。否则你运行测试用例的时候，将会出现如下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● Test suite failed to run</span><br><span class="line"></span><br><span class="line">   /Users/molunerfinn/Desktop/work/web/vue-koa-demo/test/sever/todolist.test.js:1</span><br><span class="line">   (&#123;&quot;Object.&lt;anonymous&gt;&quot;:function(module,exports,require,__dirname,__filename,global,jest)&#123;import _regeneratorRuntime from &apos;babel-runtime/regenerator&apos;;import _asyncToGenerator from &apos;babel-runtime/helpers/asyncToGenerator&apos;;var _this = this;import server from &apos;../../app.js&apos;;</span><br><span class="line">                                                                                            ^^^^^^</span><br><span class="line"></span><br><span class="line">   SyntaxError: Unexpected token import</span><br><span class="line"></span><br><span class="line">     at ScriptTransformer._transformAndBuildScript (node_modules/jest-runtime/build/script_transformer.js:305:17)</span><br><span class="line">         at Generator.next (&lt;anonymous&gt;)</span><br><span class="line">         at new Promise (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure><p>看了官方github的<a href="https://github.com/facebook/jest#using-babel" target="_blank" rel="noopener">README</a>发现应该是<code>babel-jest</code>没装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add babel-jest -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install babel-jest --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>但是奇怪的是，文档里说：Note: babel-jest is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. 也就是babel-jest在jest安装的时候便会自动安装了。这点需要求证。</p></blockquote><p>然而发现运行测试用例的时候还是出了上述问题，查阅了相关<a href="https://github.com/facebook/jest/issues/2081" target="_blank" rel="noopener">issue</a>之后，我给出两种解决办法：</p><p>都是修改项目目录下的<code>.babelrc</code>配置文件，增加<code>env</code>属性，配置<code>test</code>环境如下：</p><p><strong>1.</strong> 增加<code>presets</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"env": &#123;</span><br><span class="line">  "test": &#123;</span><br><span class="line">    "presets": ["env", "stage-2"] // 采用babel-presents-env来转译</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 或者增加<code>plugins</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"env": &#123;</span><br><span class="line">  "test": &#123;</span><br><span class="line">    "plugins": ["transform-es2015-modules-commonjs"] // 采用plugins来讲ES modules转译成Commonjs modules</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，编译通过。</p><blockquote><p>通常我们将测试文件（*.test.js或*.spec.js）放置在项目的test目录下。Jest将会自动运行这些测试用例。值得一提的是，通常我们将基于<code>TDD</code>的测试文件命名为<code>*.test.js</code>，把基于<code>BDD</code>的测试文件命名为<code>*.spec.js</code>。这二者的区别可以看这篇<a href="http://www.cnblogs.com/ustbwuyi/archive/2012/10/26/2741223.html" target="_blank" rel="noopener">文章</a></p></blockquote><p>我们可以在<code>package.json</code>的<code>scripts</code>字段里加入<code>test</code>的命令（如果原本存在则换一个名字，不要冲突）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "jest"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样我们就可以在终端直接运行<code>npm test</code>来执行测试了。下面我们先来从后端的Api测试开始写起。</p><h2 id="Koa后端Api测试"><a href="#Koa后端Api测试" class="headerlink" title="Koa后端Api测试"></a>Koa后端Api测试</h2><p>重现一下之前的应用的操作流程，可以发现应用分为登录前和登录后两种状态。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fl97i5zzb0g20z30ixk77.gif" alt></p><p>可以根据操作流程或者后端api的结构来写测试。如果根据操作流程来写测试就可以分为登录前和登录后。如果根据后端api的结构的话，就可以根据routes或者controllers的结构、功能来写测试。</p><p>由于本例登录前和登录后的api基本上是分开的，所以我主要根据上述后者（routes或controllers）来写测试。</p><p>到此需要解释一下一般来说（写）测试的步骤：</p><ol><li>写测试说明，针对你的每条测试说明测试了什么功能，预期结果是什么。</li><li>写测试主体，通常是 输入 -&gt; 输出。</li><li>判断测试结果，拿输出和预期做对比。如果输出和预期相符，则测试通过。反之，不通过。</li></ol><p>在<code>test</code>文件夹下新建一个<code>server</code>文件夹。然后创建一个<code>user.spec.js</code>文件。</p><p>我们可以通过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br></pre></td></tr></table></figure><p>的方式将我们的Koa应用的主入口文件引入。但是此时遇到了一个问题。我们如何对这个server发起http请求，并对其的返回结果做出判断呢？</p><p>在阅读了<a href="https://hackernoon.com/async-testing-koa-with-jest-1b6e84521b71" target="_blank" rel="noopener">Async testing Koa with Jest</a>以及<a href="https://www.valentinog.com/blog/testing-api-koa-jest/" target="_blank" rel="noopener">A clear and concise introduction to testing Koa with Jest and Supertest</a>这两篇文章之后，我决定使用<a href="https://github.com/visionmedia/supertest" target="_blank" rel="noopener">supertest</a>这个工具了。它是专门用来测试nodejs端HTTP server的测试工具。它内封了<a href="https://github.com/visionmedia/superagent" target="_blank" rel="noopener">superagent</a>这个著名的Ajax请求库。并且支持Promise，意味着我们对于异步请求的结果也能通过<code>async await</code>的方式很好的控制了。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add supertest -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install supertest --save-dev</span><br></pre></td></tr></table></figure><p>现在开始着手写我们第一个测试用例。先写一个针对登录功能的吧。当我们输入了错误的用户名或者密码的时候将无法登录，后端返回的参数里，success会是false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/server/user.spec.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close() <span class="comment">// 当所有测试都跑完了之后，关闭server</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果输入用户名为Molunerfinn，密码为1234则无法登录。正确应为molunerfinn和123。</span></span><br><span class="line">test(<span class="string">'Failed to login if typing Molunerfinn &amp; 1234'</span>, <span class="keyword">async</span> () =&gt; &#123; <span class="comment">// 注意用了async</span></span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server) <span class="comment">// 注意这里用了await</span></span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>) <span class="comment">// post方法向'/auth/user'发送下面的数据</span></span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'1234'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">false</span>) <span class="comment">// 期望回传的body的success值是false（代表登录失败）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>上述例子中，test()方法能接受3个参数，第一个是对测试的描述(string)，第二个是回调函数(fn)，第三个是延时参数(number)。本例不需要延时。然后expect()函数里放输出，再用各种<a href="https://facebook.github.io/jest/docs/en/expect.html" target="_blank" rel="noopener">match</a>方法来将预期和输出做对比。</p></blockquote><p>在终端执行<code>npm test</code>，紧张地希望能跑通也许是人生的第一个测试用例。结果我得到如下关键的报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">● Post todolist failed if not give the params</span><br><span class="line"></span><br><span class="line">   TypeError: app.address is not a function</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">● Post todolist failed if not give the params</span><br><span class="line"></span><br><span class="line">   TypeError: _app2.default.close is not a function</span><br></pre></td></tr></table></figure><p>这是怎么回事？说明我们import进来的server看来并没有close、address等方法。原因在于我们在<code>app.js</code>里最后一句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app</span><br></pre></td></tr></table></figure><p>此处export出来的是一个对象。但我们实际上需要一个function。</p><p>在谷歌的过程中，找到两种解决办法：</p><blockquote><p>参考<a href="https://segmentfault.com/q/1010000006906863" target="_blank" rel="noopener">解决办法1</a>和<a href="https://hackernoon.com/async-testing-koa-with-jest-1b6e84521b71" target="_blank" rel="noopener">解决办法2</a></p></blockquote><p><strong>1.</strong> 修改<code>app.js</code></p><p>将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.listen(<span class="number">8889</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in 8889`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app.listen(<span class="number">8889</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in 8889`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>即可。</p><p><strong>2.</strong> 修改你的test文件：</p><p>在里要用到<code>server</code>的地方都改为<code>server.callback()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> request(server.callback())</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'1234'</span></span><br><span class="line">                    &#125;)</span><br></pre></td></tr></table></figure><p>我采用的是第一种做法。</p><p>改完之后，顺利通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PASS  test/sever/user.test.js</span><br><span class="line"> ✓ Failed to login if typing Molunerfinn &amp; 1234 (248ms)</span><br></pre></td></tr></table></figure><p>然而此时发现一个问题，为何测试结束了，jest还占用着终端进程呢？我想要的是测试完jest就自动退出了。查了一下文档，发现它的cli有个参数<code>--forceExit</code>能解决这个问题，于是就把<code>package.json</code>里的<code>test</code>命令修改一下（后续我们还将修改几次）加上这个参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "jest --forceExit"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再测试一遍，发现没问题。这样一来我们就可以继续依葫芦画瓢，把<code>auth/*</code>这个路由的功能都测试一遍：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/routes/auth.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> auth <span class="keyword">from</span> <span class="string">'../controllers/user.js'</span></span><br><span class="line"><span class="keyword">import</span> koaRouter <span class="keyword">from</span> <span class="string">'koa-router'</span></span><br><span class="line"><span class="keyword">const</span> router = koaRouter()</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>, auth.getUserInfo) <span class="comment">// 定义url的参数是id</span></span><br><span class="line">router.post(<span class="string">'/user'</span>, auth.postUserAuth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>测试用例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Failed to login if typing Molunerfinn &amp; 1234'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'1234'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Successed to login if typing Molunerfinn &amp; 123'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'Molunerfinn'</span>,</span><br><span class="line">                      password: <span class="string">'123'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Failed to login if typing MARK &amp; 123'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/auth/user'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      name: <span class="string">'MARK'</span>,</span><br><span class="line">                      password: <span class="string">'123'</span></span><br><span class="line">                    &#125;)</span><br><span class="line">  expect(response.body.info).toBe(<span class="string">'用户不存在！'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting the user info is null if the url is /auth/user/10'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/auth/user/10'</span>)</span><br><span class="line">  expect(response.body).toEqual(&#123;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting user info successfully if the url is /auth/user/2'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/auth/user/2'</span>)</span><br><span class="line">  expect(response.body.user_name).toBe(<span class="string">'molunerfinn'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>都很简洁易懂，看描述+预期你就能知道在测试什么了。不过需要注意一点的是，我们用到了<code>toBe()</code>和<code>toEqual()</code>两个方法。乍一看好像没有区别。实际上有大区别。</p><p>简单来说，<code>toBe()</code>适合<code>===</code>这个判断条件。比如<code>1 === 1</code>，<code>&#39;hello&#39; === &#39;hello&#39;</code>。但是<code>[1] === [1]</code>是错的。具体原因不多说，js的基础。所以要判断比如数组或者对象相等的话需要用<code>toEqual()</code>这个方法。</p><p>OK，接下去我们开始测试<code>api/*</code>这个路由。</p><p>在<code>test</code>目录下创建一个叫做<code>todolits.spec.js</code>的文件：</p><p>有了上一个测试的经验，测试这个其实也不会有多大的问题。首先我们来测试一下当我们没有携带上JSON WEB TOKEN的header的话，服务端是不是返回401错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting todolist should return 401 if not set the JWT'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/api/todolist/2'</span>)</span><br><span class="line">  expect(response.status).toBe(<span class="number">401</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一切看似没问题，但是运行的时候却报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.error node_modules/jest-jasmine2/build/jasmine/Env.js:194</span><br><span class="line">    Unhandled error</span><br><span class="line"></span><br><span class="line">console.error node_modules/jest-jasmine2/build/jasmine/Env.js:195</span><br><span class="line">  Error: listen EADDRINUSE :::8888</span><br><span class="line">      at Object._errnoException (util.js:1024:11)</span><br><span class="line">      at _exceptionWithHostPort (util.js:1046:20)</span><br><span class="line">      at Server.setupListenHandle [as _listen2] (net.js:1351:14)</span><br><span class="line">      at listenInCluster (net.js:1392:12)</span><br><span class="line">      at Server.listen (net.js:1476:7)</span><br><span class="line">      at Application.listen (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/koa/lib/application.js:64:26)</span><br><span class="line">      at Object.&lt;anonymous&gt; (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/app.js:60:5)</span><br><span class="line">      at Runtime._execModule (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/jest-runtime/build/index.js:520:13)</span><br><span class="line">      at Runtime.requireModule (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/jest-runtime/build/index.js:332:14)</span><br><span class="line">      at Runtime.requireModuleOrMock (/Users/molunerfinn/Desktop/work/web/vue-koa-demo/node_modules/jest-runtime/build/index.js:408:19)</span><br></pre></td></tr></table></figure><p>看来是因为同时运行了两个Koa实例导致了监听端口的冲突。所以我们需要让Jest按顺序执行。查阅官方文档，发现了<a href="http://facebook.github.io/jest/docs/en/cli.html#runinband" target="_blank" rel="noopener">runInBand</a>这个参数正是我们想要的。</p><p>所以修改<code>package.json</code>里的<code>test</code>命令如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "jest --forceExit --runInBand"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再次运行，成功通过！</p><p>接下来遇到一个问题。我们的JWT的token原本是登录成功后生成并派发给前端的。如今我们测试api的时候并没有经过登录那一步。所以要测试的时候要用的token的话，我觉得有两种办法：</p><ol><li>增加测试的时候的api接口，不需要经过<code>koa-jwt</code>的验证。但是这种方法对项目有入侵性的影响，如果有的时候我们需要从token获取信息的话就有问题了。</li><li>后端预先生成一个合法的token，然后测试的时候用上这个测试的token即可。不过这种办法的话就需要保证token不能泄露。</li></ol><p>我采用第二种办法。为了读者使用方便我是预先生成一个token然后用一个变量存起来的。（真正的开发环境下应对将测试的token放置在项目环境变量.env中）</p><p>接下来我们测试一下数据库的四大操作：增删改查。不过我们为了一次性将这四个接口都测试一遍可以按照这个顺序：增查改删。其实就是先增加一个todo，然后查找的时候将id记录下来。随后可以用这个id进行更新和删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> server <span class="keyword">from</span> <span class="string">'../../app.js'</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> token = <span class="string">'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoibW9sdW5lcmZpbm4iLCJpZCI6MiwiaWF0IjoxNTA5ODAwNTg2fQ.JHHqSDNUgg9YAFGWtD0m3mYc9-XR3Gpw9gkZQXPSavM'</span> <span class="comment">// 预先生成的token</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todoId = <span class="literal">null</span> <span class="comment">// 用来存放测试生成的todo的id</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'Getting todolist should return 401 if not set the JWT'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/api/todolist/2'</span>)</span><br><span class="line">  expect(response.status).toBe(<span class="number">401</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line">test(<span class="string">'Created todolist successfully if set the JWT &amp; correct user'</span>, <span class="keyword">async</span> () =&gt; &#123; </span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .post(<span class="string">'/api/todolist'</span>)</span><br><span class="line">                    .send(&#123;</span><br><span class="line">                      status: <span class="literal">false</span>,</span><br><span class="line">                      content: <span class="string">'来自测试'</span>,</span><br><span class="line">                      id: <span class="number">2</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token) <span class="comment">// header处加入token验证</span></span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line">test(<span class="string">'Getting todolist successfully if set the JWT &amp; correct user'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .get(<span class="string">'/api/todolist/2'</span>)</span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  response.body.result.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.content === <span class="string">'来自测试'</span>) todoId = item.id <span class="comment">// 获取id</span></span><br><span class="line">  &#125;)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">test(<span class="string">'Updated todolist successfully if set the JWT &amp; correct todoId'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .put(<span class="string">`/api/todolist/2/<span class="subst">$&#123;todoId&#125;</span>/0`</span>) <span class="comment">// 拿id去更新</span></span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line">test(<span class="string">'Removed todolist successfully if set the JWT &amp; correct todoId'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .delete(<span class="string">`/api/todolist/2/<span class="subst">$&#123;todoId&#125;</span>`</span>)</span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对照着api的4大接口，我们已经将它们都测试了一遍。那是不是我们对于服务端的测试已经结束了呢？其实不是的。要想保证后端api的健壮性，我们得将很多情况都考虑到。但是人为的去排查每个条件、语句什么的必然过于繁琐和机械。于是我们需要一个指标来帮我们确保测试的全面性。这就是测试覆盖率了。</p><h3 id="后端api测试覆盖率"><a href="#后端api测试覆盖率" class="headerlink" title="后端api测试覆盖率"></a>后端api测试覆盖率</h3><p>上面说过，Jest是自带了测试覆盖率功能的（其实就是基于<a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">istanbul</a>这个工具来生成测试覆盖率的）。要如何开启呢？这里我还走了不少坑。</p><p>通过阅读官方的<a href="http://facebook.github.io/jest/docs/en/configuration.html" target="_blank" rel="noopener">配置文档</a>，我确定了几个需要开启的参数：</p><ol><li>coverageDirectory，指定输出测试覆盖率报告的目录</li><li>coverageReporters，指定输出的测试覆盖率报告的形式，具体可以参考istanbul的<a href="https://istanbul.js.org/docs/advanced/alternative-reporters/" target="_blank" rel="noopener">说明</a></li><li>collectCoverage，是否要收集覆盖率信息，当然是。</li><li>mapCoverage，由于我们的代码经过babel-jest转译，所以需要开启sourcemap来让Jest能够把测试结果定位到源代码上而不是编译的代码上。</li><li>verbose，用于显示每个测试用例的通过与否。</li></ol><p>于是我们需要在<code>package.json</code>里配置一个Jest字段（不是在scripts字段里配置，而是和scripts在同一级的字段），来配置Jest。</p><p>配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "verbose": true,</span><br><span class="line">  "coverageDirectory": "coverage",</span><br><span class="line">  "mapCoverage": true,</span><br><span class="line">  "collectCoverage": true,</span><br><span class="line">  "coverageReporters": [</span><br><span class="line">    "lcov", // 会生成lcov测试结果以及HTML格式的漂亮的测试覆盖率报告</span><br><span class="line">    "text" // 会在命令行界面输出简单的测试报告</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再进行一遍测试，可以看到在终端里已经输出了简易的测试报告总结：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flc95bhjwmj20y80lijus.jpg" alt></p><p>从中我们能看到一些字段是100%，而一些不是100%。最后一列<code>Uncovered Lines</code>就是告诉我们，测试里没有覆盖到的代码行。为了更直观地看到测试的结果报告，可以到项目的根目录下找到一个<code>coverage</code>的目录，在<code>lcov-report</code>目录里有个<code>index.html</code>就是输出的html报告。打开来看看：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld7tv6c91j21z20h0n0f.jpg" alt></p><p>首页是个概览，跟命令行里输出的内容差不多。不过我们可以往深了看，可以点击左侧的File提供的目录：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8bgzj3gj21z20hotc4.jpg" alt></p><p>然后我们可以看到没有被覆盖到代码行数（50）以及有一个函数没有被测试到：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8erd8g6j215w05a757.jpg" alt></p><p>通常我们没有测试到的函数也伴随着代码行数没有被测试到。我们可以看到在本例里，app的<code>error</code>事件没有被触发过。想想也是的，我们的测试都是建立在合法的api请求的基础上的。所以自然不会触发<code>error</code>事件。因此我们需要写一个测试用例来测试这个<code>.on(&#39;error&#39;)</code>的函数。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8fyapefj21z20fy0yc.jpg" alt></p><p>通常这样的测试用例并不是特别好写。不过好在我们可以尝试去触发server端的错误，对于本例来说，如果向服务端创建一个todo的时候，没有附上相应的信息（id、status、content），就无法创建相应的todo，会触发错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// server/models/todolist.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createTodolist = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> Todolist.create(&#123;</span><br><span class="line">    user_id: data.id,</span><br><span class="line">    content: data.content,</span><br><span class="line">    status: data.status</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是server端创建todo的相关函数，下面是针对它的错误进行的测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/server/todolist.spec.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">test(<span class="string">'Failed to create a todo if not give the params'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">            .post(<span class="string">'/api/todolist'</span>)</span><br><span class="line">            .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token) <span class="comment">// 不发送创建的参数</span></span><br><span class="line">  expect(response.status).toBe(<span class="number">500</span>) <span class="comment">// 服务端报500错误</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再进行测试，发现之前对于app.js的相关测试都已经是100%了。</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8s0m0g5j20xy0lq41t.jpg" alt></p><p>不过<code>controllers/todolist.js</code>里还是有未测试到的行数34，以及我们可以看到<code>% Branch</code>这列的数字显示的是50而不是100。<code>Branch</code>的意思就是分支测试。什么是分支测试呢？简单来说就是你的条件语句测试。比如一个<code>if...else</code>语句，如果测试用例只跑过<code>if</code>的条件，而没有跑过<code>else</code>的条件，那么<code>Branch</code>的测试就不完整。让我们来看看是什么条件没有测试到？</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld8yzgta5j214w0b6di6.jpg" alt></p><p>可以看到是个三元表达式并没有测试完整。（三元表达式也算分支）我们测试了0的情况，但是没有测试非零的情况，所以再写一个非零的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Failed to update todolist  if not update the status of todolist'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> request(server)</span><br><span class="line">                    .put(<span class="string">`/api/todolist/2/<span class="subst">$&#123;todoId&#125;</span>/1`</span>) <span class="comment">// &lt;- 这里最后一个参数改成了1</span></span><br><span class="line">                    .set(<span class="string">'Authorization'</span>, <span class="string">'Bearer '</span> + token)</span><br><span class="line">  expect(response.body.success).toBe(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再次跑测试：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld977icalj20x40lmdj2.jpg" alt></p><p>哈，成功做到了100%测试覆盖率！</p><h3 id="端口占用和环境变量的引入"><a href="#端口占用和环境变量的引入" class="headerlink" title="端口占用和环境变量的引入"></a>端口占用和环境变量的引入</h3><p>虽然做到了100%测试覆盖率，但是有一个问题却是不容忽视的。那就是我们现在测试环境和开发环境下的服务端监听的端口是一致的。意味着你不能在开发环境下测试你的代码。比如你写完一个api之后马上要写一个测试用例的时候，如果测试环境和开发环境的服务端监听的端口一致的话，测试的时候就会因为端口被占用而无法被监听到。</p><p>所以我们需要指定一下测试环境下的端口，让它和开发乃至生产环境的端口不一样。我一开始想法很简单，指定一下<code>NODE_ENV=test</code>的时候用8888端口，开发环境下用8889端口。在<code>app.js</code>里就是这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> port = process.env.NODE_ENV === <span class="string">'test'</span> ? <span class="number">8888</span> : <span class="number">8889</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> app.listen(port, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in <span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下去就遇到了两个问题：</p><ol><li>需要解决跨平台env设置</li><li>这样设置的话一旦在测试环境下，对于port这句话，<code>Branch</code>测试是无法完全通过的——因为始终是在test环境下，无法运行到<code>port = 8889</code>那个条件</li></ol><h4 id="跨平台env设置"><a href="#跨平台env设置" class="headerlink" title="跨平台env设置"></a>跨平台env设置</h4><p>跨平台env主要涉及到windows、linux和macOS。要在三个平台在测试的时候都跑着<code>NODE_ENV=test</code>的话，我们需要借助<a href="https://github.com/kentcdodds/cross-env" target="_blank" rel="noopener">cross-env</a>来帮助我们。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add cross-env -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install cross-env --save-dev</span><br></pre></td></tr></table></figure><p>然后在<code>package.json</code>里修改<code>test</code>的命令如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // ...其他命令</span><br><span class="line">  "test": "cross-env NODE_ENV=test jest --forceExit --runInBand"</span><br><span class="line">  // ...其他命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样就能在后端代码里，通过<code>process.env.NODE_ENV</code>这个变量访问到<code>test</code>这个值。这样就解决了第一个问题。</p><h4 id="端口分离并保证测试覆盖率"><a href="#端口分离并保证测试覆盖率" class="headerlink" title="端口分离并保证测试覆盖率"></a>端口分离并保证测试覆盖率</h4><p>目前为止，我们已经能够解决测试环境和开发环境的监听端口一致的问题了。不过却带来了测试覆盖率不全的问题。</p><p>为此我找到两种解决办法：</p><ol><li>通过istanbul特殊的<a href="https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md" target="_blank" rel="noopener"><code>ignore</code>注释</a>来忽略测试环境下的一些测试分支条件</li><li>通过配置环境变量文件，不同环境下采用不同的环境变量文件</li></ol><p>第一种方法很简单，在需要忽略的地方，输入<code>/* istanbul ignore next */</code>或<code>/* istanbul ignore &lt;word&gt;[non-word] [optional-docs] */</code>等语法忽略代码。不过考虑到这是涉及到测试环境和开发环境下的环境变量问题，如果不仅仅是端口问题的话，那么就不如采用第二种方法来得更加优雅。（比如开发环境和测试环境的数据库用户和密码都不一样的话，还是需要写在对应的环境变量的）</p><p>此时我们需要另外一个很常用的库<a href="https://github.com/motdotla/dotenv" target="_blank" rel="noopener">dotenv</a>，它能默认读取<code>.env</code>文件里的值，让我们的项目可以通过不同的<code>.env</code>文件来应对不同的环境要求。</p><p>步骤如下：</p><h5 id="1-安装dotenv"><a href="#1-安装dotenv" class="headerlink" title="1. 安装dotenv"></a>1. 安装dotenv</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add dotenv</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install dotenv --save</span><br></pre></td></tr></table></figure><h5 id="2-在项目根目录下创建-env和-env-test两个文件，分别应用于开发环境和测试环境"><a href="#2-在项目根目录下创建-env和-env-test两个文件，分别应用于开发环境和测试环境" class="headerlink" title="2. 在项目根目录下创建.env和.env.test两个文件，分别应用于开发环境和测试环境"></a>2. 在项目根目录下创建<code>.env</code>和<code>.env.test</code>两个文件，分别应用于开发环境和测试环境</h5><p>// .env</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DB_USER=xxxx <span class="comment"># 数据库用户</span></span><br><span class="line">DB_PASSWORD=yyyy <span class="comment"># 数据库密码</span></span><br><span class="line">PORT=8889 <span class="comment"># 监听端口</span></span><br></pre></td></tr></table></figure><p>// .env.test</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DB_USER=xxxx <span class="comment"># 数据库用户</span></span><br><span class="line">DB_PASSWORD=yyyy <span class="comment"># 数据库密码</span></span><br><span class="line">PORT=8888 <span class="comment"># 监听端口</span></span><br></pre></td></tr></table></figure><h5 id="3-创建一个env-js文件，用于不同环境下采用不同的环境变量。代码如下："><a href="#3-创建一个env-js文件，用于不同环境下采用不同的环境变量。代码如下：" class="headerlink" title="3. 创建一个env.js文件，用于不同环境下采用不同的环境变量。代码如下："></a>3. 创建一个<code>env.js</code>文件，用于不同环境下采用不同的环境变量。代码如下：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> dotenv <span class="keyword">from</span> <span class="string">'dotenv'</span></span><br><span class="line"><span class="keyword">let</span> path = process.env.NODE_ENV === <span class="string">'test'</span> ? <span class="string">'.env.test'</span> : <span class="string">'.env'</span></span><br><span class="line">dotenv.config(&#123;path, <span class="attr">silent</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="4-在app-js开头引入env"><a href="#4-在app-js开头引入env" class="headerlink" title="4. 在app.js开头引入env"></a>4. 在app.js开头引入env</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./env'</span></span><br></pre></td></tr></table></figure><p>然后把原本那句port的话改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> port = process.env.PORT</span><br></pre></td></tr></table></figure><p>再把数据库连接的用户密码也用环境变量来代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/config/db.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../../env'</span></span><br><span class="line"><span class="keyword">import</span> Sequelize <span class="keyword">from</span> <span class="string">'sequelize'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Todolist = <span class="keyword">new</span> Sequelize(<span class="string">`mysql://<span class="subst">$&#123;process.env.DB_USER&#125;</span>:<span class="subst">$&#123;process.env.DB_PASSWORD&#125;</span>@localhost/todolist`</span>, &#123;</span><br><span class="line">  define: &#123;</span><br><span class="line">    timestamps: <span class="literal">false</span> <span class="comment">// 取消Sequelzie自动给数据表加入时间戳（createdAt以及updatedAt）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>不过需要注意的是，.env和.env.js文件都不应该纳入git版本库，因为都是比较重要的内容。</strong></p><p>这样就能实现不同环境下用不同的变量了。慢着！这样不是还没有解决问题吗？<code>env.js</code>里的条件还是无法被测试覆盖啊——你肯定有这样的疑问。不用紧张，现在给出解决办法——给Jest指定收集测试覆盖率的范围：</p><p>修改<code>package.json</code>里<code>jest</code>字段如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "verbose": true,</span><br><span class="line">  "coverageDirectory": "coverage",</span><br><span class="line">  "mapCoverage": true,</span><br><span class="line">  "collectCoverage": true,</span><br><span class="line">  "coverageReporters": [</span><br><span class="line">    "lcov",</span><br><span class="line">    <span class="string">"text"</span></span><br><span class="line">  ],</span><br><span class="line">  "collectCoverageFrom": [ // 指定Jest收集测试覆盖率的范围</span><br><span class="line">    "!env.js", // 排除env.js</span><br><span class="line">    "server/**/*.js",</span><br><span class="line">    <span class="string">"app.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完这些工作之后，再跑一次测试，一次通过：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1fld977icalj20x40lmdj2.jpg" alt></p><p>这样我们就完成了后端的api测试。完成了100%测试覆盖率。下面我们可以开始测试Vue的前端项目了。</p><h2 id="Vue前端测试"><a href="#Vue前端测试" class="headerlink" title="Vue前端测试"></a>Vue前端测试</h2><p>Vue的前端测试我就要推荐来自官方的<a href="https://github.com/vuejs/vue-test-utils" target="_blank" rel="noopener">vue-test-utils</a>了。当然前端测试大致分成了单元测试（Unit test)和端对端测试(e2e test)，由于端对端的测试对于测试环境的要求比较严苛，而且测试起来比较繁琐，而且官方给出的测试框架是单元测试框架，因此本文对于Vue的前端测试也仅介绍配合官方工具的单元测试。</p><p>在Vue的前端测试中我们能够了解到jest的mock、snapshot等特性和用法和vue-test-utils提供的mount、shallow、setData等一系列操作。</p><h3 id="安装vue-test-utils"><a href="#安装vue-test-utils" class="headerlink" title="安装vue-test-utils"></a>安装vue-test-utils</h3><p>根据官网的<a href="https://vue-test-utils.vuejs.org/en/guides/testing-SFCs-with-jest.html" target="_blank" rel="noopener">介绍</a>我们需要安装如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue-test-utils vue-jest jest-serializer-vue -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install vue-test-utils vue-jest jest-serializer-vue --save-dev</span><br></pre></td></tr></table></figure><p>其中，<code>vue-test-utils</code>是最关键的测试框架。提供了一系列对于Vue组件的测试操作。（下面会提到）。<code>vue-jest</code>用于处理<code>*.vue</code>的文件，<code>jest-serializer-vue</code>用于快照测试提供快照序列化。</p><h3 id="配置vue-test-utils以及jest"><a href="#配置vue-test-utils以及jest" class="headerlink" title="配置vue-test-utils以及jest"></a>配置vue-test-utils以及jest</h3><p><strong>1.</strong> 修改<code>.babelrc</code></p><p>在<code>test</code>的<code>env</code>里增加或修改<code>presets</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123; <span class="attr">"modules"</span>: <span class="literal">false</span> &#125;],</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-runtime"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"comments"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: &#123;</span><br><span class="line">      <span class="attr">"plugins"</span>: [<span class="string">"transform-es2015-modules-commonjs"</span>],</span><br><span class="line">      <span class="attr">"presets"</span>: [</span><br><span class="line">        [<span class="string">"env"</span>, &#123; <span class="attr">"targets"</span>: &#123; <span class="attr">"node"</span>: <span class="string">"current"</span> &#125;&#125;] // 增加或修改</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 修改<code>package.json</code>里的jest配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  "verbose": true,</span><br><span class="line">  "moduleFileExtensions": [</span><br><span class="line">    <span class="string">"js"</span></span><br><span class="line">  ],</span><br><span class="line">  "transform": &#123; // 增加transform转换</span><br><span class="line">    ".*\\.(vue)$": "&lt;rootDir&gt;/node_modules/vue-jest",</span><br><span class="line">    "^.+\\.js$": "&lt;rootDir&gt;/node_modules/babel-jest"</span><br><span class="line">  &#125;,</span><br><span class="line">  "coverageDirectory": "coverage",</span><br><span class="line">  "mapCoverage": true,</span><br><span class="line">  "collectCoverage": true,</span><br><span class="line">  "coverageReporters": [</span><br><span class="line">    "lcov",</span><br><span class="line">    <span class="string">"text"</span></span><br><span class="line">  ],</span><br><span class="line">  "moduleNameMapper": &#123; // 处理webpack alias</span><br><span class="line">    "@/(.*)$": "&lt;rootDir&gt;/src/$1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "snapshotSerializers": [ // 配置快照测试</span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/node_modules/jest-serializer-vue"</span></span><br><span class="line">  ],</span><br><span class="line">  "collectCoverageFrom": [</span><br><span class="line">    "!env.js",</span><br><span class="line">    "server/**/*.js",</span><br><span class="line">    <span class="string">"app.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前端单元测试的一些说明"><a href="#前端单元测试的一些说明" class="headerlink" title="前端单元测试的一些说明"></a>前端单元测试的一些说明</h3><p>关于vue-test-utils和Jest的配合测试，我推荐可以查看这个系列的<a href="https://alexjoverm.github.io/2017/08/21/Write-the-first-Vue-js-Component-Unit-Test-in-Jest/" target="_blank" rel="noopener">文章</a>，讲解很清晰。</p><p>接着，明确一下前端单元测试都需要测试些什么东西。引用<code>vue-test-utils</code>的说法：</p><blockquote><p>对于 UI 组件来说，我们不推荐一味追求行级覆盖率，因为它会导致我们过分关注组件的内部实现细节，从而导致琐碎的测试。</p></blockquote><blockquote><p>取而代之的是，我们推荐把测试撰写为断言你的组件的公共接口，并在一个黑盒内部处理它。一个简单的测试用例将会断言一些输入 (用户的交互或 prop 的改变) 提供给某组件之后是否导致预期结果 (渲染结果或触发自定义事件)。</p></blockquote><blockquote><p>比如，对于每次点击按钮都会将计数加一的 Counter 组件来说，其测试用例将会模拟点击并断言渲染结果会加 1。该测试并没有关注 Counter 如何递增数值，而只关注其输入和输出。</p></blockquote><blockquote><p>该提议的好处在于，即便该组件的内部实现已经随时间发生了改变，只要你的组件的公共接口始终保持一致，测试就可以通过。</p></blockquote><p>所以，相对于后端api测试看重测试覆盖率而言，前端的单元测试是不必一味追求测试覆盖率的。（当然你要想达到100%测试覆盖率也是没问题的，只不过如果要达到这样的效果你需要撰写非常多繁琐的测试用例，占用太多时间，得不偿失。）替代地，我们只需要回归测试的本源：给定输入，我只关心输出，不考虑内部如何实现。只要能覆盖到和用户相关的操作，能测试到页面的功能即可。</p><p>和之前类似，我们在<code>test/client</code>目录下书写我们的测试用例。对于Vue的单元测试来说，我们就是针对<code>*.vue</code>文件进行测试了。由于本例里的<code>app.vue</code>无实际意义，所以就测试<code>Login.vue</code>和<code>Todolist.vue</code>即可。</p><p>运用<code>vue-test-utils</code>如何来进行测试呢？简单来说，我们需要的做的就是用<code>vue-test-utils</code>提供的<code>mount</code>或者<code>shallow</code>方法将组件在后端渲染出来，然后通过一些诸如<code>setData</code>，<code>propsData</code>、<code>setMethods</code>等方法模拟用户的操作或者模拟我们的测试条件，最后再用jest提供的<code>expect</code>断言来对预期的结果进行判断。这里的预期就很丰富了。我们可以通过判断事件是否触发、元素是否存在、数据是否正确、方法是否被调用等等来对我们的组件进行比较全面的测试。下面的例子里也会比较完整地介绍它们。</p><h3 id="Login-vue的测试"><a href="#Login-vue的测试" class="headerlink" title="Login.vue的测试"></a>Login.vue的测试</h3><p>创建一个<code>login.spec.js</code>文件。</p><p>首先我们来测试页面里是否有两个输入框和一个登录按钮。根据官方文档，我首先注意到了<a href="https://vue-test-utils.vuejs.org/en/guides/common-tips.html#shallow-rendering" target="_blank" rel="noopener">shallow rendering</a>，它的说明是，对于某个组件而言，只渲染这个组件本身，而不渲染它的子组件，让测试速度提高，也符合单元测试的理念。看着好像很不错的样子，拿过来用。</p><h4 id="查找元素测试"><a href="#查找元素测试" class="headerlink" title="查找元素测试"></a>查找元素测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = shallow(Login) <span class="comment">// 每次测试前确保我们的测试实例都是是干净完整的。返回一个wrapper对象</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Should have two input &amp; one button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> inputs = wrapper.findAll(<span class="string">'.el-input'</span>) <span class="comment">// 通过findAll来查找dom或者vue实例</span></span><br><span class="line">  <span class="keyword">const</span> loginButton = wrapper.find(<span class="string">'.el-button'</span>) <span class="comment">// 通过find查找元素</span></span><br><span class="line">  expect(inputs.length).toBe(<span class="number">2</span>) <span class="comment">// 应该有两个输入框</span></span><br><span class="line">  expect(loginButton).toBeTruthy() <span class="comment">// 应该有一个登录按钮。 只要断言条件不为空或这false，toBeTruthy就能通过。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一切看起来很正常。运行测试。结果报错了。报错是<code>input.length</code>并不等于2。通过debug断点查看，确实并没有找到元素。</p><p>这是怎么回事？哦对，我想起来，形如<code>el-input</code>、<code>el-button</code>其实也相当于是子组件啊，所以<code>shallow</code>并不能将它们渲染出来。在这种情况下，用<code>shallow</code>来渲染就不合适了。所以还是需要用<code>mount</code>来渲染，它会将页面渲染成它应该有的样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = mount(Login) <span class="comment">// 每次测试前确保我们的测试实例都是是干净完整的。返回一个wrapper对象</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Should have two input &amp; one button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> inputs = wrapper.findAll(<span class="string">'.el-input'</span>) <span class="comment">// 通过findAll来查找dom或者vue实例</span></span><br><span class="line">  <span class="keyword">const</span> loginButton = wrapper.find(<span class="string">'.el-button'</span>) <span class="comment">// 通过find查找元素</span></span><br><span class="line">  expect(inputs.length).toBe(<span class="number">2</span>) <span class="comment">// 应该有两个输入框</span></span><br><span class="line">  expect(loginButton).toBeTruthy() <span class="comment">// 应该有一个登录按钮。 只要断言条件不为空或这false，toBeTruthy就能通过。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>测试，还是报错！还是没有找到它们。为什么呢？再想想。应该是我们并没有将<code>element-ui</code>引入我们的测试里。因为<code>.el-input</code>实际上是<code>element-ui</code>的一个组件，如果没有引入它，vue自然无法将一个<code>el-input</code>渲染成<code>&lt;div class=&quot;el-input&quot;&gt;&lt;input&gt;&lt;/div&gt;</code>这样的形式。想通了就好说了，把它引进来。因为我们的项目里在<code>webpack</code>环境下是有一个<code>main.js</code>作为入口文件的，在测试里可没有这个东西。所以Vue自然也不知道你测试里用到了什么依赖，需要我们单独引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>再次运行测试，通过！</p><h4 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h4><p>接下来，使用Jest内置的一个特别棒的特性：快照（snapshot）。它能够将某个状态下的html结构以一个快照文件的形式存储下来，以后每次运行快照测试的时候如果发现跟之前的快照测试的结果不一致，测试就无法通过。</p><p>当然如果是以后页面确实需要发生改变，快照需要更新，那么只需要在执行jest的时候增加一个<code>-u</code>的参数，就能实现快照的更新。</p><p>说完了原理来实践一下。对于登录页，实际上我们只需要确保html结构没问题那么所有必要的元素自然就存在。因此快照测试写起来特别方便：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Should have the expected html structure'</span>, () =&gt; &#123;</span><br><span class="line">  expect(wrapper.element).toMatchSnapshot() <span class="comment">// 调用toMatchSnapshot来比对快照</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果是第一次进行快照测试，那么它会在你的测试文件所在目录下新建一个<code>__snapshots__</code>的目录存放快照文件。上面的测试就生成了一个<code>login.spec.js.snap</code>的文件，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// Jest Snapshot v1, https://goo.gl/fbAQLP</span><br><span class="line"></span><br><span class="line">exports[`Should have the expected html structure 1`] = `</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"el-row content"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"el-col el-col-24 el-col-xs-24 el-col-sm-6 el-col-sm-offset-9"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"title"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      </span><br><span class="line">     欢迎登录</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"el-row"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"el-input"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">          <span class="attr">autocomplete</span>=<span class="string">"off"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"el-input__inner"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">"账号"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"el-input"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">          <span class="attr">autocomplete</span>=<span class="string">"off"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"el-input__inner"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">placeholder</span>=<span class="string">"密码"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"el-button el-button--primary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="comment">&lt;!----&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">          登录</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>可以看到它将整个html结构以快照的形式保存下来了。快照测试能确保我们的前端页面结构的完整性和稳定性。</p><h4 id="methods测试"><a href="#methods测试" class="headerlink" title="methods测试"></a>methods测试</h4><p>很多时候我们需要测试在某些情况下，Vue中的一些methods能否被触发。比如本例里的，我们点击登录按钮应对要触发<code>loginToDo</code>这个方法。于是就涉及到了<code>methods</code>的测试，这个时候<code>vue-test-utils</code>提供的<code>setMethods</code>这个方法就很有用了。我们可以通过设置（覆盖）<code>loginToDo</code>这个方法，来查看它是否被触发了。</p><blockquote><p>注意，一旦setMethods了某个方法，那么在某个test()内部，这个方法原本的作用将完全被你的新function覆盖。包括这个Vue实例里其他methods通过<code>this.xxx()</code>方式调用也一样。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'loginToDo should be called after clicking the button'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> stub = jest.fn() <span class="comment">// 伪造一个jest的mock funciton</span></span><br><span class="line">  wrapper.setMethods(&#123; <span class="attr">loginToDo</span>: stub &#125;) <span class="comment">// setMethods将loginToDo这个方法覆写</span></span><br><span class="line">  wrapper.find(<span class="string">'.el-button'</span>).trigger(<span class="string">'click'</span>) <span class="comment">// 对button触发一个click事件</span></span><br><span class="line">  expect(stub).toBeCalled() <span class="comment">// 查看loginToDo是否被调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意到这里我们用到了<code>jest.fn</code>这个方法，这个在下节会详细说明。此处你只需要明白这个是jest提供的，可以用来检测是否被调用的方法。</p><h4 id="mock方法测试"><a href="#mock方法测试" class="headerlink" title="mock方法测试"></a>mock方法测试</h4><p>接下去就是对登录这个功能的测试了。由于我们之前把Koa的后端api进行了测试，所以我们在前端测试中，可以默认后端的api接口都是返回正确的结果的。（这也是我们先进行了Koa端测试的原因，保证了后端api的健壮性回到前端测试的时候就能很轻松）</p><p>虽然道理是说得通的，但是我们如何来默认、或者说“伪造”我们的api请求，以及返回的数据呢？这个时候就需要用上Jest一个非常有用的功能<code>mock</code>了。可以说<code>mock</code>这个词对很多做前端的朋友来说，不是很陌生。在没有后端，或者后端功能还未完成的时候，我们可以通过api的mock来实现伪造请求和数据。</p><p>Jest的mock也是同理，不过它更厉害的一点是，它能伪造库。比如我们接下去要用的HTTP请求库<code>axios</code>。对于我们的页面来说，登录只需要发送post请求，判断返回的<code>success</code>是否是<code>true</code>即可。我们先来mock一下<code>axios</code>以及它的<code>post</code>请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  post: jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      info: <span class="string">'用户不存在！'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>然后我们可以把axios引入我们的项目了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line"></span><br><span class="line">jest.mock(....)</span><br></pre></td></tr></table></figure><p>等会，你肯定会提出疑问，<code>jest.mock()</code>方法写在了<code>import axios from &#39;axios&#39;</code>下面，那么不就意味着<code>axios</code>是从<code>node_modules</code>里引入的吗？其实不是的，<code>jest.mock()</code>会实现函数提升，也就是实际上上面的代码其实和下面的是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(....)</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'../../src/components/Login.vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span> <span class="comment">// 这里的axios是来自jest.mock()里的axios</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure><p>看起来甚至有些<code>var</code>的变量提升的味道。</p><p>不过这样的好处是很明显的，我们可以在不破坏<code>eslint</code>的规则的情况下采用第一种的写法而达到一样的目的。</p><p>然后你还会注意到我们用到了<code>jest.fn()</code>的方法，它是jest的mock方法里很重要的一部分。它本身是一个<code>mock function</code>。通过它能够实现方法调用的追踪以及后面会说到的能够实现创建复杂行为的模拟功能。</p><p>继续我们没写完的测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Failed to login if not typing the correct password'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    account: <span class="string">'molunerfinn'</span>,</span><br><span class="line">    password: <span class="string">'1234'</span></span><br><span class="line">  &#125;) <span class="comment">// 模拟用户输入数据</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> wrapper.vm.loginToDo() <span class="comment">// 模拟异步请求的效果</span></span><br><span class="line">  expect(result.data.success).toBe(<span class="literal">false</span>) <span class="comment">// 期望返回的数据里success是false</span></span><br><span class="line">  expect(result.data.info).toBe(<span class="string">'密码错误！'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们通过<code>setData</code>来模拟用户在两个input框内输入了数据。然后通过<code>wrapper.vm.loginToDo()</code>来显式调用<code>loginTodo</code>的方法。由于我们返回的是一个<code>Promise</code>对象，所以可以用<code>async await</code>将resolve里的数据拿出来。然后测试是否和预期相符。我们这次是测试了输入错误的情况，测试通过，没有问题。那如果我接下去要再测试用户密码都通过的测试怎么办？我们<code>mock</code>的<code>axios</code>的<code>post</code>方法只有一个，难不成还能一个方法输出多种结果？下一节来详细说明这个问题。</p><h4 id="创建复杂行为测试"><a href="#创建复杂行为测试" class="headerlink" title="创建复杂行为测试"></a>创建复杂行为测试</h4><p>回顾一下我们的mock写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  post: jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">false</span>,</span><br><span class="line">      info: <span class="string">'用户不存在！'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>可以看到，采用这种写法的话，post请求始终只能返回一种结果。如何做到既能<code>mock</code>这个<code>post</code>方法又能实现多种结果测试？接下去就要用到Jest另一个杀手锏的方法：<a href="https://facebook.github.io/jest/docs/en/mock-functions.html#mock-implementations" target="_blank" rel="noopener">mockImplementationOnce</a>。官方的示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'default'</span>)</span><br><span class="line">  .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'first call'</span>)</span><br><span class="line">  .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'second call'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());</span><br><span class="line"><span class="comment">// &gt; 'first call', 'second call', 'default', 'default'</span></span><br></pre></td></tr></table></figure><p>4次调用同一个方法却能给出不同的运行结果。这正是我们想要的。</p><p>于是在我们测试登录成功这个方法的时候我们需要改写一下我们对<code>axios</code>的mock方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  post: jest.fn()</span><br><span class="line">        .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">          data: &#123;</span><br><span class="line">            success: <span class="literal">false</span>,</span><br><span class="line">            info: <span class="string">'用户不存在！'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">        .mockImplementationOnce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">          data: &#123;</span><br><span class="line">            success: <span class="literal">true</span>,</span><br><span class="line">            token: <span class="string">'xxx'</span> <span class="comment">// 随意返回一个token</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>然后开始写我们的测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Succeeded to login if typing the correct account &amp; password'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    account: <span class="string">'molunerfinn'</span>,</span><br><span class="line">    password: <span class="string">'123'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> wrapper.vm.loginToDo()</span><br><span class="line">  expect(result.data.success).toBe(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就在我认为跟之前的测试没有什么两样的时候，报错传来了。先来看看当<code>success</code>为true的时候，<code>loginToDo</code>在做什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (res.data.success) &#123; <span class="comment">// 如果成功</span></span><br><span class="line">  sessionStorage.setItem(<span class="string">'demo-token'</span>, res.data.token) <span class="comment">// 用sessionStorage把token存下来</span></span><br><span class="line">  <span class="keyword">this</span>.$message(&#123; <span class="comment">// 登录成功，显示提示语</span></span><br><span class="line">    type: <span class="string">'success'</span>,</span><br><span class="line">    message: <span class="string">'登录成功！'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.$router.push(<span class="string">'/todolist'</span>) <span class="comment">// 进入todolist页面，登录成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很快我就看到了错误所在：我们的测试环境里并没有<code>sessionStorage</code>这个原本应该在浏览器端的东西。以及我们并没有使用<code>vue-router</code>，所以就无法执行<code>this.$router.push()</code>这个方法。</p><p>关于前者，很容易找到<a href="https://stackoverflow.com/questions/30792076/mocking-sessionstorage-when-using-jestjs" target="_blank" rel="noopener">问题</a>的<a href="https://github.com/letsrock-today/mock-local-storage" target="_blank" rel="noopener">解决办法</a>。</p><p>首先安装一下<code>mock-local-storage</code>这个库（也包括了sessionStorage）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add mock-local-storage -D</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">npm install mock-local-storage --save-dev</span><br></pre></td></tr></table></figure><p>然后配置一下<code>package.json</code>里的<code>jest</code>参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"jest": &#123;</span><br><span class="line">  // ...</span><br><span class="line">  "setupTestFrameworkScriptFile": "mock-local-storage"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于后者，阅读过官方的<a href="https://vue-test-utils.vuejs.org/en/guides/common-tips.html#dealing-with-routing" target="_blank" rel="noopener">建议</a>，我们不应该引入<code>vue-router</code>，这样会破坏我们的单元测试。相应的，我们可以mock它。不过这次是用<code>vue-test-utils</code>自带的<code>mocks</code>特性了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $router = &#123; <span class="comment">// 声明一个$router对象</span></span><br><span class="line">  push: jest.fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = mount(Login, &#123;</span><br><span class="line">    mocks: &#123;</span><br><span class="line">      $router <span class="comment">// 在beforeEach钩子里挂载进mount的mocks里。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过这个方式，会把<code>$router</code>这个对象挂载到实例的<code>prototype</code>上，就能实现在组件内部通过<code>this.$router.push()</code>的方式来调用了。</p><p>上述两个问题解决之后，我们的测试也顺利通过了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj15nzsg0j215c06aq4c.jpg" alt></p><p>接下去开始测试<code>Todolist.vue</code>这个组件了。</p><h3 id="Todolist-vue的测试"><a href="#Todolist-vue的测试" class="headerlink" title="Todolist.vue的测试"></a>Todolist.vue的测试</h3><h4 id="键盘事件测试以及隐式事件触发"><a href="#键盘事件测试以及隐式事件触发" class="headerlink" title="键盘事件测试以及隐式事件触发"></a>键盘事件测试以及隐式事件触发</h4><p>类似的我们在<code>test/client</code>目录下创建一个叫做<code>todolist.spec.js</code>的文件。</p><p>先把上例中的一些环境先预置进来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> elementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'vue-test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Todolist <span class="keyword">from</span> <span class="string">'../../src/components/Todolist.vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.use(elementUI)</span><br><span class="line"></span><br><span class="line">jest.mock(...) <span class="comment">// 后续补充</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  wrapper = mount(Todolist)</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    name: <span class="string">'Molunerfinn'</span>, <span class="comment">// 预置数据</span></span><br><span class="line">    id: <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>先来个简单的，测试数据是否正确：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test 1</span></span><br><span class="line">test(<span class="string">'Should get the right username &amp; id'</span>, () =&gt; &#123;</span><br><span class="line">  expect(wrapper.vm.name).toBe(<span class="string">'Molunerfinn'</span>)</span><br><span class="line">  expect(wrapper.vm.id).toBe(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不过需要注意的是，<code>todolist</code>这个页面在<code>created</code>阶段就会触发<code>getUserInfo</code>和<code>getTodolist</code>这两个方法，而我们的wrapper是相当于在<code>mounted</code>阶段之后的。所以在我们拿到wrapper的时候，<code>created</code>、<code>mounted</code>等生命周期的钩子其实已经运行了。本例里<code>getUserInfo</code>是从<code>sessionStorage</code>里取值，不涉及ajax请求。但是<code>getTodolist</code>涉及请求，因此需要在jest.mock方法里为其配置一下，否则将会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; (&#123;</span><br><span class="line">  <span class="keyword">get</span>: jest.fn()</span><br><span class="line">        // for test 1</span><br><span class="line">        .mockImplementationOnce(() =&gt; Promise.resolve(&#123;</span><br><span class="line">          status: <span class="number">200</span>,</span><br><span class="line">          data: &#123;</span><br><span class="line">            result: []</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>上面说到的<code>getTodolist</code>和<code>getUserInfo</code>就是在测试中需要注意的隐式事件，它们并不受你测试的控制就在组件里触发了。</p><p>接下来开始进行键盘事件测试。其实跟鼠标事件类似，键盘事件的触发也是以事件名来命名的。不过对于一些常见的事件，<code>vue-test-utils</code>里给出了一些别名比如：</p><p><code>enter, tab, delete, esc, space, up, down, left, right</code>。你在书写测试的时候可以直接这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = wrapper.find(<span class="string">'.el-input'</span>)</span><br><span class="line">input.trigger(<span class="string">'keyup.enter'</span>)</span><br></pre></td></tr></table></figure><p>当然如果你需要指定某个键也是可以的，只需要提供keyCode就行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = wrapper.find(<span class="string">'.el-input'</span>)</span><br><span class="line">input.trigger(<span class="string">'keyup'</span>， &#123;</span><br><span class="line">  which: <span class="number">13</span> <span class="comment">// enter的keyCode为13</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>于是我们把这个测试完善一下，这个测试是测试当我在输入框激活的情况下按下回车键能否触发<code>addTodos</code>这个事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Should trigger addTodos when typing the enter key'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> stub = jest.fn()</span><br><span class="line">  wrapper.setMethods(&#123;</span><br><span class="line">    addTodos: stub</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> input = wrapper.find(<span class="string">'.el-input'</span>)</span><br><span class="line">  input.trigger(<span class="string">'keyup.enter'</span>)</span><br><span class="line">  expect(stub).toBeCalled()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>没有问题，一次通过。</p><p>注意到我们在实际开发时，在组件上调用原生事件是需要加<code>.native</code>修饰符的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入待办事项"</span> <span class="attr">v-model</span>=<span class="string">"todos"</span> @<span class="attr">keyup.enter.native</span>=<span class="string">"addTodos"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在<code>vue-test-utils</code>里你是可以直接通过原生的<code>keyup.enger</code>来触发的。</p><h4 id="wrapper-update-的使用"><a href="#wrapper-update-的使用" class="headerlink" title="wrapper.update()的使用"></a>wrapper.update()的使用</h4><p>很多时候我们要跟异步打交道。尤其是异步取值，异步赋值，页面异步更新。而对于使用Vue来做的实际开发来说，异步的情况简直太多了。</p><p>还记得<code>nextTick</code>么？很多时候，我们要获取一个变更的数据结果，不能直接通过<code>this.xxx</code>获取，相应的我们需要在<code>this.$nextTick()</code>里获取。在测试里我们也会遇到很多需要异步获取的情况，但是我们不需要<code>nextTick</code>这个办法，相应的我们可以通过<code>async await</code>配合<code>wrapper.update()</code>来实现组件更新。例如下面这个测试添加todo成功的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'Should add a todo if handle in the right way'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  wrapper.setData(&#123;</span><br><span class="line">    todos: <span class="string">'Test'</span>,</span><br><span class="line">    stauts: <span class="string">'0'</span>,</span><br><span class="line">    id: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> wrapper.vm.addTodos()</span><br><span class="line">  <span class="keyword">await</span> wrapper.update()</span><br><span class="line">  expect(wrapper.vm.list).toEqual([</span><br><span class="line">    &#123;</span><br><span class="line">      status: <span class="string">'0'</span>,</span><br><span class="line">      content: <span class="string">'Test'</span>,</span><br><span class="line">      id: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在本例中，从进页面到添加一个todo并显示出来需要如下步骤：</p><ol><li>getUserInfo -&gt; getTodolist</li><li>输入todo并敲击回车</li><li>addTodos -&gt; getTodolist</li><li>显示添加的todo</li></ol><p>可以看到总共有3个ajax请求。其中第一步不在我们test()的范围内，2、3、4都是我们能控制的。而addTodos和getTodolist这两个ajax请求带来的就是异步的操作。虽然我们mock方法，但是本质上是返回了Promise对象。所以还是需要用<code>await</code>来等待。</p><blockquote><p>注意你在jest.mock()里要加上相应的mockImplementationOnce的get和post请求。</p></blockquote><p>所以第一步<code>await wrapper.vm.addTodos()</code>就是等待<code>addTodos()</code>的返回。<br>第二步<code>await wrapper.update()</code>实际是在等待<code>getTodolist</code>的返回。</p><p>缺一不可。两步等待之后我们就可以通过断言数据<code>list</code>的方式测试我们是否拿到了返回的todo的信息。</p><p>接下去的就是对todo的一些增删改查的操作，采用的测试方法已经和前文所述相差无几，不再赘述。至此所有的独立测试用例的说明就说完了。看看这测试通过的成就感：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2hpjeprj213606udhc.jpg" alt></p><p>不过在测试中我还有关于调试的一些经验想分享一下，配合调试能更好的判断我们的测试的时候发生的不可预知的问题所在。</p><h3 id="用VSCode来调试测试"><a href="#用VSCode来调试测试" class="headerlink" title="用VSCode来调试测试"></a>用VSCode来调试测试</h3><p>由于我自己是使用VSCode来做的开发和调试，所以一些用其他IDE或者编辑器的朋友们可能会有所失望。不过没关系，可以考虑加入VSCode阵营嘛！</p><p>本文撰写的时候采用的nodejs版本为<code>8.9.0</code>，VSCode版本为<code>1.18.0</code>，所以所有的debug测试的配置仅保证适用于目前的环境。其他环境的可能需要自行测试一下，不再多说。</p><p>关于jest的调试的配置如下：（注意配置路径为VScode关于本项目的<code>.vscode/launch.json</code>）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Use IntelliSense to learn about possible Node.js debug attributes.</span><br><span class="line">  // Hover to view descriptions of existing attributes.</span><br><span class="line">  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  "version": "0.2.0",</span><br><span class="line">  "configurations": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Debug Jest"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/node_modules/jest-cli/bin/jest.js"</span>,</span><br><span class="line">      <span class="attr">"stopOnEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"--runInBand"</span>,</span><br><span class="line">        <span class="string">"--forceExit"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"runtimeExecutable"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">        <span class="string">"--nolazy"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"env"</span>: &#123;</span><br><span class="line">        <span class="attr">"NODE_ENV"</span>: <span class="string">"test"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"console"</span>: <span class="string">"integratedTerminal"</span>,</span><br><span class="line">      <span class="attr">"sourceMaps"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完上面的配置之后，你可以在<code>DEBUG</code>面板里（不要跟我说你不知道什么是DEBUG面板~）找到名为<code>Debug Jest</code>的选项：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2s0qhxkj20og09kq3p.jpg" alt></p><p>然后你可以在你的测试文件里打断点了：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2uakvi4j21bk09oq5s.jpg" alt></p><p>然后运行debug模式，按那个绿色启动按钮，就能进入DEBUG模式，当运行到断点处就会停下：</p><p><img src="https://ws1.sinaimg.cn/large/8700af19ly1flj2y2hpeaj21fa09u41u.jpg" alt></p><p>于是你可以在左侧面板的<code>Local</code>和<code>Closure</code>里找到当前作用域下你所需要的变量值、变量类型等等。充分运用VSCode的debug模式，开发的时候查错和调试的效率都会大大加大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文用了很大的篇幅描述了如何搭建一个Jest测试环境，并在测试过程中不断完善我们的测试环境。讲述了Koa后端测试的方法和测试覆盖率的提高，讲述了Vue前端单元测试环境的搭建以及许多相应的测试实例，以及在测试过程中不停地遇到问题并解决问题。能够看到此处的都不是一般有耐心的人，为你们鼓掌~也希望你们通过这篇文章能过对本文在开头提出的几个重点在心中有所体会和感悟：</p><blockquote><p>可以了解到测试的意义，<a href="https://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>测试框架的搭建，前后端测试的异同点，如何写测试用例，如何查看测试结果并提升我们的测试覆盖率，100%测试覆盖率是否是必须，以及在搭建测试环境、以及测试本身过程中遇到的各种疑难杂症。</p></blockquote><p>本文所有的测试用例以及整体项目实例你都可以在我的<a href="https://github.com/Molunerfinn/vue-koa-demo" target="_blank" rel="noopener">vue-koa-demo</a>的github项目中找到源代码。如果你喜欢我的文章以及项目，欢迎点个star~如果你对我的文章和项目有任何建议或者意见，欢迎在文末评论或者在本项目的<a href="https://github.com/Molunerfinn/vue-koa-demo/issues" target="_blank" rel="noopener">issues</a>跟我探讨！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><p>Koa相关</p></blockquote><p><a href="https://segmentfault.com/q/1010000006906863" target="_blank" rel="noopener">Supertest搭配koa报错</a></p><p><a href="http://facebook.github.io/jest/docs/en/cli.html#forceexit" target="_blank" rel="noopener">测试完自动退出</a></p><p><a href="https://hackernoon.com/async-testing-koa-with-jest-1b6e84521b71" target="_blank" rel="noopener">Async testing Koa with Jest</a></p><p><a href="http://www.albertgao.xyz/2017/06/10/how-to-use-jest-to-test-express-middleware-or-a-function-which-consumes-a-callback/" target="_blank" rel="noopener">How to use Jest to test Express middleware or a funciton which consumes a callback?</a></p><p><a href="https://www.valentinog.com/blog/testing-api-koa-jest/" target="_blank" rel="noopener">A clear and concise introduction to testing Koa with Jest and Supertest</a></p><p><a href="https://github.com/Microsoft/vscode/issues/28007" target="_blank" rel="noopener">Debug jest with vscode</a></p><p><a href="https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment" target="_blank" rel="noopener">Test port question</a><br><a href="https://github.com/facebook/jest/issues/4777" target="_blank" rel="noopener">Coverage bug</a></p><p><a href="https://stackoverflow.com/questions/41733634/eaddrinuse-127-0-0-15858-during-jest-test-debugging" target="_blank" rel="noopener">Eaddrinuse bug</a></p><p><a href="https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md" target="_blank" rel="noopener">Istanbul ignore</a></p><blockquote><p>Vue相关</p></blockquote><p><a href="https://vue-test-utils.vuejs.org/en/" target="_blank" rel="noopener">vue-test-utils</a></p><p><a href="https://alexjoverm.github.io/2017/09/25/Test-Methods-and-Mock-Dependencies-in-Vue-js-with-Jest/" target="_blank" rel="noopener">Test Methods and Mock Dependencies in Vue.js with Jest</a></p><p><a href="https://stackoverflow.com/questions/30792076/mocking-sessionstorage-when-using-jestjs" target="_blank" rel="noopener">Storage problem</a></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Molunerfinn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/">https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/前端/">前端</a><a class="post-meta__tags" href="/tags/Vue/">Vue</a><a class="post-meta__tags" href="/tags/Nodejs/">Nodejs</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ws1.sinaimg.cn/large/8700af19ly1fjmba1eumhj20jz0jzq4b.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://ws1.sinaimg.cn/large/8700af19ly1fjmbbmp7uwj20jm0jmt9a.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5994f8f0fea9a5f4" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/make-a-picgo/"><i class="fa fa-chevron-left"></i><span>PicGo——一个基于Electron的图片上传+简单管理的工具</span></a></div><div class="next-post pull-right"><a href="/git-ssh2https/"><span>把你的github操作从ssh转成https</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="100%" height="90"></a></div><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"f7b6cca0b0a65f07a027",clientSecret:"84b5ccac558161d1bdaa50fc498619fca9d4c640",repo:"Molunerfinn.github.io",owner:"Molunerfinn",admin:"Molunerfinn",id:md5(decodeURI(location.pathname)),language:"en"});gitalk.render("gitalk-container")</script></div></div><footer class="footer-bg" style="background-image:url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Molunerfinn</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"))</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>